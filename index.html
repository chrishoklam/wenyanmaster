<!--
   * WenyanMaster - 文言大師之旅 © 2025
   * All rights reserved. Unauthorized copying or reproduction is prohibited.
   -->
<!DOCTYPE html>
<html lang="zh-TW">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>文言大師之旅</title>
      <link rel="manifest" href="manifest.json">
      <!-- iOS 额外配置 -->
      <link rel="apple-touch-icon" href="https://i.imgur.com/tuMkTTR.png">
      <meta name="apple-mobile-web-app-capable" content="yes">
      <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
      <meta name="apple-mobile-web-app-title" content="文言大師之旅">
      <meta name="theme-color" content="#ffffff">
      <script src="https://cdn.tailwindcss.com"></script>
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
      <!-- 添加html2canvas库 - 用于截图功能 -->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
      <script>
         tailwind.config = {
             darkMode: 'class',
             theme: {
                 extend: {
                     colors: {
                         primary: '#5D5CDE',
                         /* 遊戲界面顏色 */
                         paper: {
                             light: '#f9f9ec',
                             dark: '#2a2a2a'
                         }
                     },
                     fontFamily: {
                         'sans': ['Noto Sans TC', 'sans-serif'],
                         'serif': ['"Noto Serif TC"', 'serif'],
                     }
                 }
             }
         }
      </script>
      <style>
         @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+TC:wght@400;500;700&display=swap');
         body {
         overflow-x: hidden;
         }
         /* 滑塊樣式 */
         input:checked + .slider:before {
           transform: translateX(21px);
         }
         .game-mode-switch-container {
           min-width: 120px;
           justify-content: center;
         }
         /* 8-bit 像素風格頭像樣式 */
         .pixel-avatar {
         image-rendering: pixelated;
         image-rendering: -moz-crisp-edges;
         image-rendering: crisp-edges;
         width: 100%;
         height: 100%;
         display: flex;
         align-items: center;
         justify-content: center;
         }
         .avatar-option {
         width: 60px;
         height: 60px;
         border-radius: 8px;
         cursor: pointer;
         transition: all 0.2s ease;
         overflow: hidden;
         position: relative;
         border: 2px solid transparent;
         background-color: #f0f0f0;
         }
         .dark .avatar-option {
         background-color: #333;
         }
         .avatar-option:hover {
         transform: scale(1.05);
         box-shadow: 0 3px 8px rgba(0,0,0,0.2);
         }
         .avatar-option.selected {
         border-color: #5D5CDE;
         box-shadow: 0 0 0 2px rgba(93, 92, 222, 0.3);
         }
         .book {
         perspective: 1200px;
         }
         .page {
         transform-origin: center left;
         transition: transform 0.6s cubic-bezier(0.645, 0.045, 0.355, 1.000);
         transform-style: preserve-3d;
         box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
         }
         .page.turned {
         transform: rotateY(-180deg);
         }
         .page-content {
         backface-visibility: hidden;
         }
         .page-back {
         backface-visibility: hidden;
         transform: rotateY(180deg);
         }
         .character {
         animation: fadeIn 0.5s ease-in-out;
         text-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
         }
         .dark .character {
         text-shadow: 0 2px 5px rgba(255, 255, 255, 0.2);
         }
         .option-btn {
         transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
         box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
         animation: flyIn 0.6s cubic-bezier(0.19, 1, 0.22, 1) backwards;
         transform-style: preserve-3d;
         perspective: 1000px;
         position: relative;
         overflow: hidden;
         will-change: transform;
         }
         .option-btn:nth-child(1) { animation-delay: 0s; }
         .option-btn:nth-child(2) { animation-delay: 0.1s; }
         .option-btn:nth-child(3) { animation-delay: 0.2s; }
         .option-btn:before {
         content: '';
         position: absolute;
         top: -50%;
         left: -50%;
         width: 200%;
         height: 200%;
         background: linear-gradient(
         to bottom right,
         rgba(255, 255, 255, 0.3) 0%,
         rgba(255, 255, 255, 0) 50%,
         rgba(255, 255, 255, 0) 100%
         );
         transform: rotate(30deg);
         transition: transform 0.7s;
         }
         .option-btn:hover:before {
         transform: rotate(30deg) translate(10%, 10%);
         }
         .option-btn:hover {
         transform: translateY(-3px) translateZ(20px) rotateX(10deg);
         box-shadow: 0 15px 25px rgba(0, 0, 0, 0.4);
         }
         @keyframes flyIn {
         0% {
         opacity: 0;
         transform: translateZ(-300px) scale(0.5) rotateX(20deg);
         }
         70% {
         opacity: 1;
         transform: translateZ(50px) scale(1.05) rotateX(-5deg);
         }
         100% {
         transform: translateZ(0) scale(1) rotateX(0);
         }
         }
         .option-btn.correct {
         background-color: rgba(34, 197, 94, 0.8);
         color: white;
         animation: correct-pulse 0.5s ease-in-out;
         }
         @keyframes correct-pulse {
         0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
         50% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
         100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
         }
         .option-btn.incorrect {
         background-color: rgba(239, 68, 68, 0.8);
         color: white;
         animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
         }
         @keyframes shake {
         10%, 90% { transform: translate3d(-1px, 0, 0); }
         20%, 80% { transform: translate3d(2px, 0, 0); }
         30%, 50%, 70% { transform: translate3d(-3px, 0, 0); }
         40%, 60% { transform: translate3d(3px, 0, 0); }
         }
         .dark .option-btn {
         box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
         }
         .dark .page {
         box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
         }
         /* 統一動畫定義 */
         /* 淡入淡出動畫 */
         @keyframes fadeIn {
         from { opacity: 0; transform: translateY(10px); }
         to { opacity: 1; transform: translateY(0); }
         }
         @keyframes fadeOut {
         from { opacity: 1; }
         to { opacity: 0; }
         }
         @keyframes fadeInOut {
         0% { opacity: 0; transform: translate(-50%, -20px); }
         15% { opacity: 1; transform: translate(-50%, 0); }
         85% { opacity: 1; transform: translate(-50%, 0); }
         100% { opacity: 0; transform: translate(-50%, -20px); }
         }
         /* 震動效果 */
         @keyframes screen-shake {
         0%, 100% { transform: translateX(0); }
         10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
         20%, 40%, 60%, 80% { transform: translateX(5px); }
         }
         @keyframes game-over-shake {
         0%, 100% { transform: translateX(0); }
         10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
         20%, 40%, 60%, 80% { transform: translateX(10px); }
         }
         /* 脈動效果 */
         @keyframes heart-pulse {
         0% { transform: scale(1); }
         50% { transform: scale(1.2); }
         100% { transform: scale(1); }
         }
         @keyframes countdownPulse {
         0% { transform: scale(1.2); opacity: 0.5; }
         50% { transform: scale(1.5); opacity: 1; }
         100% { transform: scale(1); opacity: 0.7; }
         }
         @keyframes correct-pulse {
         0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
         50% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
         100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
         }
         /* 特效動畫 */
         @keyframes bounce {
         0%, 100% { transform: translateY(0); }
         50% { transform: translateY(-10px); }
         }
         @keyframes inkSplash {
         0% { transform: scale(0); opacity: 0.8; }
         70% { opacity: 0.3; }
         100% { transform: scale(15); opacity: 0; }
         }
         @keyframes flyIn {
         0% {
         opacity: 0;
         transform: translateZ(-300px) scale(0.5) rotateX(20deg);
         }
         70% {
         opacity: 1;
         transform: translateZ(50px) scale(1.05) rotateX(-5deg);
         }
         100% {
         transform: translateZ(0) scale(1) rotateX(0);
         }
         }
         @keyframes pauseMenuAppear {
         from { opacity: 0; transform: scale(0.9); }
         to { opacity: 1; transform: scale(1); }
         }
         /* 動畫類 */
         .fade-out {
         animation: fadeOut 0.5s ease forwards;
         }
         .screen-shake {
         animation: screen-shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
         }
         .game-over-shake {
         animation: game-over-shake 0.8s ease-in-out;
         }
         .animate-pulse {
         animation: heart-pulse 1.5s ease-in-out infinite;
         }
         .animate-bounce {
         animation: bounce 1s ease infinite;
         }
         .pause-countdown-number {
         animation: countdownPulse 1s ease-out;
         }
         /* 墨滴效果 - 使用CSS變量 */
         :root {
         --ink-drop-color: rgba(0, 0, 0, 0.7);
         --ink-drop-color-dark: rgba(255, 255, 255, 0.5);
         --ink-animation-duration: 2s;
         --ink-animation-timing: cubic-bezier(0.165, 0.84, 0.44, 1);
         }
         .ink-drop {
         position: absolute;
         top: 0;
         left: 0;
         width: 10px;
         height: 10px;
         border-radius: 50%;
         background-color: var(--ink-drop-color);
         opacity: 0;
         transform: scale(0);
         animation: inkSplash var(--ink-animation-duration) var(--ink-animation-timing) forwards;
         }
         .dark .ink-drop {
         background-color: var(--ink-drop-color-dark);
         }
         /* 3D书本 */
         .book {
         transform-style: preserve-3d;
         }
         .book:after {
         content: '';
         position: absolute;
         top: 0;
         right: 0;
         bottom: 0;
         width: 30px;
         background: linear-gradient(to right, rgba(0,0,0,0.1), rgba(0,0,0,0.4));
         transform: translateX(100%) rotateY(90deg);
         transform-origin: left;
         }
         /* 成就徽章樣式 */
         .achievement-seal {
         width: 80px;
         height: 80px;
         position: relative;
         display: inline-flex;
         justify-content: center;
         align-items: center;
         margin: 0 0px 0px;
         transform: rotate(-5deg);
         }
         .achievement-seal svg {
         position: absolute;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         }
         .seal-text {
         position: relative;
         z-index: 5;
         font-family: 'Noto Serif TC', serif;
         font-weight: bold;
         text-align: center;
         display: flex;
         flex-direction: column;
         color: #fff;
         line-height: 1.2;
         }
         .seal-title {
         font-size: 14px;
         margin-bottom: 2px;
         }
         .seal-desc {
         font-size: 10px;
         opacity: 0.9;
         }
         .achievements-container {
         display: flex;
         flex-wrap: wrap;
         justify-content: center;
         margin-bottom: 10px;
         }
         /* 暫停菜單動畫 */
         @keyframes pauseMenuAppear {
         from { opacity: 0; transform: scale(0.9); }
         to { opacity: 1; transform: scale(1); }
         }
         #pause-overlay > div {
         animation: pauseMenuAppear 0.3s ease-out;
         }
         /* 倒計時數字動畫 */
         .pause-countdown-number {
         animation: countdownPulse 1s ease-out;
         }
         @keyframes countdownPulse {
         0% { transform: scale(1.2); opacity: 0.5; }
         50% { transform: scale(1.5); opacity: 1; }
         100% { transform: scale(1); opacity: 0.7; }
         }
         /* 優化篇章列表和段落選擇器的滾動條樣式 */
         #passage-list, #paragraph-list, .paragraph-options {
         scrollbar-width: thin;
         scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
         }
         #passage-list::-webkit-scrollbar, #paragraph-list::-webkit-scrollbar, .paragraph-options::-webkit-scrollbar {
         width: 6px;
         }
         #passage-list::-webkit-scrollbar-track, #paragraph-list::-webkit-scrollbar-track, .paragraph-options::-webkit-scrollbar-track {
         background: transparent;
         }
         #passage-list::-webkit-scrollbar-thumb, #paragraph-list::-webkit-scrollbar-thumb, .paragraph-options::-webkit-scrollbar-thumb {
         background-color: rgba(156, 163, 175, 0.5);
         border-radius: 6px;
         }
         /* 確保篇章和段落選擇器有合適的內距 */
         .passage-item, #paragraph-list > div {
         padding: 0.5rem;
         margin-bottom: 0.25rem;
         }
         /* 確保可見性指示器 */
         .passage-item.hidden, #paragraph-selector.hidden {
         display: none;
         }
         /* 優化段落選項容器 */
         .paragraph-options {
         max-height: 300px;
         overflow-y: auto;
         margin-bottom: 10px;
         padding-right: 10px;
         }
         /* 改進確定按鈕樣式和位置 */
         #confirm-paragraphs {
         position: sticky;
         bottom: 0;
         margin-top: 10px;
         width: 100%;
         padding: 8px;
         font-weight: 500;
         box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
         }
      </style>
      <!-- 慶祝動畫和載入動畫樣式 -->
      <style>
         #confetti-canvas {
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         pointer-events: none;
         z-index: 100;
         }
         /* 墨水擴散動畫樣式 - 簡化版 */
         #loading-container {
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         background-color: rgba(245, 242, 234, 1); /* 完全不透明背景 */
         display: flex;
         justify-content: center;
         align-items: center;
         z-index: 9999; /* 更高的 z-index 確保覆蓋所有元素 */
         opacity: 0;
         animation: fadeIn 0.15s ease forwards;
         overflow: hidden;
         }
         #main-splash {
         position: absolute;
         width: 220px;
         height: 220px;
         top: 50%;
         left: 50%;
         background-color: rgba(0, 0, 0, 0.85);
         border-radius: 50%;
         transform-origin: center;
         transform: translate(-50%, -50%) scale(0);
         opacity: 0;
         animation: mainSplash 0.8s cubic-bezier(0.19, 1, 0.22, 1) forwards;
         }
         @keyframes mainSplash {
         0% { 
         transform: translate(-50%, -50%) scale(0); 
         opacity: 0.9;
         border-radius: 50%;
         }
         20% { 
         opacity: 0.8;
         }
         100% { 
         transform: translate(-50%, -50%) scale(4.5); 
         opacity: 0;
         border-radius: 48%;
         }
         }
         @keyframes fadeIn {
         from { opacity: 0; }
         to { opacity: 1; }
         }
         @keyframes fadeOut {
         from { opacity: 1; }
         to { opacity: 0; }
         }
         .fade-out {
         animation: fadeOut 0.5s ease forwards;
         }
         /* 啟動界面樣式 */
         #start-screen {
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         background-image: url('https://i.imgur.com/ACyJYTg.png');
         background-color: rgba(0, 0, 0, 0.7);
         background-blend-mode: overlay;
         background-size: cover;
         background-position: center;
         display: flex;
         flex-direction: column;
         justify-content: center;
         align-items: center;
         z-index: 10000;
         transition: opacity 0.8s ease;
         }
         .start-title {
         font-size: 2.5rem;
         font-weight: bold;
         color: white;
         text-align: center;
         margin-bottom: 3rem;
         text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
         line-height: 1.3;
         }
         .start-button {
         position: relative;
         padding: 0.8rem 2.5rem;
         color: white;
         border: none;
         font-size: 1.25rem;
         font-weight: 500;
         cursor: pointer;
         transition: all 0.3s ease;
         margin-bottom: 2.5rem;
         /* 純黑白水墨風格 */
         background-color: rgba(0, 0, 0, 0.9);
         border-radius: 0.5rem;
         overflow: hidden;
         /* 簡潔陰影 */
         box-shadow: 
         0 4px 10px rgba(0, 0, 0, 0.4),
         inset 0 0 3px rgba(255, 255, 255, 0.15);
         /* 添加毛筆邊緣效果 */
         border: 1px solid rgba(255, 255, 255, 0.1);
         }
         .start-button::before {
         content: '';
         position: absolute;
         top: 0;
         left: 0;
         right: 0;
         bottom: 0;
         /* 輕微的黑白變化，模擬墨跡濃淡 */
         background: 
         radial-gradient(ellipse at top left, rgba(60, 60, 60, 0.5) 0%, transparent 70%),
         radial-gradient(ellipse at bottom right, rgba(20, 20, 20, 0.8) 0%, transparent 70%);
         opacity: 0.7;
         z-index: -1;
         }
         .start-button::after {
         content: '';
         position: absolute;
         top: 0;
         left: 0;
         right: 0;
         bottom: 0;
         /* 水墨紋理效果 */
         background-image: url('data:image/svg+xml;utf8,
         <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
            <filter id="noise">
               <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="2" stitchTiles="stitch"/>
               <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.3 0"/>
            </filter>
            <rect width="100%" height="100%" filter="url(%23noise)"/>
         </svg>
         ');
         opacity: 0.07;
         mix-blend-mode: overlay;
         z-index: -1;
         pointer-events: none;
         }
         .start-button:hover {
         transform: translateY(-2px);
         box-shadow: 
         0 6px 12px rgba(0, 0, 0, 0.5),
         inset 0 0 5px rgba(255, 255, 255, 0.2);
         /* 懸停時變暗一點，模擬墨色加深 */
         background-color: rgba(0, 0, 0, 1);
         }
         .start-button:active {
         transform: translateY(0);
         box-shadow: 
         0 2px 6px rgba(0, 0, 0, 0.4),
         inset 0 0 3px rgba(255, 255, 255, 0.1);
         }
         .version-info {
         color: rgba(255, 255, 255, 0.8);
         font-size: 0.9rem;
         }
      </style>
   </head>
   <body class="bg-white font-serif min-h-screen bg-cover bg-center bg-fixed" style="background-image: url('https://i.imgur.com/ACyJYTg.png'); background-color: rgba(255, 255, 255, 0.8); background-blend-mode: overlay;">
      <!-- 啟動界面 -->
      <div id="start-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-cover bg-center" style="background-image: url('https://i.imgur.com/ACyJYTg.png'); background-color: rgba(0, 0, 0, 0.7); background-blend-mode: overlay;">
         <div class="text-center p-8 max-w-xl">
            <h1 class="start-title mb-10 text-4xl md:text-5xl font-bold text-white leading-tight drop-shadow-lg">文言大師之旅</h1>
            <button id="start-journey-btn" class="start-button text-xl font-medium px-8 py-3 bg-primary hover:bg-primary/90 text-white rounded-lg transform transition hover:scale-105">
            進入
            </button>
            <p class="version-info mt-10 text-white/70 text-sm">v1.5</p>
         </div>
      </div>
      <!-- 暫停菜單覆蓋層 - 改進按鈕垂直居中 -->
      <div id="pause-overlay" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
         <div class="bg-white dark:bg-gray-800 rounded-lg p-8 py-12 max-w-sm w-full mx-4 flex flex-col items-center justify-center">
            <div id="pause-buttons" class="flex justify-center gap-8 mb-8">
               <button id="restart-from-pause-btn" class="w-16 h-16 bg-amber-500 text-white rounded-full hover:bg-amber-600 transition-colors flex items-center justify-center text-xl" title="重新開始">
               <i class="fas fa-redo"></i>
               </button>
               <button id="continue-btn" class="w-16 h-16 bg-primary text-white rounded-full hover:bg-opacity-90 flex items-center justify-center text-xl" title="繼續遊戲">
               <i class="fas fa-play"></i>
               </button>
               <button id="return-home-btn" class="w-16 h-16 bg-green-600 text-white rounded-full hover:bg-green-700 transition-colors flex items-center justify-center text-xl" title="返回主頁">
               <i class="fas fa-home"></i>
               </button>
            </div>
            <!-- 隱藏的倒計時顯示 -->
            <div id="countdown-resume" class="hidden text-center">
               <p class="text-gray-600 dark:text-gray-300 mb-3">遊戲將在以下時間後繼續</p>
               <div class="text-4xl font-bold text-primary pause-countdown-number">3</div>
            </div>
         </div>
      </div>
      <!-- 設置按鈕 - 絕對固定不滾動 -->
      <div id="settings-button" style="position: fixed; top: 16px; left: 16px; width: 48px; height: 48px; background-color: #92400e; color: white; border-radius: 50%; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 9999; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s;">
         <i class="fas fa-cog text-xl"></i>
      </div>
      <!-- 設置菜單 -->
      <div id="settings-menu" class="fixed top-0 left-0 w-full h-full bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
         <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-6">
               <h2 class="text-xl font-bold text-gray-800 dark:text-gray-100">設置</h2>
               <button id="close-settings" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-gray-100">
               <i class="fas fa-times"></i>
               </button>
            </div>
            <div class="flex flex-col gap-3">
               <button data-section="help" class="settings-option py-3 px-4 bg-gray-50 dark:bg-gray-700 rounded-lg flex items-center hover:bg-gray-100 dark:hover:bg-gray-600">
               <i class="fas fa-question-circle text-primary mr-3"></i>
               <span class="text-gray-800 dark:text-gray-200 font-semibold">遊玩說明</span>
               </button>
               <button data-section="records" class="settings-option py-3 px-4 bg-gray-50 dark:bg-gray-700 rounded-lg flex items-center hover:bg-gray-100 dark:hover:bg-gray-600">
               <i class="fas fa-trophy text-amber-500 mr-3"></i>
               <span class="text-gray-800 dark:text-gray-200 font-semibold">我的記錄</span>
               </button>
               <button data-section="achievements" class="settings-option py-3 px-4 bg-gray-50 dark:bg-gray-700 rounded-lg flex items-center hover:bg-gray-100 dark:hover:bg-gray-600">
               <i class="fas fa-medal text-yellow-500 mr-3"></i>
               <span class="text-gray-800 dark:text-gray-200 font-semibold">歷史成就</span>
               </button>
               <button data-section="saveload" class="settings-option py-3 px-4 bg-gray-50 dark:bg-gray-700 rounded-lg flex items-center hover:bg-gray-100 dark:hover:bg-gray-600">
               <i class="fas fa-save text-cyan-500 mr-3"></i>
               <span class="text-gray-800 dark:text-gray-200 font-semibold">保存及載入進度</span>
               </button>
               <button data-section="version" class="settings-option py-3 px-4 bg-gray-50 dark:bg-gray-700 rounded-lg flex items-center hover:bg-gray-100 dark:hover:bg-gray-600">
               <i class="fas fa-code-branch text-green-500 mr-3"></i>
               <span class="text-gray-800 dark:text-gray-200 font-semibold">版本資訊（v1.5重大更新！）</span>
               </button>
               <button data-section="about" class="settings-option py-3 px-4 bg-gray-50 dark:bg-gray-700 rounded-lg flex items-center hover:bg-gray-100 dark:hover:bg-gray-600">
               <i class="fas fa-user text-blue-500 mr-3"></i>
               <span class="text-gray-800 dark:text-gray-200 font-semibold">關於製作者</span>
               </button>
            </div>
         </div>
      </div>
      <!-- 詳細信息模態框 -->
      <div id="info-modal" class="fixed top-0 left-0 w-full h-full bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
         <div class="bg-white dark:bg-gray-800 rounded-lg max-w-lg w-full mx-4 max-h-[80vh] flex flex-col">
            <!-- 固定在頂部的標題欄，不參與滾動 -->
            <div class="flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700 sticky top-0 bg-white dark:bg-gray-800 z-20 shadow-sm">
               <h3 id="info-modal-title" class="text-xl font-bold text-gray-800 dark:text-gray-100"></h3>
               <button id="close-info-modal" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-gray-100">
               <i class="fas fa-times"></i>
               </button>
            </div>
            <!-- 內容區域可滾動 -->
            <div class="overflow-y-auto p-6 pt-2 flex-1">
               <div id="info-modal-content" class="text-gray-700 dark:text-gray-300"></div>
            </div>
         </div>
      </div>
      <!-- 頭像選擇模態框 -->
      <div id="avatar-selector-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
         <div class="bg-white dark:bg-gray-800 rounded-lg p-5 max-w-lg w-full mx-4 max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
               <h3 class="text-xl font-bold text-gray-800 dark:text-gray-100">選擇頭像</h3>
               <button id="close-avatar-selector" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-gray-100">
               <i class="fas fa-times"></i>
               </button>
            </div>
            <div class="grid grid-cols-4 gap-3 md:grid-cols-5 md:gap-4" id="avatar-grid">
               <!-- 頭像會通過JS動態生成 -->
            </div>
         </div>
      </div>
      <div class="container mx-auto px-4 pt-16 pb-8 max-w-2xl">
         <header class="mb-8 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800 dark:text-gray-100 mb-2">文言大師之旅</h1>
            <p class="text-gray-600 dark:text-gray-300 text-m">踏上屬於自己的征途</p>
         </header>
         <div class="passage-selector mb-6">
            <div id="passage-container" class="bg-amber-800 rounded-lg overflow-hidden transition-all duration-300 shadow-md z-50" style="max-height: 46px;">
               <div id="passage-header" class="flex justify-between items-center cursor-pointer p-3 text-white">
                  <h3 class="text-lg font-medium">選擇篇章</h3>
                  <i id="passage-toggle" class="fas fa-chevron-down transition-transform duration-300"></i>
               </div>
               <div id="passage-content" class="px-3 pb-3 hidden">
                  <div class="categories mb-3 flex flex-wrap gap-2 justify-between">
                     <button class="category-btn p-2 bg-amber-100 dark:bg-amber-800 text-amber-900 dark:text-amber-100 rounded-md hover:bg-amber-200 dark:hover:bg-amber-700 text-sm flex-1" data-category="中一">中一</button>
                     <button class="category-btn p-2 bg-amber-100 dark:bg-amber-800 text-amber-900 dark:text-amber-100 rounded-md hover:bg-amber-200 dark:hover:bg-amber-700 text-sm flex-1" data-category="中二">中二</button>
                     <button class="category-btn p-2 bg-amber-100 dark:bg-amber-800 text-amber-900 dark:text-amber-100 rounded-md hover:bg-amber-200 dark:hover:bg-amber-700 text-sm flex-1" data-category="中三">中三</button>
                     <button class="category-btn p-2 bg-amber-100 dark:bg-amber-800 text-amber-900 dark:text-amber-100 rounded-md hover:bg-amber-200 dark:hover:bg-amber-700 text-sm flex-1" data-category="指定文言">指定文言</button>
                     <button class="category-btn p-2 bg-amber-100 dark:bg-amber-800 text-amber-900 dark:text-amber-100 rounded-md hover:bg-amber-200 dark:hover:bg-amber-700 text-sm flex-1" data-category="文學">文學</button>
                     <button class="category-btn p-2 bg-amber-100 dark:bg-amber-800 text-amber-900 dark:text-amber-100 rounded-md hover:bg-amber-200 dark:hover:bg-amber-700 text-sm flex-1" data-category="其他">其他</button>
                  </div>
                  <div id="passage-list" class="bg-white dark:bg-gray-800 rounded-md p-2 max-h-60 overflow-y-auto">
                     <!-- 篇章項目會在初始化時自動生成 -->
                     <!-- 空分類提示信息 -->
                     <div id="empty-category-message" class="p-4 text-center hidden">
                        <i class="fas fa-info-circle text-amber-500 text-xl mb-2"></i>
                        <p class="text-gray-600 dark:text-gray-300">此分類暫無篇章，請選擇其他分類</p>
                     </div>
                  </div>
                  <!--選擇區域段落 (默認隱藏) -->
                  <div id="paragraph-selector" class="mt-3 bg-white dark:bg-gray-800 rounded-md p-3 hidden">
                     <p class="text-gray-700 dark:text-gray-300 mb-2 font-medium">選擇背誦段落：</p>
                     <div id="paragraph-list" class="space-y-2">
                        <!-- 段落選項將在選擇篇章後動態生成 -->
                     </div>
                     <div class="mt-3">
                        <button id="confirm-paragraphs" class="px-3 py-2 bg-primary text-white rounded-lg hover:bg-opacity-90 text-base font-medium w-full">
                        確定
                        </button>
                     </div>
                  </div>
               </div>
            </div>
         </div>
         <div class="book relative mb-8">
            <!-- 用戶資料容器 - 修改成與遊戲頁面相似大小 -->
            <div id="user-profile-container" class="page rounded-lg overflow-hidden bg-white dark:bg-gray-800 p-6 md:p-8 min-h-[400px] shadow-md">
               <div class="flex flex-col h-full justify-center items-center">
                  <div id="change-avatar-btn" class="user-avatar-container w-24 h-24 md:w-32 md:h-32 bg-amber-100 dark:bg-amber-800 rounded-full flex items-center justify-center mb-6 relative cursor-pointer hover:shadow-lg transition-shadow">
                     <div id="user-avatar" class="w-full h-full flex items-center justify-center overflow-hidden">
                        <!-- 默認頭像 -->
                        <i class="fas fa-user text-4xl md:text-5xl text-amber-800 dark:text-amber-100"></i>
                     </div>
                  </div>
                  <div class="text-center w-full max-w-md">
                     <div class="flex justify-center items-center gap-3 mb-4">
                        <!-- 顯示模式 -->
                        <div id="name-display-mode" class="flex items-center">
                           <h3 id="user-name" class="text-xl font-bold text-gray-800 dark:text-gray-100">文言大師</h3>
                           <button id="edit-name-btn" class="ml-2 w-7 h-7 flex items-center justify-center bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-primary transition-colors">
                           <i class="fas fa-pen text-xs"></i>
                           </button>
                        </div>
                        <!-- 編輯模式 (默認隱藏) -->
                        <div id="name-edit-mode" class="flex flex-col items-center gap-2 hidden w-full max-w-xs mx-auto">
                           <div class="w-full relative">
                              <input type="text" id="user-name-input" class="w-full text-xl font-bold text-gray-800 dark:text-gray-100 bg-gray-100 dark:bg-gray-700 border-2 border-primary/70 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-primary shadow-sm" maxlength="12">
                              <div class="absolute right-3 bottom-2 text-xs text-gray-500 dark:text-gray-400" id="char-counter">0/12</div>
                           </div>
                           <div class="flex gap-3 mt-1">
                              <button id="save-name-btn" class="w-9 h-9 flex items-center justify-center bg-green-500 hover:bg-green-600 text-white rounded-full focus:outline-none focus:ring-2 focus:ring-green-500 transition-colors">
                              <i class="fas fa-check"></i>
                              </button>
                              <button id="cancel-name-btn" class="w-9 h-9 flex items-center justify-center bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-700 dark:text-gray-200 rounded-full focus:outline-none focus:ring-2 focus:ring-gray-400 transition-colors">
                              <i class="fas fa-times"></i>
                              </button>
                           </div>
                        </div>
                     </div>
                     <div class="w-full mb-4">
                        <div class="flex justify-between items-center mb-2">
                           <div class="flex items-center">
                              <span id="user-level" class="bg-primary text-white text-sm py-0.5 px-2 rounded-full mr-2">Lv.1</span>
                              <span class="text-sm text-gray-600 dark:text-gray-400">經驗值</span>
                           </div>
                           <span id="exp-text" class="text-sm text-gray-600 dark:text-gray-400">0 / 100</span>
                        </div>
                        <div class="h-3 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                           <div id="exp-bar" class="h-full bg-amber-500 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                     </div>
                     <div class="mt-6">
                        <div class="mb-4">
                           <h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2 flex items-center justify-between">
                              成就
                              <button id="manage-achievements-btn" class="text-sm bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 text-gray-600 dark:text-gray-300 rounded-md px-2 py-1 focus:outline-none transition-colors">
                              <i class="fas fa-cog text-xs"></i>
                              </button>
                           </h4>
                           <div id="achievements-display" class="flex justify-center flex-wrap gap-2">
                              <p class="text-sm text-gray-500 dark:text-gray-400 italic">從設置菜單的「歷史成就」中選擇展示</p>
                           </div>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
            <!-- 遊戲界面容器 -->
            <div id="game-page" class="page rounded-lg overflow-hidden hidden">
               <div class="page-content bg-paper-light dark:bg-paper-dark p-6 md:p-8 min-h-[400px] flex flex-col justify-between">
                  <!-- 遊戲控制區域 -->
                  <div class="flex justify-between items-center mb-4">
                     <div class="flex flex-col gap-2">
                        <!-- 進度條 -->
                        <div class="w-full max-w-[200px]">
                           <div class="flex justify-between items-center text-xs text-gray-600 dark:text-gray-400 mb-1">
                              <span>進度</span>
                              <span id="progress-text">0 / <span id="total-chars">0</span></span>
                           </div>
                           <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                              <div id="progress-bar" class="h-full bg-primary rounded-full transition-all duration-300" style="width: 0%"></div>
                           </div>
                        </div>
                        <!-- 生命值 -->
                        <div id="lives" class="flex text-red-500 dark:text-red-400 text-2xl">
                           <i class="fas fa-heart mx-0.5"></i>
                           <i class="fas fa-heart mx-0.5"></i>
                           <i class="fas fa-heart mx-0.5"></i>
                        </div>
                     </div>
                     <div class="flex items-center gap-2">
                        <div id="stopwatch" class="text-gray-700 dark:text-gray-300 px-3 py-1 bg-gray-100 dark:bg-gray-800 rounded-lg text-base flex items-center">
                           <i class="fas fa-stopwatch mr-2"></i><span id="timer" class="font-medium">00:00.0</span>
                        </div>
                        <!-- 暫停按鈕或返回主頁按鈕 -->
                        <button id="pause-btn" class="p-2 bg-primary text-white rounded-lg hover:bg-opacity-90 text-xl flex items-center justify-center w-10 h-10" title="暫停遊戲">
                        <i class="fas fa-pause"></i>
                        </button>
                        <button id="return-home-btn-game" class="p-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-xl flex items-center justify-center w-10 h-10 hidden" title="返回主頁">
                        <i class="fas fa-home"></i>
                        </button>
                     </div>
                  </div>
                  <div class="text-center">
                     <div class="passage-info mb-4">
                        <h2 id="passage-title" class="text-xl font-bold text-gray-800 dark:text-gray-100">《論四端》</h2>
                        <p id="passage-author" class="text-gray-600 dark:text-gray-400">孟子</p>
                     </div>
                     <div class="current-text my-6">
                        <div id="game-start-screen" class="flex flex-col items-center justify-center">
                           <div class="flex flex-col items-center justify-center gap-3">
                              <div class="flex items-center justify-center gap-3">
                                 <button id="start-game-btn" class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-opacity-90 transform hover:scale-105 transition-transform text-lg">
                                 開始
                                 </button>
                                 <button id="view-full-text-btn" class="p-3 bg-amber-100 text-amber-800 rounded-lg hover:bg-amber-200 flex items-center justify-center" title="查看完整文章">
                                 <i class="fas fa-search text-xl"></i>
                                 </button>
                              </div>
                              <!-- 單人/雙人模式切換 - 改為滑塊 -->
                              <div class="game-mode-switch-container flex items-center my-2">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300 mr-3">單人</span>
                                <label class="relative inline-block w-14 h-6">
                                  <input type="checkbox" id="game-mode-switch" class="opacity-0 w-0 h-0">
                                  <span class="slider round absolute cursor-pointer inset-0 bg-teal-600 transition-all duration-300 rounded-full before:content-[''] before:absolute before:h-5 before:w-5 before:left-0.5 before:bottom-0.5 before:bg-white before:rounded-full before:transition before:duration-300"></span>
                                </label>
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300 ml-3">雙人</span>
                              </div>
                           </div>
                        </div>
                        <div id="game-content" class="hidden">
                           <!-- 單人模式遊戲界面 -->
                           <div id="single-player-ui" class="flex flex-col items-center justify-center">
                              <div class="flex items-center justify-center">
                                 <div id="last-answered-chars" class="text-lg md:text-xl text-gray-700 dark:text-gray-300 whitespace-nowrap overflow-x-auto max-w-full h-12 flex items-center"></div>
                                 <div id="current-char" class="character text-2xl md:text-3xl font-bold text-gray-900 dark:text-gray-100 min-w-[1.2em] flex items-center justify-center ml-1"></div>
                                 <div class="text-lg text-gray-400 dark:text-gray-500">...</div>
                              </div>
                              <div id="completed-text" class="hidden"></div>
                           </div>
                           <!-- 雙人模式遊戲界面 -->
                           <div id="multiplayer-ui" class="hidden flex flex-col h-full">
                              <!-- 上方玩家區域 -->
                              <div id="player-top" class="w-full pb-4 mb-2 border-b border-gray-300 dark:border-gray-700 relative" style="transform: rotate(180deg);">
                                 <div class="flex flex-col items-center">
                                    <!-- 上方玩家控制欄 -->
                                    <div class="w-full flex justify-between items-center px-4 mb-2">
                                       <div class="flex flex-col gap-1 max-w-[150px] w-full">
                                          <div id="stopwatch-top" class="text-gray-700 dark:text-gray-300 px-3 py-1 bg-gray-100 dark:bg-gray-800 rounded-lg text-base flex items-center">
                                             <i class="fas fa-stopwatch mr-2"></i><span id="timer-top" class="font-medium">00:00.0</span>
                                          </div>
                                          <!-- 上方玩家進度條 -->
                                          <div class="px-3">
                                             <div class="flex justify-between items-center text-xs text-gray-600 dark:text-gray-400">
                                                <span>進度</span>
                                                <span id="progress-text-top">0 / <span id="total-chars-top">0</span></span>
                                             </div>
                                             <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                                                <div id="progress-bar-top" class="h-full bg-primary rounded-full transition-all duration-300" style="width: 0%"></div>
                                             </div>
                                          </div>
                                       </div>
                                       <button id="pause-btn-top" class="p-2 bg-primary text-white rounded-lg hover:bg-opacity-90 text-xl flex items-center justify-center w-10 h-10" title="暫停遊戲" style="transform: rotate(180deg);">
                                       <i class="fas fa-pause"></i>
                                       </button>
                                    </div>
                                    <div class="flex items-center justify-center">
                                       <div id="last-answered-chars-top" class="text-lg md:text-xl text-gray-700 dark:text-gray-300 whitespace-nowrap overflow-x-auto max-w-full h-12 flex items-center"></div>
                                       <div id="current-char-top" class="character text-2xl md:text-3xl font-bold text-gray-900 dark:text-gray-100 min-w-[1.2em] flex items-center justify-center ml-1"></div>
                                       <div class="text-lg text-gray-400 dark:text-gray-500">...</div>
                                    </div>
                                    <div id="options-container-top" class="grid grid-cols-3 gap-3 md:gap-4 mt-4 w-full px-4"></div>
                                    <!-- 上方玩家錯誤屏障 -->
                                    <div id="top-player-error-overlay" class="absolute inset-0 bg-black bg-opacity-70 hidden flex items-center justify-center" style="transform: rotate(180deg);">
                                       <div class="text-white font-bold flex items-center">
                                          <span id="top-error-timer" class="text-3xl text-red-500">●●●</span>
                                       </div>
                                    </div>
                                 </div>
                              </div>
                              <!-- 中間區域 - 僅用於倒計時 -->
                              <div class="flex-grow flex items-center justify-center relative min-h-[50px]">
                                 <!-- 倒計時區域 - 增加覆蓋整個畫面的半透明黑色背景並加大綠點 -->
                                 <div id="multiplayer-countdown" class="fixed inset-0 flex items-center justify-center hidden bg-black bg-opacity-70 z-[1000]">
                                    <div class="text-5xl font-bold text-green-500">●●●</div>
                                 </div>
                              </div>
                              <!-- 下方玩家區域 -->
                              <div id="player-bottom" class="w-full pt-4 mt-2 border-t border-gray-300 dark:border-gray-700 relative">
                                 <div class="flex flex-col items-center">
                                    <!-- 下方玩家控制欄 -->
                                    <div class="w-full flex justify-between items-center px-4 mb-2">
                                       <div class="flex flex-col gap-1 max-w-[150px] w-full">
                                          <div id="stopwatch-bottom" class="text-gray-700 dark:text-gray-300 px-3 py-1 bg-gray-100 dark:bg-gray-800 rounded-lg text-base flex items-center">
                                             <i class="fas fa-stopwatch mr-2"></i><span id="timer-bottom" class="font-medium">00:00.0</span>
                                          </div>
                                          <!-- 下方玩家進度條 -->
                                          <div class="px-3">
                                             <div class="flex justify-between items-center text-xs text-gray-600 dark:text-gray-400">
                                                <span>進度</span>
                                                <span id="progress-text-bottom">0 / <span id="total-chars-bottom">0</span></span>
                                             </div>
                                             <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                                                <div id="progress-bar-bottom" class="h-full bg-primary rounded-full transition-all duration-300" style="width: 0%"></div>
                                             </div>
                                          </div>
                                       </div>
                                       <button id="pause-btn-bottom" class="p-2 bg-primary text-white rounded-lg hover:bg-opacity-90 text-xl flex items-center justify-center w-10 h-10" title="暫停遊戲">
                                       <i class="fas fa-pause"></i>
                                       </button>
                                    </div>
                                    <div class="flex items-center justify-center">
                                       <div id="last-answered-chars-bottom" class="text-lg md:text-xl text-gray-700 dark:text-gray-300 whitespace-nowrap overflow-x-auto max-w-full h-12 flex items-center"></div>
                                       <div id="current-char-bottom" class="character text-2xl md:text-3xl font-bold text-gray-900 dark:text-gray-100 min-w-[1.2em] flex items-center justify-center ml-1"></div>
                                       <div class="text-lg text-gray-400 dark:text-gray-500">...</div>
                                    </div>
                                    <div id="options-container-bottom" class="grid grid-cols-3 gap-3 md:gap-4 mt-4 w-full px-4"></div>
                                    <!-- 下方玩家錯誤屏障 -->
                                    <div id="bottom-player-error-overlay" class="absolute inset-0 bg-black bg-opacity-70 hidden flex items-center justify-center">
                                       <div class="text-white font-bold flex items-center">
                                          <span id="bottom-error-timer" class="text-3xl text-red-500">●●●</span>
                                       </div>
                                    </div>
                                 </div>
                              </div>
                           </div>
                           <!-- 雙人模式暫停菜單 -->
                           <div id="multiplayer-pause-overlay" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
                              <div class="bg-white dark:bg-gray-800 rounded-lg p-8 py-12 max-w-sm w-full mx-4 flex flex-col items-center justify-center">
                                 <div id="multiplayer-pause-buttons" class="flex justify-center gap-8 mb-8">
                                    <button id="multiplayer-continue-btn" class="w-16 h-16 bg-primary text-white rounded-full hover:bg-opacity-90 flex items-center justify-center text-xl" title="繼續遊戲">
                                    <i class="fas fa-play"></i>
                                    </button>
                                    <button id="multiplayer-return-btn" class="w-16 h-16 bg-green-600 text-white rounded-full hover:bg-green-700 transition-colors flex items-center justify-center text-xl" title="返回主頁">
                                    <i class="fas fa-home"></i>
                                    </button>
                                 </div>
                                 <!-- 隱藏的倒計時顯示 -->
                                 <div id="multiplayer-countdown-resume" class="hidden text-center">
                                    <p class="text-gray-600 dark:text-gray-300 mb-3">遊戲將在以下時間後繼續</p>
                                    <div class="text-4xl font-bold text-primary pause-countdown-number">3</div>
                                 </div>
                              </div>
                           </div>
                        </div>
                     </div>
                  </div>
                  <div id="options-container" class="grid grid-cols-3 gap-3 md:gap-4 mb-4">
                     <!-- Options will be generated here -->
                  </div>
                  <div id="feedback" class="text-center h-6 text-lg"></div>
               </div>
            </div>
         </div>
         <!-- 移除底部的遊玩說明按鈕，因為已經放在齒輪菜單中 -->
      </div>
      <!-- 版本號 -->
      <div class="text-center py-3 text-gray-500 dark:text-gray-400 text-sm">
         <p>v1.5</p>
         <p>WenyanMaster - 文言大師之旅 © 2025</p>
      </div>
      <script>
         // 添加用於頭像的兩個全局變量
         let userSelectedAvatar = null;
         let avatarPixelData = {
             // 定義頭像 - 部分保留，部分重新設計著重呈現物件形狀
             'villager': { name: '普通村民', colors: ['#5D4037', '#8D6E63', '#D7CCC8', '#FFF8E1'] }, // 重新設計
             'rabbit': { name: '兔子', colors: ['#FFEBEE', '#FFCDD2', '#9E9E9E', '#424242'] }, // 重新設計
             'panda': { name: '熊貓', colors: ['#212121', '#424242', '#FFFFFF', '#90A4AE'] }, // 重新設計
             'whale': { name: '鯨魚', colors: ['#0D47A1', '#1565C0', '#81D4FA', '#E1F5FE'] }, // 重新設計
             'bread': { name: '麵包', colors: ['#AA7942', '#D2B48C', '#FFFDE7', '#FFECB3'] }, // 重新設計
             'chicken': { name: '雞', colors: ['#FF6F00', '#FFA000', '#FFECB3', '#F44336'] }, // 保留
             'dragon': { name: '神龍', colors: ['#00695C', '#009688', '#FFD54F', '#D32F2F'] }, // 重新設計
             'bomb': { name: '炸彈', colors: ['#263238', '#37474F', '#546E7A', '#FF3D00'] }, // 保留
             'fox': { name: '狐狸', colors: ['#E65100', '#FF6D00', '#FBE9E7', '#37474F'] }, // 重新設計
             'wizard': { name: '魔法师', colors: ['#311B92', '#5E35B1', '#D1C4E9', '#FFC400'] }, // 重新設計
             'assassin': { name: '刺客', colors: ['#212121', '#424242', '#EEE', '#D50000'] }, // 重新設計
             'husky': { name: '哈士奇', colors: ['#455A64', '#78909C', '#CFD8DC', '#ECEFF1'] }, // 保留
             'werewolf': { name: '狼人', colors: ['#5D4037', '#795548', '#FFC107', '#F5F5F5'] }, // 保留
             'cat': { name: '猫', colors: ['#616161', '#9E9E9E', '#E0E0E0', '#FFC107'] }, // 保留
             'orange': { name: '橙子', colors: ['#FF9800', '#F57C00', '#4CAF50', '#1B5E20'] }, // 保留
             'mask': { name: '面具', colors: ['#FFFFFF', '#EEEEEE', '#9E9E9E', '#212121'] }, // 保留
             'sparrow': { name: '麻雀', colors: ['#795548', '#8D6E63', '#A1887F', '#BCAAA4'] }, // 保留
             'watermelon': { name: '西瓜', colors: ['#4CAF50', '#388E3C', '#E91E63', '#1B5E20'] }, // 保留
             'capybara': { name: '卡皮巴拉', colors: ['#8D6E63', '#A1887F', '#D7CCC8', '#6D4C41'] }, // 保留
             'sunflower': { name: '向日葵', colors: ['#FFEB3B', '#FBC02D', '#795548', '#33691E'] }, // 重新設計
             // 重新設計的頭像 - 著重呈現物件形狀
             'lemon': { name: '檸檬', colors: ['#FFEB3B', '#FFEE58', '#AFB42B', '#C0CA33'] }, // 重新設計
             'angel': { name: '天使', colors: ['#FAFAFA', '#F5F5F5', '#80DEEA', '#FFEE58'] }, // 重新設計
             'pirate': { name: '海盜', colors: ['#3E2723', '#5D4037', '#CFD8DC', '#D32F2F'] }, // 已實現
             'unicorn': { name: '獨角獸', colors: ['#FAFAFA', '#E1BEE7', '#AB47BC', '#FFD54F'] }, // 已實現
             'iceflower': { name: '冰花', colors: ['#E3F2FD', '#B3E5FC', '#03A9F4', '#0277BD'] }, // 已實現
             'snowman': { name: '雪人', colors: ['#ECEFF1', '#CFD8DC', '#546E7A', '#EF5350'] }, // 保留
             'mummy': { name: '木乃伊', colors: ['#F5F5F5', '#E0E0E0', '#BDBDBD', '#757575'] }, // 保留
             // 重新設計的頭像
             'candy': { name: '糖果', colors: ['#F06292', '#EC407A', '#81C784', '#4CAF50'] },
             'butterfly': { name: '蝴蝶', colors: ['#9C27B0', '#BA68C8', '#EC407A', '#7B1FA2'] },
             'lightning': { name: '閃電', colors: ['#FFEB3B', '#FDD835', '#FBC02D', '#F9A825'] },
             'crown': { name: '皇冠', colors: ['#FFC107', '#FFD54F', '#F44336', '#B71C1C'] },
             'moon': { name: '月球', colors: ['#ECEFF1', '#CFD8DC', '#B0BEC5', '#546E7A'] }
         }
         
         // 定義頭像解鎖所需等級
         window.avatarUnlockLevels = {
         'villager': 1,  // 預設解鎖「普通村民」頭像
         'rabbit': 4,    // 4級解鎖「兔子」頭像
         'panda': 7,     // 7級解鎖「熊貓」頭像
         'whale': 10,    // 10級解鎖「鯨魚」頭像
         'bread': 13,    // 13級解鎖「麵包」頭像
         'chicken': 16,  // 16級解鎖「雞」頭像
         'dragon': 19,   // 19級解鎖「神龍」頭像
         'bomb': 22,     // 22級解鎖「炸彈」頭像
         'fox': 25,      // 25級解鎖「狐狸」頭像
         'wizard': 28,   // 28級解鎖「魔法师」頭像
         'assassin': 31, // 31級解鎖「刺客」頭像
         'husky': 34,    // 34級解鎖「哈士奇」頭像
         'werewolf': 37, // 37級解鎖「狼人」頭像
         'cat': 40,      // 40級解鎖「猫」頭像
         'orange': 43,   // 43級解鎖「橙子」頭像
         'mask': 46,     // 46級解鎖「面具」頭像
         'sparrow': 49,  // 49級解鎖「麻雀」頭像
         'watermelon': 52, // 52級解鎖「西瓜」頭像
         'capybara': 55, // 55級解鎖「卡皮巴拉」頭像
         'sunflower': 58, // 58級解鎖「向日葵」頭像
         'lemon': 61,    // 61級解鎖「檸檬」頭像
         'angel': 64,    // 64級解鎖「天使」頭像
         'pirate': 67,   // 67級解鎖「海盜」頭像
         'unicorn': 70,  // 70級解鎖「獨角獸」頭像
         'iceflower': 73, // 73級解鎖「冰花」頭像
         'candy': 84,    // 84級解鎖「糖果」頭像
         'butterfly': 88, // 88級解鎖「蝴蝶」頭像
         'lightning': 92, // 92級解鎖「閃電」頭像
         'crown': 96,    // 96級解鎖「皇冠」頭像
         'moon': 100,     // 100級解鎖「月球」頭像
         'snowman': 76,  // 76級解鎖「雪人」頭像
         'mummy': 80,    // 80級解鎖「木乃伊」頭像
         };
         
         document.addEventListener('DOMContentLoaded', function() {
             // 確保移除深色模式類
             document.documentElement.classList.remove('dark');
             
             // 添加視窗大小變化監聽
             window.addEventListener('resize', function() {
                 // 如果篇章選擇器已打開
                 if (passageContent && !passageContent.classList.contains('hidden')) {
                     const passageList = document.getElementById('passage-list');
                     if (passageList) {
                         passageList.style.maxHeight = Math.max(60, window.innerHeight * 0.2) + 'px';
                     }
                     
                     // 如果段落選擇器也打開
                     const paragraphSelector = document.getElementById('paragraph-selector');
                     const paragraphList = document.getElementById('paragraph-list');
                     if (paragraphSelector && !paragraphSelector.classList.contains('hidden') && paragraphList) {
                         // 調整段落選項容器的高度
                         const paragraphOptions = paragraphList.querySelector('.paragraph-options');
                         if (paragraphOptions) {
                             // 每段約70px高，最少200px，最多視口高度的50%
                             const paragraphCount = document.querySelectorAll('.paragraph-checkbox').length;
                             const calculatedHeight = Math.min(
                                 Math.max(200, paragraphCount * 70),
                                 window.innerHeight * 0.5
                             );
                             paragraphOptions.style.maxHeight = calculatedHeight + 'px';
                         }
                     }
                     
                     // 更新容器高度
                     if (passageContainer) {
                         // 計算當前所有內容的實際高度
                         const passageContentHeight = document.getElementById('passage-content').scrollHeight;
                         // 增加額外空間，確保容器高度充足
                         const totalHeight = Math.max(600, passageContentHeight + 50);
                         passageContainer.style.maxHeight = totalHeight + 'px';
                     }
                 }
             });
             console.log("DOM加載完成，開始初始化...");
             
             // 隱藏主界面，直到用戶點擊「開始旅程」
             const mainContainer = document.querySelector('.container');
             const startScreen = document.getElementById('start-screen');
             const startJourneyBtn = document.getElementById('start-journey-btn');
             const settingsButton = document.getElementById('settings-button');
             
             // 初始隱藏主內容和設置按鈕
             if (mainContainer) mainContainer.style.display = 'none';
             if (settingsButton) settingsButton.style.display = 'none';
             
             // 開始旅程按鈕事件
             if (startJourneyBtn && startScreen && mainContainer) {
                 startJourneyBtn.addEventListener('click', function() {
                     // 先禁用按鈕防止重複點擊
                     startJourneyBtn.disabled = true;
                     
                     // 1. 讓啟動界面淡出
                     startScreen.style.opacity = '0';
                     
                     // 2. 在淡出過程中（大約400ms後）播放墨水擴散動畫
                     setTimeout(() => {
                         // 創建墨水擴散動畫
                         const loadingAnimation = document.createElement('div');
                         loadingAnimation.id = 'loading-container';
                         loadingAnimation.innerHTML = `<div id="main-splash"></div>`;
                         document.body.appendChild(loadingAnimation);
                         
                         // 3. 淡出完全結束后（大約800ms）隱藏啟動界面並顯示主界面
                         setTimeout(() => {
                             // 隱藏啟動界面
                             startScreen.style.display = 'none';
                             // 顯示主界面
                             mainContainer.style.display = 'block';
                             
                             // 顯示用戶資料容器，隱藏遊戲界面
                             const userProfileContainer = document.getElementById('user-profile-container');
                             const gamePage = document.getElementById('game-page');
                             if (userProfileContainer) {
                                 userProfileContainer.classList.remove('hidden');
                             }
                             
                             // 4. 最後顯示設置按鈕
                             setTimeout(() => {
                                 settingsButton.style.display = 'flex';
                                 
                                 // 墨水動畫淡出並移除
                                 loadingAnimation.classList.add('fade-out');
                                 setTimeout(() => {
                                     if (loadingAnimation.parentNode) {
                                         loadingAnimation.parentNode.removeChild(loadingAnimation);
                                     }
                                     // 重新啟用按鈕（雖然啟動界面已經隱藏）
                                     startJourneyBtn.disabled = false;
                                 }, 500);
                             }, 100); // 短暫延遲後顯示設置按鈕
                         }, 400); // 總共約800ms的淡出時間
                     }, 400); // 淡出到一半時開始播放墨水擴散動畫
                 });
             }
             
             // 新增暫停功能相關變量
             let isPaused = false;
             let resumeCountdown = null;
             
             // 添加追蹤用戶是否使用過暫停功能的變量
             let hasPaused = false;
             
             // 計時器相關變量 - 修改為支持暫停/繼續
             let startTime = null;
             let elapsedTimeBeforePause = 0; // 保存暫停前的累計時間
             let timerInterval = null;
             const timerElement = document.getElementById('timer');
             
             // 文言文數據 - 您可以在此處添加更多篇章
         
             const passages = {
          '木蘭辭': {
                    title: '《木蘭辭》',
                    author: '佚名',
                    category: '中一',
                    paragraphs: [
                        '唧唧復唧唧，木蘭當戶織。不聞機杼聲，唯聞女歎息。問女何所思，問女何所憶。「女亦無所思，女亦無所憶。昨夜見軍帖，可汗大點兵。軍書十二卷，卷卷有爺名。阿爺無大兒，木蘭無長兄。願為市鞍馬，從此替爺征。」',
                        '東市買駿馬，西市買鞍韉，南市買轡頭，北市買長鞭。旦辭爺娘去，暮宿黃河邊；不聞爺娘喚女聲，但聞黃河流水鳴濺濺。旦辭黃河去，暮宿黑山頭；不聞爺娘喚女聲，但聞燕山胡騎聲啾啾。',
                        '萬里赴戎機，關山度若飛。朔氣傳金柝，寒光照鐵衣。將軍百戰死，壯士十年歸。歸來見天子，天子坐明堂。策勳十二轉，賞賜百千彊。可汗問所欲，「木蘭不用尚書郎，願借明駝千里足，送兒還故鄉。」',
                        '爺娘聞女來，出郭相扶將。阿姊聞妹來，當戶理紅妝。小弟聞姊來，磨刀霍霍向豬羊。開我東閣門，坐我西閣牀；脫我戰時袍，着我舊時裳；當窗理雲鬢，對鏡帖花黃。出門看火伴，火伴皆驚惶：「同行十二年，不知木蘭是女郎。」',
                        '雄兔腳撲朔，雌兔眼迷離；兩兔傍地走，安能辨我是雄雌？'
                    ]
                },

                '燕詩': {
                    title: '《燕詩》',
                    author: '白居易',
                    category: '中一',
                    paragraphs: [
                        '梁上有雙燕，翩翩雄與雌。銜泥兩椽間，一巢生四兒。四兒日夜長，索食聲孜孜。青蟲不易捕，黃口無飽期。嘴爪雖欲敝，心力不知疲。須臾十來往，猶恐巢中飢。辛勤三十日，母瘦雛漸肥。喃喃教言語，一一刷毛衣。一旦羽翼長，引上庭樹枝；舉翅不回顧，隨風四散飛。雌雄空中鳴，聲盡呼不歸；卻入空巢裏，啁啾終夜悲。燕燕爾勿悲！爾當反自思：思爾為雛日，高飛背母時。當時父母念，今日爾應知！'
                    ]
                },

                '岳飛之少年時代': {
                    title: '《岳飛之少年時代》',
                    author: '佚名',
                    category: '中一',
                    paragraphs: [
                        '岳飛，字鵬舉，相州湯陰人也。生時，有大禽若鵠，飛鳴室上，因以為名。未彌月，河決內黃，水暴至，母姚氏抱飛坐巨甕中，衝濤乘流而下，及岸，得不死。',
                        '飛少負氣節，沉厚寡言。天資敏悟，強記書傳，尤好《左氏春秋》及孫吳兵法。家貧，拾薪為燭，誦習達旦不寐。生有神力，未冠，能挽弓三百斤。學射於周同。同射三矢，皆中的，以示飛；飛引弓一發，破其筈；再發，又中。同大驚，以所愛良弓贈之。飛由是益自練習，盡得同術。',
                        '未幾，同死，飛悲慟不已。每值朔望，必具酒肉，詣同墓，奠而泣；又引同所贈弓，發三矢，乃酹。父知而義之，撫其背曰︰「使汝異日得為時用，其殉國死義乎？」應曰︰「惟大人許兒以身報國家，何事不可為！」'
                    ]
                },

                '送杜少府之任蜀州': {
                    title: '《送杜少府之任蜀州》',
                    author: '王勃',
                    category: '中一',
                    paragraphs: [
                        '城闕輔三秦，風煙望五津。與君離別意，同是宦遊人。海內存知己，天涯若比鄰。無為在歧路，兒女共霑巾。'
                    ]
                },
             
                '賣油翁': {
                    title: '《賣油翁》',
                    author: '歐陽修',
                    category: '中一',
                    paragraphs: [
                        '陳康肅公堯咨善射，當世無雙，公亦以此自矜。嘗射於家圃，有賣油翁釋擔而立，睨之，久而不去。見其發矢十中八九，但微頷之。',
                        '康肅問曰：「汝亦知射乎？吾射不亦精乎？」翁曰：「無他，但手熟爾。」康肅忿然曰：「爾安敢輕吾射！」翁曰：「以我酌油知之。」乃取一葫蘆置於地，以錢覆其口，徐以杓酌油瀝之，自錢孔入，而錢不濕。因曰：「我亦無他，惟手熟爾。」康肅笑而遣之。'
                    ]
                },

                '蘇軾水調歌頭並序': {
                    title: '《水調歌頭並序》',
                    author: '蘇軾',
                    category: '中二',
                    paragraphs: [
                        '丙辰中秋，歡飲達旦，大醉，作此篇，兼懷子由。',
                        '明月幾時有？把酒問青天。不知天上宮闕，今夕是何年？我欲乘風歸去，又恐瓊樓玉宇，高處不勝寒。起舞弄清影，何似在人間？',                     
                        '轉朱閣，低綺戶，照無眠。不應有恨，何事長向別時圓？人有悲歡離合，月有陰晴圓缺，此事古難全。但願人長久，千里共嬋娟。'
                    ]
                },

                '李煜虞美人': {
                    title: '《虞美人》（春花秋月）',
                    author: '李煜',
                    category: '中二',
                    paragraphs: [
                        '春花秋月何時了，往事知多少？小樓昨夜又東風，故國不堪回首月明中。',
                        '雕闌玉砌應猶在，只是朱顏改。問君能有幾多愁，恰似一江春水向東流。'
                    ]
                },             

                '愛蓮說': {
                    title: '《愛蓮說》',
                    author: '周敦頤',
                    category: '中二',
                    paragraphs: [
                        '水陸草木之花，可愛者甚蕃，晉陶淵明獨愛菊。自李唐來，世人甚愛牡丹。予獨愛蓮之出淤泥而不染，濯清漣而不妖；中通外直，不蔓不枝；香遠益清，亭亭淨植，可遠觀而不可褻玩焉。',
                        '予謂︰菊，花之隱逸者也；牡丹，花之富貴者也；蓮，花之君子者也。噫！菊之愛，陶後鮮有聞；蓮之愛，同予者何人？牡丹之愛，宜乎眾矣！'
                    ]
                },        

                '為學一首示子姪': {
                    title: '《為學一首示子姪》',
                    author: '彭端淑',
                    category: '中二',
                    paragraphs: [
                        '天下事有難易乎？為之，則難者亦易矣；不為，則易者亦難矣。人之為學有難易乎？學之，則難者亦易矣；不學，則易者亦難矣。吾資之昏不逮人也，吾材之庸不逮人也，旦旦而學之，久而不怠焉，迄乎成，而亦不知其昏與庸也。吾資之聰倍人也，吾材之敏倍人也；摒棄而不用，其與昏與庸無以異也。聖人之道，卒於魯也傳之。然則昏庸聰敏之用，豈有常哉？',
                        '蜀之鄙有二僧：其一貧，其一富。貧者語於富者曰：「吾欲之南海，何如？」富者曰：「子何恃而往？」曰：「吾一瓶一鉢足矣。」富者曰：「吾數年來欲買舟而下，猶未能也。子何恃而往？」越明年，貧者自南海還，以告富者，富者有慚色。西蜀之去南海，不知幾千里也，僧之富者不能至，而貧者至之。人之立志，顧不如蜀鄙之僧哉？',
                        '是故聰與敏，可恃而不可恃也，自恃其聰與敏而不學者，自敗者也。昏與庸，可限而不可限也；不自限其昏與庸而力學不倦者，自力者也。'
                    ]
                },     
             
                '傷仲永': {
                    title: '《傷仲永》',
                    author: '王安石',
                    category: '中二',
                    paragraphs: [
                        '金溪民方仲永，世隸耕。仲永生五年，未嘗識書具，忽啼求之。父異焉，借旁近與之，即書詩四句，並自為其名。其詩以養父母、收族為意，傳一鄉秀才觀之。自是指物作詩立就，其文理皆有可觀者。邑人奇之，稍稍賓客其父，或以錢幣乞之。父利其然也，日扳仲永環謁於邑人，不使學。',
                        '予聞之也久，明道中，從先人還家，於舅家見之，十二三矣。令作詩，不能稱前時之聞。又七年，還自揚州，復到舅家，問焉。曰：「泯然眾人矣。」',
                        '王子曰：仲永之通悟，受之天也。其受之天也，賢於材人遠矣，卒之為眾人，則其受於人者不至也。彼其受之天也，如此其賢也，不受之人，且為眾人。今夫不受之天，固眾人，又不受之人，得為眾人而已邪？'
                    ]
                },        
             
                '人間詞話': {
                    title: '《人間詞話》（節錄）',
                    author: '王國維',
                    category: '中三',
                    paragraphs: [
                        '古今之成大事業、大學問者，必經過三種境界：「昨夜西風凋碧樹。獨上高樓，望盡天涯路。」此第一境界也。「衣帶漸寬終不悔，為伊消得人憔悴。」此第二境界也。「眾裡尋他千百度，驀然回首，那人卻在，燈火闌珊處。」此第三境界也。此等語皆非大詞人不能道。然遽以此意解釋諸詞，恐為晏、歐諸公所不許也。'
                    ]
                },

                '論四端': {
                    title: '《論四端》',
                    author: '孟子',
                    category: '中三',
                    paragraphs: [
                        '孟子曰：「人皆有不忍人之心。先王有不忍人之心，斯有不忍人之政矣。以不忍人之心，行不忍人之政，治天下可運之掌上。」',
                        '所以謂人皆有不忍人之心者，今人乍見孺子將入於井，皆有怵惕惻隱之心----非所以內交於孺子之父母也，非所以要譽於鄉黨朋友也，非惡其聲而然也。由是觀之，無惻隱之心，非人也；無羞惡之心，非人也；無辭讓之心，非人也；無是非之心，非人也。惻隱之心，仁之端也；羞惡之心，義之端也；辭讓之心，禮之端也；是非之心，智之端也。',
                        '人之有是四端也，猶其有四體也。有是四端而自謂不能者，自賊者也；謂其君不能者，賊其君者也。凡有四端於我者，知皆擴而充之矣，若火之始然，泉之始達。苟能充之，足以保四海；苟不充之，不足以事父母。」'
                    ]
                },

                '鄒忌諷齊王納諫': {
                    title: '《鄒忌諷齊王納諫》',
                    author: '戰國策',
                    category: '中三', 
                    paragraphs: [
                        '鄒忌脩八尺有餘，而形貌昳麗。朝服衣冠，窺鏡，謂其妻曰：「我孰與城北徐公美？」其妻曰：「君美甚，徐公何能及君也！」城北徐公，齊國之美麗者也。忌不自信，而復問其妾曰：「吾孰與徐公美？」妾曰：「徐公何能及君也！」旦日，客從外來，與坐談，問之客曰：「吾與徐公孰美？」客曰：「徐公不若君之美也。」明日，徐公來，孰視之，自以為不如；窺鏡而自視，又弗如遠甚。暮寢而思之，曰：「吾妻之美我者，私我也；妾之美我者，畏我也；客之美我者，欲有求於我也。」',
                        '於是入朝見威王，曰：「臣誠知不如徐公美。臣之妻私臣，臣之妾畏臣，臣之客欲有求於臣，皆以美於徐公。今齊地方千里，百二十城，宮婦左右，莫不私王；朝廷之臣，莫不畏王，四境之內，莫不有求於王。由此觀之，王之蔽甚矣。」王曰：「善。」乃下令：「羣臣吏民能面刺寡人之過者，受上賞；上書諫寡人者，受中賞；能謗議於市朝，聞寡人之耳者，受下賞。」',
                        '令初下，羣臣進諫，門庭若市；數月之後，時時而間進；期年之後，雖欲言，無可進者。燕、趙、韓、魏聞之，皆朝於齊。此所謂戰勝於朝廷。'
                    ]
                },

                 '李商隱無題相見時難': {
                    title: '《無題》（相見時難）',
                    author: '李商隱',
                    category: '中三', 
                    paragraphs: [
                        '相見時難別亦難，東風無力百花殘。春蠶到死絲方盡，蠟炬成灰淚始乾。曉鏡但愁雲鬢改，夜吟應覺月光寒。蓬山此去無多路，青鳥殷勤為探看。'
                    ]
                },
             
                 '蘇軾江城子': {
                    title: '《江城子》',
                    author: '蘇軾',
                    category: '中三', 
                    paragraphs: [
                        '十年生死兩茫茫。不思量，自難忘。千里孤墳，無處話淒涼。縱使相逢應不識，塵滿面，鬢如霜。',
                        '夜來幽夢忽還鄉。小軒窗，正梳妝。相顧無言，惟有淚千行。料得年年腸斷處︰明月夜，短松岡。'
                    ]
                },
             
                 '李清照醉花陰': {
                    title: '《醉花陰》',
                    author: '李清照',
                    category: '中三', 
                    paragraphs: [
                        '薄霧濃雲愁永晝，瑞腦銷金獸。佳節又重陽，玉枕紗廚，半夜涼初透。',
                        '東籬把酒黃昏後，有暗香盈袖。莫道不銷魂，簾卷西風，人比黃花瘦。'
                    ]
                },
             
                '論仁論孝論君子': {
                    title: '《論仁論孝論君子》',
                    author: '論語',
                    category: '指定文言',
                    paragraphs: [
                        '子曰：「不仁者，不可以久處約，不可以長處樂。仁者安仁，知者利仁。」',
                        '子曰：「富與貴，是人之所欲也；不以其道得之，不處也。貧與賤，是人之所惡也；不以其道得之，不去也。君子去仁，惡乎成名？君子無終食之間違仁，造次必於是，顛沛必於是。」',
                        '顏淵問仁。子曰：「克己復禮為仁。一日克己復禮，天下歸仁焉。為仁由己，而由人乎哉？」顏淵曰：「請問其目。」子曰：「非禮勿視，非禮勿聽，非禮勿言，非禮勿動。」顏淵曰：「回雖不敏，請事斯語矣。」',
                        '子曰：「志士仁人，無求生以害仁，有殺身以成仁。」',
                        '孟懿子問孝。子曰：「無違。」樊遲御，子告之曰：「孟孫問孝於我，我對曰，無違。」樊遲曰：「何謂也？」子曰：「生，事之以禮；死，葬之以禮，祭之以禮。',
                        '子游問孝。子曰：「今之孝者，是謂能養。至於犬馬，皆能有養；不敬，何以別乎！」',
                        '子曰：「事父母幾諫，見志不從，又敬不違，勞而不怨。」',
                        '子曰：「父母之年，不可不知也。一則以喜，一則以懼。」',
                        '子曰：「君子不重則不威；學則不固。主忠信。無友不如己者。過則勿憚改。」',
                        '子曰：「君子坦蕩蕩，小人長戚戚。」',
                        '司馬牛問君子。子曰：「君子不憂不懼。」曰：「不憂不懼，斯謂之君子已乎？」子曰：「內省不疚，夫何憂何懼？」',
                        '子曰：「君子成人之美，不成人之惡。小人反是。」',
                        '子曰：「君子恥其言而過其行。」',
                        '子曰：「君子義以為質，禮以行之，孫以出之，信以成之。君子哉！」',
                        '子曰：「君子病無能焉，不病人之不己知也。」',
                        '子曰：「君子求諸己，小人求諸人。」'
                    ]
                },

                '魚我所欲也': {
                    title: '《魚我所欲也》',
                    author: '孟子',
                    category: '指定文言',
                    paragraphs: [
                        '孟子曰：「魚，我所欲也，熊掌，亦我所欲也；二者不可得兼，舍魚而取熊掌者也。生亦我所欲也，義亦我所欲也；二者不可得兼，舍生而取義者也。生亦我所欲，所欲有甚於生者，故不為苟得也；死亦我所惡，所惡有甚於死者，故患有所不辟也。如使人之所欲莫甚於生，則凡可以得生者，何不用也？使人之所惡莫甚於死者，則凡可以辟患者，何不為也？由是則生而有不用也，由是則可以辟患而有不為也，是故所欲有甚於生者，所惡有甚於死者。非獨賢者有是心也，人皆有之，賢者能勿喪耳。',
                        '一簞食，一豆羹，得之則生，弗得則死。嘑爾而與之，行道之人弗受；蹴爾而與之，乞人不屑也；萬鍾則不辯禮義而受之。萬鍾於我何加焉？為宮室之美、妻妾之奉、所識窮乏者得我與？鄉為身死而不受，今為宮室之美為之；鄉為身死而不受，今為妻妾之奉為之；鄉為身死而不受，今為所識窮乏者得我而為之，是亦不可以已乎？此之謂失其本心。」'
                    ]
                },

                '勸學': {
                    title: '《勸學》（節錄）',
                    author: '荀子',
                    category: '指定文言',
                    paragraphs: [
                        '君子曰：學不可以已。青，取之於藍，而青於藍；冰，水為之，而寒於水。木直中繩，輮以為輪，其曲中規；雖有槁暴、不復挺者，輮使之然也。故木受繩則直，金就礪則利，君子博學而日參省乎己，則知明而行無過矣。',
                        '吾嘗終日而思矣，不如須臾之所學也；吾嘗跂而望矣，不如登高之博見也。登高而招，臂非加長也，而見者遠。順風而呼，聲非加疾也，而聞者彰。假輿馬者，非利足也，而致千里；假舟楫者，非能水也，而絕江河。君子生非異也，善假於物也。',
                        '積土成山，風雨興焉；積水成淵，蛟龍生焉；積善成德，而神明自得，聖心備焉。故不積跬步，無以至千里；不積小流，無以成江海。騏驥一躍，不能十步；駑馬十駕，功在不舍。鍥而舍之，朽木不折；鍥而不舍，金石可鏤。螾無爪牙之利，筋骨之強，上食埃土，下飲黃泉，用心一也。蟹六跪而二螯，非蛇蟺之穴無可寄託者，用心躁也。'
                    ]
                },
                
                '師說': {
                    title: '《師說》（節錄）',
                    author: '韓愈',
                    category: '指定文言',
                    paragraphs: [
                        '古之學者必有師。師者，所以傳道、受業、解惑也。人非生而知之者，孰能無惑？惑而不從師，其為惑也終不解矣。生乎吾前，其聞道也，固先乎吾，吾從而師之；生乎吾後，其聞道也，亦先乎吾，吾從而師之。吾師道也，夫庸知其年之先後生於吾乎？是故無貴無賤，無長無少，道之所存，師之所存也。',
                        '嗟乎！師道之不傳也久矣！欲人之無惑也難矣！古之聖人，其出人也遠矣，猶且從師而問焉；今之眾人，其下聖人也亦遠矣，而恥學於師。是故聖益聖，愚益愚，聖人之所以為聖，愚人之所以為愚，其皆出於此乎！',
                        '愛其子，擇師而教之；於其身也，則恥師焉，惑矣！彼童子之師，授之書而習其句讀者，非吾所謂傳其道、解其惑者也。句讀之不知，惑之不解，或師焉，或不焉，小學而大遺，吾未見其明也。',
                        '巫、醫、樂師、百工之人，不恥相師；士大夫之族，曰師、曰弟子云者，則羣聚而笑之。問之，則曰：「彼與彼年相若也，道相似也。」位卑則足羞，官盛則近諛。嗚呼！師道之不復，可知矣。巫、醫、樂師、百工之人，君子不齒，今其智乃反不能及，其可怪也歟！',
                        '聖人無常師，孔子師郯子、萇弘、師襄、老聃。郯子之徒，其賢不及孔子。孔子曰：「三人行，則必有我師。」是故弟子不必不如師，師不必賢於弟子；聞道有先後，術業有專攻，如是而已。',
                        '李氏子蟠，年十七，好古文，六藝經傳，皆通習之，不拘於時，學於余。余嘉其能行古道，作《師說》以貽之。'
                    ]
                },

                '岳陽樓記': {
                    title: '《岳陽樓記》',
                    author: '范仲淹',
                    category: '指定文言', 
                    paragraphs: [
                        '慶曆四年春，滕子京謫守巴陵郡。越明年，政通人和，百廢具興，乃重修岳陽樓，增其舊制，刻唐賢今人詩賦於其上；屬予作文以記之。',
                        '予觀夫巴陵勝狀，在洞庭一湖。銜遠山，吞長江，浩浩湯湯，橫無際涯；朝暉夕陰，氣象萬千；此則岳陽樓之大觀也，前人之述備矣。然則北通巫峽，南極瀟湘，遷客騷人，多會於此，覽物之情，得無異乎？',
                        '若夫霪雨霏霏，連月不開；陰風怒號，濁浪排空；日星隱曜，山嶽潛形；商旅不行，檣傾楫摧；薄暮冥冥，虎嘯猿啼。登斯樓也，則有去國懷鄉，憂讒畏譏，滿目蕭然，感極而悲者矣。',
                        '至若春和景明，波瀾不驚，上下天光，一碧萬頃；沙鷗翔集，錦鱗游泳，岸芷汀蘭，郁郁青青。而或長煙一空，皓月千里，浮光躍金，靜影沉璧，漁歌互答，此樂何極。登斯樓也，則有心曠神怡，寵辱皆忘，把酒臨風，其喜洋洋者矣。',
                        '嗟夫！予嘗求古仁人之心，或異二者之為，何哉？不以物喜，不以己悲。居廟堂之高，則憂其民；處江湖之遠，則憂其君。是進亦憂，退亦憂；然則何時而樂耶？其必曰：「先天下之憂而憂，後天下之樂而樂」歟！噫！微斯人，吾誰與歸？'
                    ]
                },

                '六國論': {
                    title: '《六國論》',
                    author: '蘇洵',
                    category: '指定文言', 
                    paragraphs: [
                        '六國破滅，非兵不利，戰不善，弊在賂秦。賂秦而力虧，破滅之道也。或曰：「六國互喪，率賂秦耶？」曰：「不賂者以賂者喪。蓋失強援，不能獨完，故曰『弊在賂秦』也。」',
                        '秦以攻取之外，小則獲邑，大則得城，較秦之所得與戰勝而得者，其實百倍；諸侯之所亡與戰敗而亡者，其實亦百倍。則秦之所大欲，諸侯之所大患，固不在戰矣。思厥先祖父，暴霜露，斬荊棘，以有尺寸之地。子孫視之不甚惜，舉以予人，如棄草芥。今日割五城，明日割十城，然後得一夕安寢，起視四境，而秦兵又至矣。然則諸侯之地有限，暴秦之欲無厭，奉之彌繁，侵之愈急，故不戰而強弱勝負已判矣。至於顛覆，理固宜然。古人云：「以地事秦，猶抱薪救火，薪不盡，火不滅。」此言得之。',
                        '齊人未嘗賂秦，終繼五國遷滅，何哉？與嬴而不助五國也。五國既喪，齊亦不免矣。燕趙之君，始有遠略，能守其土，義不賂秦。是故燕雖小國而後亡，斯用兵之效也。至丹以荊卿為計，始速禍焉。趙嘗五戰于秦，二敗而三勝，後秦擊趙者再，李牧連卻之；洎牧以讒誅，邯鄲為郡，惜其用武而不終也。且燕趙處秦革滅殆盡之際，可謂智力孤危，戰敗而亡，誠不得已。向使三國各愛其地，齊人勿附於秦，刺客不行，良將猶在，則勝負之數，存亡之理，當與秦相較，或未易量。',
                        '嗚呼！以賂秦之地，封天下之謀臣；以事秦之心，禮天下之奇才；幷力西嚮，則吾恐秦人食之不得下嚥也。悲夫！有如此之勢，而為秦人積威之所劫，日削月割，以趨於亡。為國者無使為積威之所劫哉！',
                        '夫六國與秦皆諸侯，其勢弱於秦，而猶有可以不賂而勝之之勢；茍以天下之大，而從六國破亡之故事，是又在六國下矣！'
                    ]
                },

                '出師表': {
                    title: '《出師表》',
                    author: '諸葛亮',
                    category: '指定文言', 
                    paragraphs: [
                        '先帝創業未半，而中道崩殂；今天下三分，益州疲弊，此誠危急存亡之秋也！然侍衞之臣，不懈於內；忠志之士忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。',
                        '誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。',
                        '宮中、府中，俱為一體；陟罰臧否，不宜異同。若有作姦、犯科，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。',
                        '侍中、侍郎郭攸之、費禕、董允等，此皆良實，志慮忠純，是以先帝簡拔以遺陛下。愚以為宮中之事，事無大小，悉以咨之，然後施行，必能裨補闕漏，有所廣益。將軍向寵，性行淑均，曉暢軍事，試用於昔日，先帝稱之曰「能」，是以眾議舉寵為督。愚以為營中之事，悉以咨之，必能使行陣和睦，優劣得所。',
                        '親賢臣，遠小人，此先漢所以興隆也；親小人，遠賢臣，此後漢所以傾頹也。先帝在時，每與臣論此事，未嘗不歎息痛恨於桓、靈也！侍中、尚書、長史、參軍，此悉貞良死節之臣，願陛下親之、信之，則漢室之隆，可計日而待也。',
                        '侍中、侍郎郭攸之、費禕、董允等，此皆良實，志慮忠純，是以先帝簡拔以遺陛下。愚以為宮中之事，事無大小，悉以咨之，然後施行，必能裨補闕漏，有所廣益。將軍向寵，性行淑均，曉暢軍事，試用於昔日，先帝稱之曰「能」，是以眾議舉寵為督。愚以為營中之事，悉以咨之，必能使行陣和睦，優劣得所。',
                        '臣本布衣，躬耕於南陽，苟全性命於亂世，不求聞達於諸侯。先帝不以臣卑鄙，猥自枉屈，三顧臣於草廬之中，諮臣以當世之事；由是感激，遂許先帝以驅馳。後值傾覆，受任於敗軍之際，奉命於危難之間，爾來二十有一年矣。先帝知臣謹慎，故臨崩寄臣以大事也。受命以來，夙夜憂歎，恐託付不效，以傷先帝之明。故五月渡瀘，深入不毛。今南方已定，兵甲已足，當獎率三軍，北定中原。庶竭駑鈍，攘除奸凶，興復漢室，還於舊都。此臣之所以報先帝，而忠陛下之職分也。至於斟酌損益，進盡忠言，則攸之、禕、允之任也。',
                        '願陛下託臣以討賊興復之效；不效，則治臣之罪，以告先帝之靈。若無興德之言，則責攸之、禕、允等之慢，以彰其咎。陛下亦宜自謀，以咨諏善道，察納雅言，深追先帝遺詔。臣不勝受恩感激。今當遠離，臨表涕零，不知所言！'
                    ]
                },

                '登樓': {
                    title: '《登樓》',
                    author: '杜甫',
                    category: '指定文言', 
                    paragraphs: [
                        '花近高樓傷客心，萬方多難此登臨。錦江春色來天地，玉壘浮雲變古今。北極朝廷終不改，西山寇盜莫相侵。可憐後主還祠廟，日暮聊為梁甫吟。'
                    ]
                },

                '山居秋暝': {
                    title: '《山居秋暝》',
                    author: '王維',
                    category: '指定文言', 
                    paragraphs: [
                        '空山新雨後，天氣晚來秋。明月松間照，清泉石上流。竹喧歸浣女，蓮動下漁舟。隨意春芳歇，王孫自可留。'
                    ]
                },

                '月下獨酌': {
                    title: '《月下獨酌》',
                    author: '李白',
                    category: '指定文言', 
                    paragraphs: [
                        '花間一壺酒，獨酌無相親。舉杯邀明月，對影成三人。月既不解飲，影徒隨我身。暫伴月將影，行樂須及春。我歌月徘徊，我舞影零亂。醒時同交歡，醉後各分散。永結無情遊，相期邈雲漢。'
                    ]
                },

                '青玉案': {
                    title: '《青玉案．元夕》',
                    author: '辛棄疾',
                    category: '指定文言', 
                    paragraphs: [
                        '東風夜放花千樹，更吹落、星如雨。寶馬雕車香滿路，鳳簫聲動，玉壺光轉，一夜魚龍舞。蛾兒雪柳黃金縷，笑語盈盈暗香去。',
                        '眾裡尋他千百度；驀然回首，那人卻在，燈火闌珊處。'
                    ]
                },

                '念奴嬌': {
                    title: '《念奴嬌．赤壁懷古》',
                    author: '李清照',
                    category: '指定文言', 
                    paragraphs: [
                        '赤壁懷古大江東去，浪淘盡、千古風流人物。故壘西邊，人道是：三國周郎赤壁。亂石穿空，驚濤拍岸，捲起千堆雪。江山如畫，一時多少豪傑。',
                        '遙想公瑾當年，小喬初嫁了，雄姿英發，羽扇綸巾，談笑間、檣櫓灰飛煙滅。故國神遊，多情應笑我，早生華髮。人生如夢，一尊還酹江月。'
                    ]
                },


                '聲聲慢': {
                    title: '《聲聲慢．秋情》',
                    author: '李清照',
                    category: '指定文言', 
                    paragraphs: [
                        '尋尋覓覓，冷冷清清，悽悽慘慘戚戚。乍煖還寒時候，最難將息。三杯兩盞淡酒，怎敵它、晚來風急？雁過也，正傷心，卻是舊時相識。',
                        '滿地黃花堆積。憔悴損，如今有誰堪摘？守著窗兒，獨自怎生得黑？梧桐更兼細雨，到黃昏、點點滴滴。這次第，怎一個愁字了得！'
                    ]
                },

                '始得西山宴遊記': {
                    title: '《始得西山宴遊記》',
                    author: '柳宗元',
                    category: '指定文言', 
                    paragraphs: [
                        '自余為僇人，居是州，恒惴慄。其隙也，則施施而行，漫漫而遊。日與其徒上高山，入深林，窮迴溪，幽泉怪石，無遠不到。到則披草而坐，傾壺而醉。醉則更相枕以臥，臥而夢。意有所極，夢亦同趣。覺而起，起而歸。以為凡是州之山有異態者，皆我有也，而未始知西山之怪特。',
                        '今年九月二十八日，因坐法華西亭，望西山，始指異之。遂命僕過湘江，緣染溪，斫榛莽。焚茅茷，窮山之高而止。攀援而登，箕踞而遨，則凡數州之土壤，皆在衽席之下。其高下之勢，岈然窪然，若垤若穴，尺寸千里，攢蹙累積，莫得遯隱。縈青繚白，外與天際，四望如一。然後知是山之特出，不與培塿為類，悠悠乎與顥氣俱，而莫得其涯；洋洋乎與造物者遊，而不知其所窮。引觴滿酌，頹然就醉，不知日之入。蒼然暮色，自遠而至，至無所見，而猶不欲歸。心凝形釋，與萬化冥合。然後知吾嚮之未始遊，遊於是乎始，故為之文以志。是歲元和四年也。'
                    ]
                },

                '逍遙遊': {
                    title: '《逍遙遊》',
                    author: '莊子',
                    category: '指定文言', 
                    paragraphs: [
                        '惠子謂莊子曰：「魏王貽我大瓠之種，我樹之成而實五石。以盛水漿，其堅不能自舉也。剖之以爲瓢，則瓠落無所容。非不呺然大也，吾爲其無用而掊之。」莊子曰：「夫子固拙於用大矣。宋人有善爲不龜手之藥者，世世以洴澼絖爲事。客聞之，請買其方百金。聚族而謀曰：『我世世爲洴澼絖，不過數金；今一朝而鬻技百金，請與之。』客得之，以說吳王。越有難，吳王使之將，冬與越人水戰，大敗越人，裂地而封之。能不龜手，一也；或以封，或不免於洴澼絖，則所用之異也。今子有五石之瓠，何不慮以爲大樽而浮乎江湖，而憂其瓠落無所容？則夫子猶有蓬之心也夫！」',
                        '惠子謂莊子曰：「吾有大樹，人謂之樗。其大本擁腫而不中繩墨，其小枝捲曲而不中規矩，立之塗，匠者不顧。今子之言，大而無用，衆所同去也。」莊子曰：「子獨不見狸狌乎？卑身而伏，以候敖者；東西跳梁，不避高下；中於機辟，死於罔罟。今夫斄牛，其大若垂天之雲。此能爲大矣，而不能執鼠。今子有大樹，患其無用，何不樹之於無何有之鄉，廣莫之野，彷徨乎無爲其側，逍遙乎寢臥其下？不夭斤斧，物無害者，無所可用，安所困苦哉！」'
                    ]
                },

                '秦風蒹葭': {
                    title: '《秦風．蒹葭》',
                    author: '詩經',
                    category: '文學', 
                    paragraphs: [
                        '蒹葭蒼蒼，白露為霜。所謂伊人，在水一方。溯洄從之，道阻且長，溯游從之，宛在水中央。',
                        '蒹葭萋萋，白露未晞。所謂伊人，在水之湄。溯洄從之，道阻且躋。溯游從之，宛在水中坻。',
                        '蒹葭采采，白露未已。所謂伊人，在水之涘。溯洄從之，道阻且右。溯游從之，宛在水中沚。'
                    ]
                },
             
                '九章涉江': {
                    title: '《九章．涉江》',
                    author: '屈原',
                    category: '文學', 
                    paragraphs: [
                        '余幼好此奇服兮，年既老而不衰。帶長鋏之陸離兮，冠切雲之崔嵬。被明月兮珮寶璐。世溷濁而莫余知兮，吾方高馳而不顧。駕青虯兮驂白螭，吾與重華遊兮瑤之圃。登崑崙兮食玉英，與天地兮同壽，與日月兮同光。哀南夷之莫吾知兮，旦余濟乎江湘。',
                        '乘鄂渚而反顧兮，欸秋冬之緒風。步余馬兮山皋，邸余車兮方林。乘舲船余上沅兮，齊吳榜以擊汰。船容與而不進兮，淹回水而疑滯。朝發枉陼兮，夕宿辰陽。苟余心其端直兮，雖僻遠之何傷。',
                        '入漵浦余儃佪兮，迷不知吾所如。深林杳以冥冥兮，猿狖之所居。山峻高以蔽日兮，下幽晦以多雨。霰雪紛其無垠兮，雲霏霏而承宇。哀吾生之無樂兮，幽獨處乎山中。吾不能變心而從俗兮，固將愁苦而終窮。',
                        '接輿髡首兮，桑扈臝行。忠不必用兮，賢不必以。伍子逢殃兮，比干菹醢。與前世而皆然兮，吾又何怨乎今之人！余將董道而不豫兮，固將重昏而終身！',
                        '亂曰：鸞鳥鳳皇，日以遠兮。燕雀烏鵲，巢堂壇兮。露申辛夷，死林薄兮。腥臊並御，芳不得薄兮。陰陽易位，時不當兮。懷信侘傺，忽乎吾將行兮！'
                    ]
                },

                '庖丁解牛': {
                    title: '《庖丁解牛》',
                    author: '莊子',
                    category: '文學', 
                    paragraphs: [
                        '吾生也有涯，而知也無涯，以有涯隨無涯，殆已！已而為知者，殆而已矣！為善無近名，為惡無近刑，緣督以為經，可以保身，可以全生，可以養親，可以盡年。',
                        '庖丁為文惠君解牛，手之所解，肩之所倚，足之所履，膝之所踦，砉然嚮然，奏刀騞然，莫不中音，合於桑林之舞，乃中經首之會。文惠君曰：「譆！善哉！技蓋至此乎？」庖丁釋刀對曰：「臣之所好者，道也，進乎技矣。始臣之解牛之時，所見無非牛者，三年之後，未嘗見全牛也。方今之時，臣以神遇，而不以目視，官知止而神欲行，依乎天理，批大郤，導大窾，因其固然，技經肯綮之未嘗，而況大軱乎？良庖歲更刀，割也，族庖月更刀，折也。今臣之刀十九年矣，所解數千牛矣，而刀刃若新發於硎。彼節者有間，而刀刃者無厚，以無厚入有間，恢恢乎其於遊刃，必有餘地矣！是以十九年，而刀刃若新發於硎？雖然，每至於族吾見其難為，怵然為戒，視為止，行為遲，動刀甚微，謋然已解，如土委地。提刀而立，為之四顧，為之躊躇滿志，善刀而藏之。」文惠君曰：「善哉！吾聞庖丁之言，得養生焉。」'
                    ]
                },

                '蘇秦約縱': {
                    title: '《蘇秦約縱》',
                    author: '戰國策',
                    category: '文學', 
                    paragraphs: [
                        '說秦王書十上而說不行，黑貂之裘弊，黃金百斤盡，資用乏絕，去秦而歸，羸縢履蹻，負書擔橐，形容枯槁，面目犂黑，狀有歸色。歸至家，妻不下絍，嫂不為炊，父母不與言。蘇秦喟歎曰：「妻不以我為夫，嫂不以我為叔，父母不以我為子，是皆秦之罪也。」乃夜發書，陳篋數十，得太公《陰符》之謀，伏而誦之，簡練以為揣摩。讀書欲睡，引錐自刺其股，血流至足，曰︰「安有說人主，不能出其金玉錦繡，取卿相之尊者乎？」朞年，揣摩成，曰︰「此真可以說當世之君矣。」於是乃摩燕烏集闕，見說趙王於華屋之下，抵掌而談，趙王大悅，封為武安君。受相印，革車百乘、錦繡千純、白璧百雙、黃金萬鎰以隨其後，約從散橫以抑強秦，故蘇秦相於趙而關不通。',
                        '當此之時，天下之大，萬民之眾，王侯之威，謀臣之權，皆欲決蘇秦之策。不費斗糧，未煩一兵，未戰一士，未絕一絃，未折一矢，諸侯相親，賢於兄弟。夫賢人在而天下服，一人用而天下從，故曰︰式於政不式於勇；式於廊廟之內，不式於四境之外。當秦之隆，黃金萬鎰為用，轉轂連騎，炫熿於道，山東之國從風而服，使趙太重。且夫蘇秦，特窮巷掘門桑戶棬樞之士耳，伏軾撙銜，橫歷天下，廷說諸侯之主，杜左右之口，天下莫之能伉。',
                        '將說楚王，路過洛陽，父母聞之，清宮除道，張樂設飲，郊迎三十里。妻側目而視，傾耳而聽。嫂虵行匍伏，四拜自跪而謝。蘇秦曰︰「嫂何前倨而後卑也？」嫂曰︰「以季子之位尊而多金。」蘇秦曰：「嗟乎，貧窮則父母不子，富貴則親戚畏懼。人生世上，勢位富貴，蓋可忽乎哉？」'
                    ]
                },

                '鴻門會': {
                    title: '《鴻門會》',
                    author: '司馬遷',
                    category: '文學', 
                    paragraphs: [
                        '沛公旦日從百餘騎來見項王，至鴻門，謝曰：「臣與將軍戮力而攻秦，將軍戰河北，臣戰河南，然不自意能先入關破秦，得復見將軍於此。今者有小人之言，令將軍與臣有郤。」項王曰：「此沛公左司馬曹無傷言之，不然，籍何以至此。」項王即日因留沛公與飲。項王、項伯東嚮坐；亞父南嚮坐──亞父者，范增也；沛公北嚮坐；張良西嚮侍。范增數目項王，舉所佩玉玦以示之者三。項王默然不應。范增起，出召項莊，謂曰：「君王為人不忍，若入前為壽，壽畢，請以劔舞，因擊沛公於坐，殺之。不者，若屬皆且為所虜。」莊則入為壽。壽畢，曰：「君王與沛公飲，軍中無以為樂，請以劔舞。」項王曰：「諾。」項莊拔劔起舞，項伯亦拔劔起舞，常以身翼蔽沛公，莊不得擊。',
                        '於是張良至軍門，見樊噲。樊噲曰：「今日之事何如？」良曰：「甚急！今者項莊拔劔舞，其意常在沛公也。」噲曰：「此迫矣！臣請入，與之同命！」噲即帶劔擁盾入軍門。交戟之衛士欲止不內，樊噲側其盾以撞，衛士仆地。噲遂入。披帷西嚮立，瞋目視項王，頭髮上指，目眦盡裂。項王按劔而跽曰：「客何為者？」張良曰：「沛公之參乘樊噲者也。」項王曰：「壯士！賜之巵酒！」則與斗巵酒。噲拜謝，起，立而飲之。項王曰：「賜之彘肩！」則與一生彘肩。樊噲覆其盾於地，加彘肩上，拔劔切而啗之。項王曰：「壯士！能復飲乎？」樊噲曰：「臣死且不避，巵酒安足辭！夫秦王有虎狼之心，殺人如不能舉，刑人如恐不勝，天下皆叛之。懷王與諸將約曰：『先破秦入咸陽者王之。』今沛公先破秦入咸陽，毫毛不敢有所近，封閉宮室，還軍霸上，以待大王來。故遣將守關者，備他盜出入與非常也。勞苦而功高如此，未有封侯之賞，而聽細說，欲誅有功之人，此亡秦之續耳，竊為大王不取也。」項王未有以應，曰：「坐！」樊噲從良坐，坐須臾，沛公起如廁，因招樊噲出。',
                        '沛公已出，項王使都尉陳平召沛公。沛公曰：「今者出，未辭也，為之奈何？」樊噲曰：「大行不顧細謹，大禮不辭小讓。如今人方為刀俎，我為魚肉，何辭為？」於是遂去。乃令張良留謝。良問曰：「大王來何操？」曰：「我持白璧一雙，欲獻項王；玉斗一雙，欲與亞父。會其怒，不敢獻。公為我獻之。」張良曰：「謹諾。」當是時，項王軍在鴻門下，沛公軍在霸上，相去四十里。沛公則置車騎，脫身獨騎，與樊噲、夏侯嬰、靳彊、紀信等四人持劔盾步走，從酈山下，道芷陽間行。沛公謂張良曰：「從此道至吾軍，不過二十里耳。度我至軍中，公乃入。」沛公已去，間至軍中，張良入，謝曰：「沛公不勝桮杓，不能辭。謹使臣良奉白璧一雙，再拜獻大王足下；玉斗一雙，再拜奉大將軍足下。」項王曰：「沛公安在？」良曰：「聞大王有意督過之，脫身獨去，已至軍矣。」項王則受璧，置之坐上。亞父受玉斗，置之地，拔劔撞而破之，曰：「唉！豎子不足與謀！奪項王天下者，必沛公也，吾屬今為之虜矣！」沛公至軍，立誅殺曹無傷。'
                    ]
                },

                '戰城南': {
                    title: '《戰城南》',
                    author: '佚名',
                    category: '文學', 
                    paragraphs: [
                        '戰城南，死郭北，野死不葬烏可食。為我謂烏：「且為客豪！野死諒不葬，腐肉安能去子逃！」水深激激，蒲葦冥冥；梟騎戰鬭死，駑馬徘徊鳴。梁築室，何以南，何以北？禾黍不穫君何食？願為忠臣安可得？思子良臣，良臣誠可思：朝行出攻，暮不夜歸！'
                    ]
                },

                '短歌行': {
                    title: '《短歌行》',
                    author: '曹操',
                    category: '文學', 
                    paragraphs: [
                        '對酒當歌，人生幾何？譬如朝露，去日苦多。慨當以慷，憂思難忘。何以解憂？唯有杜康。青青子衿，悠悠我心。但為君故，沉吟至今。呦呦鹿鳴，食野之苹。我有嘉賓，鼓瑟吹笙。明明如月，何時可輟？憂從中來，不可斷絕。越陌度阡，枉用相存。契闊談讌，心念舊恩。月明星稀，烏鵲南飛。繞樹三匝，何枝可依？山不厭高，水不厭深。周公吐哺，天下歸心。'
                    ]
                },

                '歸去來辭並序': {
                    title: '《歸去來辭（並序）》',
                    author: '陶潛',
                    category: '文學', 
                    paragraphs: [
                        '余家貧，耕植不足以自給。幼稚盈室，缾無儲粟，生生所資，未見其術。親故多勸余為長吏，脫然有懷，求之靡途。會有四方之事，諸侯以惠愛為德，家叔以余貧苦，遂見用于小邑。于時風波未靜，心憚遠役，彭澤去家百里，公田之利，足以為酒，故便求之。及少日，眷然有歸歟之情。何則？質性自然，非矯厲所得。飢凍雖切，違己交病。嘗從人事，皆口腹自役。於是悵然慷慨，深媿平生之志。猶望一稔，當斂裳宵逝。尋程氏妹喪于武昌，情在駿奔，自免去職。仲秋至冬，在官八十餘日。因事順心，命篇曰《歸去來兮》。乙巳歲十一月也。',
                        '歸去來兮，田園將蕪胡不歸？既自以心為形役，奚惆悵而獨悲！悟已往之不諫，知來者之可追；實迷途其未遠，覺今是而昨非。舟遙遙以輕颺，風飄飄而吹衣。問征夫以前路。恨晨光之熹微。',
                        '乃瞻衡宇，載欣載奔。僮僕歡迎，稚子候門。三逕就荒，松菊猶存。攜幼入室，有酒盈罇。引壺觴以自酌，眄庭柯以怡顏。倚南窗以寄傲，審容膝之易安。園日涉以成趣，門雖設而常關。策扶老以流憇，時矯首而遐觀。雲無心以出岫，鳥倦飛而知還。景翳翳以將入，撫孤松而盤桓。歸去來兮，請息交以絕游。世與我而相違，復駕言兮焉求？悅親戚之情話，樂琴書以消憂。農人告余以春及，將有事於西疇。或命巾車，或棹孤舟。既窈窕以尋壑，亦崎嶇而經丘。木欣欣以向榮，泉涓涓而始流。喜萬物之得時，感吾生之行休。',
                        '已矣乎，寓形宇內復幾時，曷不委心任去留？胡為乎遑遑兮欲何之？富貴非吾願，帝鄉不可期。懷良辰以孤往，或植杖而耘耔。登東皐以舒嘯，臨清流而賦詩。聊乘化以歸盡，樂夫天命復奚疑。'
                    ]
                },

                '將近酒': {
                    title: '《將進酒》',
                    author: '李白',
                    category: '文學', 
                    paragraphs: [
                        '君不見黃河之水天上來，奔流到海不復回！君不見高堂明鏡悲白髮，朝如青絲暮成雪！人生得意須盡歡，莫使金樽空對月。天生我材必有用，千金散盡還復來。烹羊宰牛且為樂，會須一飲三百杯。岑夫子，丹丘生，將進酒，君莫停。與君歌一曲，請君為我傾耳聽：鐘鼓饌玉不足貴，但願長醉不用醒；古來聖賢皆寂寞，唯有飲者留其名。陳王昔時宴平樂，斗酒十千恣歡謔。主人何為言少錢，徑須沽取對君酌。五花馬，千金裘，呼兒將出換美酒，與爾同銷萬古愁。'
                    ]
                },

                '登高': {
                    title: '《登高》',
                    author: '杜甫',
                    category: '文學', 
                    paragraphs: [
                        '風急天高猿嘯哀，渚清沙白鳥飛迴，無邊落木蕭蕭下，不盡長江滾滾來。萬里悲秋常作客，百年多病獨登臺。艱難苦恨繁霜鬢，潦倒新停濁酒杯。'
                    ]
                },

                '進學解': {
                    title: '《進學解》',
                    author: '韓愈',
                    category: '文學', 
                    paragraphs: [
                        '國子先生晨入太學，招諸生立館下，誨之曰︰「業精于勤荒于嬉，行成于思毀于隨。方今聖賢相逢，治具畢張，拔去兇邪，登崇畯良。占小善者率以錄，名一藝者無不庸，爬羅剔抉，刮垢磨光。蓋有幸而獲選，孰云多而不揚！諸生業患不能精，無患有司之不明；行患不能成，無患有司之不公。」',
                        '言未既，有笑于列者曰︰「先生欺余哉！弟子事先生，於茲有年矣。先生口不絕吟於六藝之文，手不停披於百家之編，記事者必提其要，纂言者必鉤其玄；貪多務得，細大不捐，焚膏油以繼晷，恒兀兀以窮年：先生之業，可謂勤矣。觝排異端，攘斥佛老，補苴罅漏，張皇幽眇，尋墜緒之茫茫，獨旁搜而遠紹，障百川而東之，迴狂瀾於既倒：先生之於儒，可謂有勞矣。沈浸醲郁，含英咀華，作為文章，其書滿家。上規姚姒，渾渾無涯，《周誥》《殷盤》，佶屈聱牙，《春秋》謹嚴，《左氏》浮誇，《易》奇而法，《詩》正而葩；下逮《莊》《騷》，太史所錄，子雲相如，同工異曲：先生之於文，可謂閎其中而肆其外矣。少始知學，勇於敢為；長通於方，左右具宜：先生之於為人，可謂成矣。然而公不見信於人，私不見助於友，跋前躓後，動輒得咎，暫為御史，遂竄南夷，三年博士，冗不見治。命與仇謀，取敗幾時。冬暖而兒號寒，年豐而妻啼飢，頭童齒豁，竟死何裨！不知慮此，而反教人為？」',
                        '先生曰︰「吁！子來前！夫大木為杗，細木為桷，欂櫨侏儒，椳闑扂楔，各得其宜，施以成室者，匠氏之工也。玉札丹砂，赤箭青芝，牛溲馬勃，敗鼓之皮，俱收並畜，待用無遺者，醫師之良也。登明選公，雜進巧拙，紆餘為妍，卓犖為傑，校短量長，惟器是適者，宰相之方也。昔者孟軻好辯，孔道以明，轍還天下，卒老於行；荀卿守正，大論是弘，逃讒於楚，廢死蘭陵：是二儒者，吐辭為經，舉足為法，絕類離倫，優入聖域。其遇於世何如也？今先生，學雖勤而不繇其統，言雖多而不要其中，文雖奇而不濟於用，行雖修而不顯於眾。猶且月費俸錢，歲靡廩粟，子不知耕，婦不知織，乘馬從徒，安坐而食，踵常途之促促，窺陳編以盜竊。然而聖主不加誅，宰臣不見斥，非其幸歟！動而得謗，名亦隨之，投閒置散，乃分之宜。若夫商財賄之有亡，計班資之崇庳，忘己量之所稱，指前人之瑕疵，是所謂詰匠氏之不以杙為楹，而訾醫師以昌陽引年，欲進其豨苓也。」'
                    ]
                },

                '醉翁亭記': {
                    title: '《醉翁亭記》',
                    author: '歐陽修',
                    category: '文學', 
                    paragraphs: [
                        '環滁皆山也。其西南諸峯，林壑尤美；望之蔚然而深秀者，琅邪也。山行六七里，漸聞水聲潺潺，而瀉出于兩峯之間者，釀泉也。峯回路轉，有亭翼然，臨于泉上者，醉翁亭也。作亭者誰？山之僧曰智僊也。名之者誰？太守自謂也。太守與客來飲于此，飲少輒醉，而年又最高，故自號曰醉翁也。醉翁之意不在酒，而在乎山水之間也。山水之樂，得之心而寓之酒也。',
                        '若夫日出而林霏開，雲歸而巖穴暝，晦明變化者，山間之朝暮也。野芳發而幽香，佳木秀而繁陰，風霜高潔，水落而石出者，山間之四時也。朝而往，暮而歸，四時之景不同，而樂亦無窮也。',
                        '至于負者歌於塗，行者休于樹；前者呼，後者應；傴僂提攜，往來而不絕者，滁人遊也。臨谿而漁，谿深而魚肥；釀泉為酒，泉香而酒洌；山肴野蓛，雜然而前陳者，太守宴也。宴酣之樂，非絲非竹，射者中，弈者勝，觥籌交錯，起坐而諠譁者，眾賓懽也。蒼顏白髮，頹然乎其間者，太守醉也。',
                        '已而夕陽在山，人影散亂，太守歸而賓客從也。樹林陰翳，鳴聲上下，遊人去而禽鳥樂也。然而禽鳥知山林之樂，而不知人之樂；人知從太守遊而樂，而不知太守之樂其樂也。',
                        '醉能同其樂，醒能述以文者，太守也。太守謂誰？廬陵歐陽修也。'
                    ]
                },

                '前赤壁賦': {
                    title: '《前赤壁賦》',
                    author: '蘇軾',
                    category: '文學', 
                    paragraphs: [
                        '壬戌之秋，七月既望，蘇子與客泛舟，遊於赤壁之下。清風徐來，水波不興。舉酒屬客，誦明月之詩，歌窈窕之章。少焉，月出於東山之上，徘徊於斗牛之間。白露橫江，水光接天。縱一葦之所如，凌萬頃之茫然。浩浩乎如馮虛御風而不知其所止，飄飄乎如遺世獨立，羽化而登仙。',
                        '於是飲酒樂甚，扣舷而歌之。歌曰：「桂棹兮蘭槳，擊空明兮泝流光。渺渺兮予懷，望美人兮天一方。」客有吹洞簫者，倚歌而和之，其聲烏烏然，如怨如慕，如泣如訴。餘音嫋嫋，不絕如縷。舞幽壑之潛蛟，泣孤舟之嫠婦。',
                        '蘇子愀然，正襟危坐，而問客曰：「何為其然也？」客曰：「『月明星稀，烏鵲南飛。』此非曹孟德之詩乎？西望夏口，東望武昌。山川相繆，鬱乎蒼蒼。此非孟德之困於周郎者乎？方其破荊州，下江陵，順流而東也，舳艫千里，旌旗蔽空，釃酒臨江，橫槊賦詩，固一世之雄也，而今安在哉？況吾與子漁樵於江渚之上，侶魚蝦而友麋鹿。駕一葉之扁舟，舉匏尊以相屬。寄蜉蝣於天地，眇滄海之一粟。哀吾生之須臾，羨長江之無窮。挾飛仙以遨遊，抱明月而長終。知不可乎驟得，託遺響於悲風。」',
                        '蘇子曰：「客亦知夫水與月乎？逝者如斯，而未嘗往也。盈虛者如彼，而卒莫消長也。蓋將自其變者而觀之，則天地曾不能以一瞬。自其不變者而觀之，則物與我皆無盡也，而又何羨乎？且夫天地之間，物各有主，苟非吾之所有，雖一毫而莫取。惟江上之清風，與山間之明月，耳得之而為聲，目遇之而成色。取之無禁，用之不竭。是造物者之無盡藏也，而吾與子之所共適。」客喜而笑，洗盞更酌，肴核既盡，杯盤狼籍，相與枕藉乎舟中，不知東方之既白。'
                    ]
                },

                '齊天樂秋思': {
                    title: '《齊天樂．秋思》',
                    author: '周邦彥',
                    category: '文學', 
                    paragraphs: [
                        '綠蕪凋盡臺城路，殊鄉又逢秋晚。暮雨生寒，鳴蛩勸織，深閣時聞裁翦。雲窗靜掩。嘆重拂羅裀，頓疏花簟。尚有綀囊，露螢清夜照書卷。',
                        '荊江留滯最久，故人相望處，離思何限。渭水西風，長安亂葉，空憶詩情宛轉。憑高眺遠，正玉液新篘，蟹螯初薦。醉倒山翁，但愁斜照歛。'
                    ]
                },

                '南鄉子': {
                    title: '《南鄉子．登京口北固亭有懷》',
                    author: '辛棄疾',
                    category: '文學', 
                    paragraphs: [
                        '何處望神州？滿眼風光北固樓。千古興亡多少事，悠悠，不盡長江滾滾流。',
                        '年少萬兜鍪，坐斷東南戰未休。天下英雄誰敵手？曹劉。生子當如孫仲謀。'
                    ]
                },

                '雙調夜行船': {
                    title: '《雙調．夜行船．秋思》',
                    author: '馬致遠',
                    category: '文學', 
                    paragraphs: [
                        '百歲光陰一夢蝶，重回首往事堪嗟。今日春來，明朝花謝，急罰盞夜闌燈滅。',
                        '想秦宮漢闕，都做了衰草牛羊野。不恁麼漁樵沒話說。縱荒墳橫斷碑，不辨龍蛇。',
                        '投至狐蹤與兔穴，多少豪傑。鼎足雖堅半腰裏折，魏耶，晉耶？',
                        '天教你富，莫太奢，不多時好天良夜。富家兒更做道你心似鐵，爭辜負了錦堂風月。',
                        '眼前紅日又西斜，疾似下坡車。不爭鏡裏添白雪，上牀與鞋履相別。休笑鳩巢計拙，葫蘆提一向裝呆。',
                        '利名竭，是非絕。紅塵不向門前惹，綠樹偏宜屋角遮。青山正補牆頭缺。更那堪竹籬茅舍。',
                        '蛩吟罷一覺纔寧貼，雞鳴時萬事無休歇。何年是徹？看密匝匝蟻排兵，亂紛紛蜂釀蜜，鬧攘攘蠅爭血。裴公綠野堂，陶令白蓮社。愛秋來時那些：和露摘黃花，帶霜分紫蟹，煮酒燒紅葉。想人生有限杯，渾幾箇重陽節？人問我頑童記者：便北海探吾來，道東籬醉了也。'
                    ]
                },

                '西湖七月半': {
                    title: '《西湖七月半》',
                    author: '張岱',
                    category: '文學', 
                    paragraphs: [
                        '西湖七月半，一無可看，止可看看七月半之人。看七月半之人，以五類看之：其一，樓船簫鼓，峨冠盛筵，燈火優傒，聲光相亂，名爲看月而實不見月者，看之；其一，亦船亦樓，名娃閨秀，攜及童孌，笑啼雜之，環坐露臺，左右盼望，身在月下而實不看月者，看之；其一，亦船亦聲歌，名妓閒僧，淺斟低唱，弱管輕絲，竹肉相發，亦在月下，亦看月而欲人看其看月者，看之；其一，不舟不車，不衫不幘，酒醉飯飽，呼群三五，躋入人叢，昭慶斷橋，嘄呼嘈雜，裝假醉，唱無腔曲，月亦看，看月者亦看，不看月者亦看，而實無一看者，看之；其一，小船輕幌，淨几煖爐，茶鐺旋煮，素瓷靜遞，好友佳人，邀月同坐，或匿影樹下，或逃囂裏湖，看月而人不見其看月之態，亦不作意看月者，看之。',
                        '杭人遊湖，巳出酉歸，避月如仇。是夕好名，逐隊爭出，多犒門軍酒錢，轎夫擎燎，列俟岸上。一入舟，速舟子急放斷橋，趕入勝會。以故二鼓以前，人聲鼓吹，如沸如撼，如魘如囈，如聾如啞，大船小船一齊湊岸，一無所見，止見篙擊篙，舟觸舟，肩摩肩，面看面而已。少刻興盡，官府席散，皂隸喝道去。轎夫叫船上人，怖以關門，燈籠火把如列星，一一簇擁而去。岸上人亦逐隊趕門，漸稀漸薄，頃刻散盡矣。吾輩始艤舟近岸。斷橋石磴始涼，席其上，呼客縱飲。此時月如鏡新磨，山復整粧，湖復頮面。向之淺斟低唱者出，匿影樹下者亦出，吾輩往通聲氣，拉與同坐。韻友來，名妓至，杯箸安，竹肉發。月色蒼涼，東方將白，客方散去。吾輩縱舟酣睡於十里荷花之中，香氣拍人，清夢甚愜。'
                    ]
                },

             '關雎': {
                    title: '《國風．關雎》',
                    author: '詩經',
                    category: '其他', 
                    paragraphs: [
                        '關關雎鳩，在河之洲。窈窕淑女，君子好逑。參差荇菜，左右流之。窈窕淑女，寤寐求之。求之不得，寤寐思服。悠哉悠哉，輾轉反側。參差荇菜，左右采之。窈窕淑女，琴瑟友之。參差荇菜，左右芼之。窈窕淑女，鐘鼓樂之。'
                    ]
                },

                '曹劌論戰': {
                    title: '《曹劌論戰》',
                    author: '左傳',
                    category: '其他', 
                    paragraphs: [
                        '十年春，齊師伐我，公將戰，曹劌請見。其鄉人曰：「肉食者謀之，又何間焉？」劌曰：「肉食者鄙，未能遠謀。」乃入見，問：「何以戰。」公曰：「衣食所安，弗敢專也，必以分人。」對曰：「小惠未徧，民弗從也。」公曰：「犧牲玉帛，弗敢加也，必以信。」對曰：「小信未孚，神弗福也。」公曰：「小大之獄，雖不能察，必以情。」對曰：「忠之屬也，可以一戰。戰則請從。」',
                        '公與之乘，戰於長勺。公將鼓之。劌曰：「未可。」齊人三鼓，劌曰：「可矣。」齊師敗績。公將馳之。劌曰：「未可。」下視其轍，登軾而望之，曰：「可矣。」遂逐齊師。',
                        '既克，公問其故。對曰：「夫戰，勇氣也。一鼓作氣，再而衰，三而竭。彼竭我盈，故克之。夫大國，難測也，懼有伏焉。吾視其轍亂，望其旗靡，故逐之。」'
                    ]
                },
                '大學': {
                    title: '《大學》（節錄）',
                    author: '禮記',
                    category: '其他', 
                    paragraphs: [
                        '大學之道，在明明德，在親民，在止於至善。知止而後有定，定而後能靜，靜而後能安，安而後能慮，慮而後能得。物有本末，事有終始，知所先後，則近道矣。',
                        '古之欲明明德於天下者，先治其國；欲治其國者，先齊其家；欲齊其家者，先修其身；欲修其身者，先正其心；欲正其心者，先誠其意；欲誠其意者，先致其知；致知在格物。物格而后知至，知至而后意誠，意誠而后心正，心正而后身修，身修而后家齊，家齊而后國治，國治而后天下平。'
                    ]
                },

                '陳情表': {
                    title: '《陳情表》',
                    author: '李密',
                    category: '其他', 
                    paragraphs: [
                        '臣密言︰臣以險釁，夙遭閔凶，生孩六月，慈父見背，行年四歲，舅奪母志。祖母劉，愍臣孤弱，躬親撫養。臣少多疾病，九歲不行；零丁孤苦，至于成立。既無叔伯，終鮮兄弟，門衰祚薄，晚有兒息。外無期功彊近之親，內無應門五尺之童。煢煢獨立，形影相弔。而劉夙嬰疾病，常在牀蓐。臣侍湯藥，未曾廢離。',
                        '逮奉聖朝，沐浴清化。前太守臣逵，察臣孝廉；後刺史臣榮，舉臣秀才；臣以供養無主，辭不赴命。詔書特下，拜臣郎中；尋蒙國恩，除臣洗馬。猥以微賤，當侍東宮，非臣隕首所能上報。臣具以表聞，辭不就職。詔書切峻，責臣逋慢；郡縣逼迫，催臣上道；州司臨門，急於星火。臣欲奉詔奔馳，則劉病日篤；欲苟順私情，則告訴不許。臣之進退，實為狼狽。',
                        '伏惟聖朝以孝治天下，凡在故老，猶蒙矜育，況臣孤苦，特為尤甚。且臣少仕偽朝，歷職郎署，本圖宦達，不矜名節。今臣亡國賤俘，至微至陋，過蒙拔擢，寵命優渥，豈敢盤桓，有所希冀？但以劉日薄西山，氣息奄奄，人命危淺，朝不慮夕。臣無祖母，無以至今日；祖母無臣，無以終餘年。母孫二人，更相為命，是以區區不能廢遠。',
                        '臣密今年四十有四，祖母劉今年九十有六。是臣盡節於陛下之日長，報養劉之日短也。烏鳥私情，願乞終養。臣之辛苦，非獨蜀之人士，及二州牧伯，所見明知；皇天后土，實所共鑒。願陛下矜愍愚誠，聽臣微志。庶劉僥倖，卒保餘年。臣生當隕首，死當結草。臣不勝犬馬怖懼之情，謹拜表以聞。'
                    ]
                },

                '滿井遊記': {
                    title: '《滿井遊記》',
                    author: '袁宏道',
                    category: '其他', 
                    paragraphs: [
                        '燕地寒，花朝節後，餘寒猶厲。凍風時作，作則飛沙走礫。局促一室之內，欲出不得。每冒風馳行，未百步輒返。',
                        '廿二日，天稍和，偕數友出東直。至滿井，高柳夾堤，土膏微潤，一望空闊，若脫籠之鵠。於時冰皮始解，波色乍明，鱗浪層層，清徹見底，晶晶然如鏡之新開而冷光之乍出於匣也。山巒為晴雪所洗，娟然如拭，鮮妍明媚，如倩女之靧面而髻鬟之始掠也。柳條將舒未舒，柔梢披風，麥田淺鬣寸許。遊人雖未盛，泉而茗者，罍而歌者，紅裝而蹇者，亦時時有。風力雖尚勁，然徒步則汗出浹背。凡曝沙之鳥，呷浪之鱗，悠然自得，毛羽鱗鬣之間皆有喜氣。始知郊田之外，未始無春，而城居者未之知也。',
                        '夫能不以遊墮事，而瀟然於山石草木之間者，惟此官也。而此地適與余近，余之遊將自此始，惡能無紀？己亥之二月也。'
                    ]
                },

                '左忠毅公軼事': {
                    title: '《左忠毅公軼事》',
                    author: '方苞',
                    category: '其他', 
                    paragraphs: [
                        '先君子嘗言，鄉先輩左忠毅公視學京畿。一日，風雪嚴寒，從數騎出，微行，入古寺。廡下一生伏案臥，文方成草。公閱畢，即解貂覆生，為掩戶，叩之寺僧，則史公可法也。及試，吏呼名，至史公，公瞿然注視。呈卷，即面署第一；召入，使拜夫人，曰：「吾諸兒碌碌，他日繼吾志事，惟此生耳。」',
                        '及左公下廠獄，史朝夕窺獄門外。逆閹防伺甚嚴，雖家僕不得近。久之，聞左公被炮烙，旦夕且死，持五十金，涕泣謀於禁卒，卒感焉。一日，使史公更敝衣草屨，背筐，手長鑱，為除不潔者，引入，微指左公處，則席地倚牆而坐，面額焦爛不可辨，左膝以下，筋骨盡脫矣。史前跪，抱公膝而嗚咽。公辨其聲，而目不可開，乃奮臂以指撥眥，目光如炬。怒曰：「庸奴！此何地也，而汝前來！國家之事，糜爛至此。老夫已矣，汝復輕身而昧大義，天下事誰可支拄者！不速去，無俟姦人構陷，吾今即撲殺汝。」因摸地上刑械，作投擊勢。史噤不敢發聲，趨而出。後常流涕述其事以語人曰：「吾師肺肝，皆鐵石所鑄造也！」',
                        '崇禎末，流賊張獻忠出沒蘄、黃、潛、桐間，史公以鳳廬道奉檄守禦，每有警，輒數月不就寢，使將士更休，而自坐幄幕外，擇健卒十人，令二人蹲踞，而背倚之，漏鼓移，則番代。每寒夜起立，振衣裳，甲上冰霜迸落，鏗然有聲。或勸以少休，公曰：「吾上恐負朝廷，下恐愧吾師也。」史公治兵，往來桐城，必躬造左公弟，候太公、太母起居，拜夫人於堂上。',
                        '余宗老塗山，左公甥也，與先君子善，謂獄中語乃親得之於史公云。'
                    ]
                },


                '飲酒': {
                    title: '《飲酒》（其五）',
                    author: '陶潛',
                    category: '其他', 
                    paragraphs: [
                        '結廬在人境，而無車馬喧。問君何能爾？心遠地自偏。採菊東籬下，悠然見南山。山氣日夕佳，飛鳥相與還。此中有真意，欲辨已忘言。'
                    ]
                },

                '四塊玉': {
                    title: '《四塊玉．閒適》',
                    author: '關漢卿',
                    category: '其他', 
                    paragraphs: [
                        '南畝耕，東山卧。世態人情經歷多。閒將往事思量過，賢的是他，愚的是我，爭甚麼？'
                    ]
                },

                '沉醉東風': {
                    title: '《沉醉東風．漁父詞》',
                    author: '白樸',
                    category: '其他', 
                    paragraphs: [
                        '黃蘆岸白蘋渡口。綠楊堤紅蓼灘頭。雖無刎頸交，卻有忘機友。點秋江白鷺沙鷗。傲煞人間萬戶侯，不識字煙波釣叟。'
                    ]
                },
            };
             
             // 重新生成篇章列表
             generatePassageItems();
         
             // 自動生成內容和初始化
             initializePassages();
             
             // 定义全局变量
             const startGameBtn = document.getElementById('start-game-btn');
             const gameStartScreen = document.getElementById('game-start-screen');
             const gameContent = document.getElementById('game-content');
             const gamePage = document.getElementById('game-page');
             
             // 当前选择的篇章键值，初始设定为一个随機篇章
              /*let currentPassageKey = '';
             
             // 函數：隨機選擇篇章並加載
             function loadRandomPassage() {
                 // 獲取所有篇章的鍵值
                 const passageKeys = Object.keys(passages);
                 if (passageKeys.length === 0) return;
                 
                 // 隨機選擇一個篇章
                 const randomIndex = Math.floor(Math.random() * passageKeys.length);
                 const randomPassageKey = passageKeys[randomIndex];
                 currentPassageKey = randomPassageKey;
                 
                 // 獲取所有段落索引
                 const selectedPassage = passages[randomPassageKey];
                 const paragraphIndices = [];
                 for (let i = 0; i < selectedPassage.paragraphs.length; i++) {
                     paragraphIndices.push(i);
                 }
                 
                 // 加載選中的篇章（所有段落）
                 loadSelectedParagraphs(randomPassageKey, paragraphIndices);
             }*/
             
             // 初始化默認篇章資料但不顯示遊戲界面的函數
             function initializePassageData() {
                 // 僅預載隨機篇章資料，不自動顯示遊戲界面
                 if (Object.keys(passages).length > 0) {
                     // 隨機選擇一個篇章但只載入資料，不顯示遊戲界面
                     const passageKeys = Object.keys(passages);
                     const randomIndex = Math.floor(Math.random() * passageKeys.length);
                     const randomPassageKey = passageKeys[randomIndex];
                     
                     // 初始化當前篇章鍵值
                     currentPassageKey = randomPassageKey;
                     
                     // 獲取所有段落索引但不顯示遊戲界面
                     const selectedPassage = passages[randomPassageKey];
                     const paragraphIndices = [];
                     for (let i = 0; i < selectedPassage.paragraphs.length; i++) {
                         paragraphIndices.push(i);
                     }
                     
                     // 加載篇章資料，但不顯示遊戲界面 (第三個參數為false表示不顯示遊戲界面)
                     loadSelectedParagraphs(randomPassageKey, paragraphIndices, false);
                 }
                 
                 // 確保用戶資料容器顯示，遊戲界面隱藏
                 const userProfileContainer = document.getElementById('user-profile-container');
                 if (userProfileContainer) {
                     userProfileContainer.classList.remove('hidden');
                 }
                 
                 // 確保遊戲頁面隱藏，直到用戶選擇篇章
                 if (gamePage) {
                     gamePage.classList.add('hidden');
                 }
             }
             
             // 頁面加載後初始化篇章資料，但不顯示遊戲界面
             setTimeout(() => {
                 // 初始化篇章資料但不顯示遊戲界面
                 initializePassageData();
                 
                 // 確保顯示開始畫面 (遊戲內容仍然隱藏)
                 if (gameStartScreen && gameContent) {
                     gameStartScreen.classList.remove('hidden');
                     gameContent.classList.add('hidden');
                 }
             }, 300);
             
             // 追蹤錯誤次數
             let wrongAnswersCount = 0;
             
             // 创建倒计时容器
             const countdownContainer = document.createElement('div');
             countdownContainer.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden';
             countdownContainer.id = 'countdown-container';
             document.body.appendChild(countdownContainer);
             
             const countdownNumber = document.createElement('div');
             countdownNumber.className = 'text-8xl md:text-9xl font-bold text-white countdown-number';
             countdownContainer.appendChild(countdownNumber);
             
             // 添加倒计时样式
             const style = document.createElement('style');
             style.textContent = `
                 @keyframes countdown-pulse {
                     0% { transform: scale(0.8); opacity: 0; }
                     20% { transform: scale(1.2); opacity: 1; }
                     70% { transform: scale(0.9); opacity: 1; }
                     100% { transform: scale(1); opacity: 0.7; }
                 }
                 .countdown-number {
                     animation: countdown-pulse 1s ease-in-out;
                     text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(93, 92, 222, 0.6);
                 }
             `;
             document.head.appendChild(style);
             
             // 初始化暫停功能
             initializePauseSystem();
             
             // 自動生成篇章列表
             generatePassageItems();
             
             // 更新暫停/返回主頁按鈕顯示狀態
             function updateGameControlButtons(gameState) {
                 const pauseBtn = document.getElementById('pause-btn');
                 const returnHomeBtn = document.getElementById('return-home-btn-game');
                 
                 if (!pauseBtn || !returnHomeBtn) return;
                 
                 if (gameState === 'not-started' || gameState === 'completed' || gameState === 'failed') {
                     // 遊戲開始前、完成後或失敗後，顯示返回主頁按鈕
                     pauseBtn.classList.add('hidden');
                     returnHomeBtn.classList.remove('hidden');
                 } else if (gameState === 'playing') {
                     // 遊戲進行中，顯示暫停按鈕
                     pauseBtn.classList.remove('hidden');
                     returnHomeBtn.classList.add('hidden');
                 }
             }
             
             // 為遊戲界面中的返回主頁按鈕添加點擊事件
             const returnHomeGameBtn = document.getElementById('return-home-btn-game');
             if (returnHomeGameBtn) {
                 returnHomeGameBtn.addEventListener('click', async function() {
                     console.log("遊戲界面中的返回主頁按鈕被點擊");
                     
                     try {
                         // 顯示水墨過渡動畫
                         await showLoadingAnimation();
                         console.log("水墨過渡動畫播放完成");
                         
                         // 執行與暫停菜單中返回主頁相同的操作
                         // 重置遊戲狀態
                         currentPosition = 0;
                         correctAnswers = 0;
                         lives = 3;
                         successfulChars = 0;
                         wrongAnswersCount = 0;
                         lastAnsweredChars = [];
                         
                         const lastAnsweredCharsElem = document.getElementById('last-answered-chars');
                         if (lastAnsweredCharsElem) {
                             lastAnsweredCharsElem.textContent = '';
                         }
                         
                         canSelect = true;
                         isPaused = false;
                         hasPaused = false;
                         updateLives();
                         
                         if (feedback) {
                             feedback.textContent = '';
                         }
                         
                         // 停止計時器
                         stopStopwatch();
                         elapsedTimeBeforePause = 0;
                         if (timerElement) {
                             timerElement.textContent = "00:00.0";
                         }
                         
                         // 更新進度條
                         const progressText = document.getElementById('progress-text');
                         const progressBar = document.getElementById('progress-bar');
                         
                         if (progressText) {
                             progressText.textContent = `0 / ${totalNonPunctChars}`;
                         }
                         
                         if (progressBar) {
                             progressBar.style.width = '0%';
                         }
                         
                         // 獲取需要操作的元素
                         const userProfileContainer = document.getElementById('user-profile-container');
                         const gamePage = document.getElementById('game-page');
                         
                         // 隱藏遊戲界面
                         gamePage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
                         gamePage.classList.add('hidden');
                         gamePage.classList.remove('block', 'flex', 'visible', 'opacity-100');
                         
                         // 顯示用戶資料界面
                         userProfileContainer.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                         userProfileContainer.classList.remove('hidden');
                         userProfileContainer.classList.add('block');
                         
                         // 確保書本頁面回到初始狀態
                         const bookPage = document.querySelector('.page');
                         if (bookPage && bookPage.classList.contains('turned')) {
                             bookPage.classList.remove('turned');
                         }
                         
                         // 滾動到頁面頂部
                         window.scrollTo({
                             top: 0,
                             behavior: 'smooth'
                         });
                         
                         // 清空選項並恢復原始的網格佈局
                         if (optionsContainer) {
                             optionsContainer.innerHTML = '';
                             optionsContainer.className = 'grid grid-cols-3 gap-3 md:gap-4 mb-4';
                         }
                         
                         // 重新啟用設置按鈕
                         window.enableSettingsButton();
                         
                         console.log("從遊戲界面返回主頁成功");
                     } catch (error) {
                         console.error("返回主頁按鈕處理發生錯誤:", error);
                         alert("返回主頁時發生錯誤，請重新載入頁面");
                         // 即使發生錯誤，仍嘗試啟用設置按鈕
                         try {
                             window.enableSettingsButton();
                         } catch (e) {
                             console.error("啟用設置按鈕時發生錯誤:", e);
                         }
                     }
                 });
             }
                 
             // 双人模式变量定义
             window.multiplayerMode = {
                 active: false,
                 players: [
                     { currentPosition: 0, correctAnswers: 0, lastAnsweredChars: [], canSelect: true, errorTimer: null },
                     { currentPosition: 0, correctAnswers: 0, lastAnsweredChars: [], canSelect: true, errorTimer: null }
                 ],
                 winner: null,
                 gameStarted: false
             };
             
             // 添加双人模式切换功能 - 使用滑塊
             const gameModeSwitch = document.getElementById('game-mode-switch');
             
             if (gameModeSwitch) {
                 // 设置单人/双人模式切换
                 window.gameMode = 'single'; // 默认为单人模式
                 
                 gameModeSwitch.addEventListener('change', function() {
                     if (this.checked) {
                         // 切换到双人模式
                         window.gameMode = 'multi';
                         console.log("切換到雙人模式");
                     } else {
                         // 切换到单人模式
                         window.gameMode = 'single';
                         console.log("切換到單人模式");
                     }
                 });
             }
             
             // 双人模式确认对话框
             function showMultiplayerConfirm() {
                 // 创建确认对话框
                 const confirmDialog = document.createElement('div');
                 confirmDialog.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[1000]';
                 confirmDialog.id = 'multiplayer-confirm-dialog';
                 
                 confirmDialog.innerHTML = `
                     <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-sm w-full mx-4 text-center">
                         <h3 class="text-xl font-bold text-gray-800 dark:text-gray-100 mb-4">雙人對戰模式</h3>
                         <p class="text-gray-600 dark:text-gray-300 mb-5">兩位玩家分別使用螢幕上半和下半部分同臺競技！。</p>
                         <div class="flex justify-center gap-6">
                             <button id="start-multi-btn" class="px-5 py-2 bg-primary text-white rounded-lg hover:bg-opacity-90">開始</button>
                             <button id="cancel-multi-btn" class="px-5 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">返回</button>
                         </div>
                     </div>
                 `;
                 
                 document.body.appendChild(confirmDialog);
                 
                 // 添加按钮事件
                 document.getElementById('start-multi-btn').addEventListener('click', function() {
                     document.body.removeChild(confirmDialog);
                     startMultiplayerGame();
                 });
                 
                 document.getElementById('cancel-multi-btn').addEventListener('click', function() {
                     document.body.removeChild(confirmDialog);
                     // 切换回单人模式
                     if (singleModeBtn) singleModeBtn.click();
                 });
             }
             
             // 开始双人游戏
             function startMultiplayerGame() {
                 window.multiplayerMode.active = true;
                 window.multiplayerMode.gameStarted = false;
                 window.multiplayerMode.winner = null;
                 
                 // 重置双人模式状态
                 window.multiplayerMode.players.forEach(player => {
                     player.currentPosition = 0;
                     player.correctAnswers = 0;
                     player.lastAnsweredChars = [];
                     player.canSelect = true;
                 });
                 
                 // 隐藏开始屏幕，显示游戏内容
                 if (gameStartScreen) {
                     gameStartScreen.classList.add('hidden');
                 }
                 
                 if (gameContent) {
                     gameContent.classList.remove('hidden');
                 }
                 
                 // 显示双人UI，隐藏单人UI
                 const singlePlayerUI = document.getElementById('single-player-ui');
                 const multiplayerUI = document.getElementById('multiplayer-ui');
                 
                 if (singlePlayerUI && multiplayerUI) {
                     singlePlayerUI.classList.add('hidden');
                     multiplayerUI.classList.remove('hidden');
                     
                     // 在進入雙人模式時隱藏選擇篇章容器、「文言大師之旅」標題等於遊戲過程無關的元素
                     const headerElement = document.querySelector('header');
                     if (headerElement) {
                         headerElement.style.display = 'none';
                     }
                     
                     const passageSelector = document.querySelector('.passage-selector');
                     if (passageSelector) {
                         passageSelector.style.display = 'none';
                     }
                     
                     // 隐藏设置按钮和版本号
                     if (document.getElementById('settings-button')) {
                         document.getElementById('settings-button').style.display = 'none';
                     }
                     
                     // 隐藏底部版本信息
                     const versionInfo = document.querySelector('.text-center.py-3.text-gray-500');
                     if (versionInfo) {
                         versionInfo.style.display = 'none';
                     }
                     
                     // 隱藏單人模式的秒錶、生命值、篇章名稱等元素
                     const stopwatch = document.getElementById('stopwatch');
                     if (stopwatch) {
                         stopwatch.style.display = 'none';
                     }
                     
                     const lives = document.getElementById('lives');
                     if (lives) {
                         lives.style.display = 'none';
                     }
                     
                     // 隱藏單人模式的進度條
                     const progressContainer = document.querySelector('.w-full.max-w-\\[200px\\]');
                     if (progressContainer) {
                         progressContainer.style.display = 'none';
                     }
                     
                     const passageInfo = document.querySelector('.passage-info');
                     if (passageInfo) {
                         passageInfo.style.display = 'none';
                     }
                     
                     const returnHomeBtn = document.getElementById('return-home-btn-game');
                     if (returnHomeBtn) {
                         returnHomeBtn.style.display = 'none';
                     }
                     
                     // 設置雙人模式總字數
                     const totalCharsTop = document.getElementById('total-chars-top');
                     const totalCharsBottom = document.getElementById('total-chars-bottom');
                     
                     if (totalCharsTop) totalCharsTop.textContent = totalNonPunctChars;
                     if (totalCharsBottom) totalCharsBottom.textContent = totalNonPunctChars;
                     
                     // 重置計時器變量但不立即啟動計時器
                     elapsedTimeBeforePauseTop = 0;
                     elapsedTimeBeforePauseBottom = 0;
                     multiplayerTimersStarted = false;
                     
                     // 清除上一局遊戲顯示的字符
                     const lastAnsweredCharsTop = document.getElementById('last-answered-chars-top');
                     const lastAnsweredCharsBottom = document.getElementById('last-answered-chars-bottom');
                     const currentCharTop = document.getElementById('current-char-top');
                     const currentCharBottom = document.getElementById('current-char-bottom');
                     
                     if (lastAnsweredCharsTop) lastAnsweredCharsTop.innerHTML = '';
                     if (lastAnsweredCharsBottom) lastAnsweredCharsBottom.innerHTML = '';
                     if (currentCharTop) currentCharTop.textContent = '';
                     if (currentCharBottom) currentCharBottom.textContent = '';
                     
                     // 重置進度顯示
                     const progressBarTop = document.getElementById('progress-bar-top');
                     const progressBarBottom = document.getElementById('progress-bar-bottom');
                     const progressTextTop = document.getElementById('progress-text-top');
                     const progressTextBottom = document.getElementById('progress-text-bottom');
                     
                     if (progressBarTop) progressBarTop.style.width = '0%';
                     if (progressBarBottom) progressBarBottom.style.width = '0%';
                     if (progressTextTop) progressTextTop.textContent = `0 / ${totalNonPunctChars}`;
                     if (progressTextBottom) progressTextBottom.textContent = `0 / ${totalNonPunctChars}`;
                 }
                 
                 // 添加雙人模式暫停按鈕事件
                 setupMultiplayerPauseButtons();
                 
                 // 开始游戏倒计时
                 const multiplayerCountdown = document.getElementById('multiplayer-countdown');
                 if (multiplayerCountdown) {
                     multiplayerCountdown.classList.remove('hidden');
                     
                     // 使用绿点倒计时
                     let countdownDots = 3;
                     let countdownText = '';
                     
                     function updateCountdownDots() {
                         countdownText = '';
                         for (let i = 0; i < countdownDots; i++) {
                             countdownText += '●';
                         }
                         multiplayerCountdown.querySelector('div').textContent = countdownText;
                         
                         if (countdownDots > 0) {
                             countdownDots--;
                             setTimeout(updateCountdownDots, 1000);
                         } else {
                             // 倒计时结束，开始游戏
                             multiplayerCountdown.classList.add('hidden');
                             window.multiplayerMode.gameStarted = true;
                             
                             // 在倒計時結束後啟動計時器
                             multiplayerTimersStarted = true;
                             startMultiplayerTimers();
                             
                             // 为两位玩家生成选项
                             updateMultiplayerDisplay();
                         }
                     }
                     
                     updateCountdownDots();
                 }
             }
             
             // 設置雙人模式的暫停按鈕功能
             function setupMultiplayerPauseButtons() {
                 const pauseBtnTop = document.getElementById('pause-btn-top');
                 const pauseBtnBottom = document.getElementById('pause-btn-bottom');
                 const multiplayerPauseOverlay = document.getElementById('multiplayer-pause-overlay');
                 const multiplayerContinueBtn = document.getElementById('multiplayer-continue-btn');
                 const multiplayerReturnBtn = document.getElementById('multiplayer-return-btn');
                 const multiplayerCountdownResume = document.getElementById('multiplayer-countdown-resume');
                 
                 // 雙人模式暫停狀態
                 let isMultiplayerPaused = false;
                 let multiplayerResumeCountdown = null;
                 
                 // 暫停函數
                 function pauseMultiplayerGame() {
                     if (isMultiplayerPaused) return;
                     
                     isMultiplayerPaused = true;
                     
                     // 暫停兩位玩家的計時器
                     stopMultiplayerTimers();
                     
                     // 禁止選擇選項
                     window.multiplayerMode.players.forEach(player => {
                         player.canSelect = false;
                     });
                     
                     // 顯示暫停覆蓋層
                     if (multiplayerPauseOverlay) {
                         multiplayerPauseOverlay.classList.remove('hidden');
                     }
                 }
                 
                 // 繼續遊戲函數
                 function resumeMultiplayerGame() {
                     if (!isMultiplayerPaused) return;
                     
                     isMultiplayerPaused = false;
                     
                     // 隱藏暫停覆蓋層
                     if (multiplayerPauseOverlay) {
                         multiplayerPauseOverlay.classList.add('hidden');
                     }
                     
                     // 確保計時器標記為已啟動
                     multiplayerTimersStarted = true;
                     
                     // 恢復計時器
                     startMultiplayerTimers();
                     
                     // 允許選擇選項
                     window.multiplayerMode.players.forEach(player => {
                         player.canSelect = true;
                     });
                 }
                 
                 // 上方玩家暫停按鈕
                 if (pauseBtnTop) {
                     pauseBtnTop.addEventListener('click', function() {
                         if (!window.multiplayerMode.gameStarted || window.multiplayerMode.winner !== null) return;
                         pauseMultiplayerGame();
                     });
                 }
                 
                 // 下方玩家暫停按鈕
                 if (pauseBtnBottom) {
                     pauseBtnBottom.addEventListener('click', function() {
                         if (!window.multiplayerMode.gameStarted || window.multiplayerMode.winner !== null) return;
                         pauseMultiplayerGame();
                     });
                 }
                 
                 // 繼續遊戲按鈕
                 if (multiplayerContinueBtn) {
                     multiplayerContinueBtn.addEventListener('click', function() {
                         // 隱藏按鈕，顯示倒計時
                         const pauseButtons = document.getElementById('multiplayer-pause-buttons');
                         if (pauseButtons) {
                             pauseButtons.classList.add('hidden');
                         }
                         
                         if (multiplayerCountdownResume) {
                             multiplayerCountdownResume.classList.remove('hidden');
                         }
                         
                         let count = 3;
                         const countdownNumber = multiplayerCountdownResume.querySelector('.pause-countdown-number');
                         if (countdownNumber) {
                             countdownNumber.textContent = count;
                         }
                         
                         // 清除可能存在的倒計時
                         if (multiplayerResumeCountdown) {
                             clearInterval(multiplayerResumeCountdown);
                         }
                         
                         // 開始新的倒計時
                         multiplayerResumeCountdown = setInterval(function() {
                             count--;
                             if (countdownNumber) {
                                 countdownNumber.textContent = count;
                                 countdownNumber.style.animation = 'none';
                                 void countdownNumber.offsetWidth; // 重置動畫
                                 countdownNumber.style.animation = 'countdownPulse 1s ease-out';
                             }
                             
                             if (count <= 0) {
                                 clearInterval(multiplayerResumeCountdown);
                                 multiplayerResumeCountdown = null;
                                 
                                 // 恢復遊戲
                                 resumeMultiplayerGame();
                                 
                                 // 重置界面
                                 if (pauseButtons) {
                                     pauseButtons.classList.remove('hidden');
                                 }
                                 if (multiplayerCountdownResume) {
                                     multiplayerCountdownResume.classList.add('hidden');
                                 }
                             }
                         }, 1000);
                     });
                 }
                 
                 // 返回主頁按鈕 - 修改為直接返回遊戲開始界面
                 if (multiplayerReturnBtn) {
                     multiplayerReturnBtn.addEventListener('click', function() {
                         // 隱藏暫停覆蓋層
                         if (multiplayerPauseOverlay) {
                             multiplayerPauseOverlay.classList.add('hidden');
                         }
                         
                         // 清除倒計時
                         if (multiplayerResumeCountdown) {
                             clearInterval(multiplayerResumeCountdown);
                             multiplayerResumeCountdown = null;
                         }
                         
                         // 重置界面
                         const pauseButtons = document.getElementById('multiplayer-pause-buttons');
                         if (pauseButtons) {
                             pauseButtons.classList.remove('hidden');
                         }
                         if (multiplayerCountdownResume) {
                             multiplayerCountdownResume.classList.add('hidden');
                         }
                         
                         // 重置雙人模式狀態
                         window.multiplayerMode.active = false;
                         isMultiplayerPaused = false;
                         
                         // 停止計時器
                         stopMultiplayerTimers();
                         
                         // 重要：完全重置計時器相關變量
                         timerTopInterval = null;
                         timerBottomInterval = null;
                         startTimeTop = null;
                         startTimeBottom = null;
                         elapsedTimeBeforePauseTop = 0;
                         elapsedTimeBeforePauseBottom = 0;
                         
                         // 重新顯示之前隱藏的元素
                         const headerElement = document.querySelector('header');
                         if (headerElement) {
                             headerElement.style.display = 'block';
                         }
                         
                         const passageSelector = document.querySelector('.passage-selector');
                         if (passageSelector) {
                             passageSelector.style.display = 'block';
                         }
                         
                         // 恢復設置按鈕和版本號
                         if (document.getElementById('settings-button')) {
                             document.getElementById('settings-button').style.display = 'flex';
                         }
                         
                         // 恢復底部版本信息
                         const versionInfo = document.querySelector('.text-center.py-3.text-gray-500');
                         if (versionInfo) {
                             versionInfo.style.display = 'block';
                         }
                         
                         // 恢復單人模式UI元素
                         const stopwatch = document.getElementById('stopwatch');
                         if (stopwatch) {
                             stopwatch.style.display = 'block';
                         }
                         
                         const lives = document.getElementById('lives');
                         if (lives) {
                             lives.style.display = 'block';
                         }
                         
                     // 恢復單人模式進度條
                     const progressContainer = document.querySelector('.w-full.max-w-\\[200px\\]');
                     if (progressContainer) {
                         progressContainer.style.display = 'block';
                     }

                         const passageInfo = document.querySelector('.passage-info');
                         if (passageInfo) {
                             passageInfo.style.display = 'block';
                         }
                         
                         // 確保返回主頁按鈕顯示
                         const returnHomeBtn = document.getElementById('return-home-btn-game');
                         if (returnHomeBtn) {
                             returnHomeBtn.classList.remove('hidden');
                             returnHomeBtn.style.display = 'flex';
                         }
                         
                         // 直接返回遊戲開始界面, 不觸發返回主頁按鈕
                         const gameStartScreen = document.getElementById('game-start-screen');
                         const gameContent = document.getElementById('game-content');
                         const gamePage = document.getElementById('game-page');
                         
                         if (gameStartScreen && gameContent && gamePage) {
                             // 隱藏遊戲內容，顯示開始畫面
                             gameContent.classList.add('hidden');
                             gameStartScreen.classList.remove('hidden');
                             
                             // 顯示遊戲頁面
                             gamePage.classList.remove('hidden');
                             gamePage.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                             
                             // 確保書本頁面翻轉效果生效
                             const bookPage = document.querySelector('.page');
                             if (bookPage) {
                                 bookPage.classList.add('turned');
                             }
                             
                             // 切換回單人模式 - 使用gameModeSwitch
                             if (gameModeSwitch && gameModeSwitch.checked) {
                                 gameModeSwitch.checked = false;
                                 window.gameMode = 'single';
                                 console.log("返回主頁：已切換到單人模式");
                             }
                         }
                     });
                 }
                 
                 // 鍵盤事件 - ESC 鍵暫停/繼續
                 document.addEventListener('keydown', function(e) {
                     if (e.key === 'Escape' && window.multiplayerMode.active && window.multiplayerMode.gameStarted) {
                         if (isMultiplayerPaused) {
                             // 如果已暫停，按ESC將觸發繼續按鈕
                             if (multiplayerContinueBtn) {
                                 multiplayerContinueBtn.click();
                             }
                         } else {
                             // 如果未暫停，按ESC將暫停遊戲
                             pauseMultiplayerGame();
                         }
                     }
                 });
             }
             
             // 雙人模式計時器相關變量
             let timerTopInterval = null;
             let timerBottomInterval = null;
             let startTimeTop = null;
             let startTimeBottom = null;
             let elapsedTimeBeforePauseTop = 0;
             let elapsedTimeBeforePauseBottom = 0;
             let multiplayerTimersStarted = false; // 標記計時器是否已經開始
             
             // 開始雙人模式計時器
             function startMultiplayerTimers() {
                 // 如果計時器尚未開始或已被暫停，則啟動計時器
                 if (!multiplayerTimersStarted) {
                     console.log("雙人模式計時器尚未啟動，等待倒計時結束");
                     return;
                 }
                 
                 const timerTopElement = document.getElementById('timer-top');
                 const timerBottomElement = document.getElementById('timer-bottom');
                 
                 // 設置開始時間 - 考慮先前累積的時間
                 startTimeTop = new Date();
                 startTimeBottom = new Date();
                 
                 console.log("開始雙人模式計時器");
                 
                 // 啟動上方玩家計時器
                 timerTopInterval = setInterval(function() {
                     if (!timerTopElement) return;
                     
                     const currentTime = new Date();
                     const totalElapsedMs = elapsedTimeBeforePauseTop + (currentTime - startTimeTop);
                     
                     // 轉換為時間格式
                     const totalElapsedDate = new Date(totalElapsedMs);
                     const minutes = String(totalElapsedDate.getUTCMinutes()).padStart(2, '0');
                     const seconds = String(totalElapsedDate.getUTCSeconds()).padStart(2, '0');
                     const tenths = Math.floor(totalElapsedDate.getUTCMilliseconds() / 100);
                     
                     timerTopElement.textContent = `${minutes}:${seconds}.${tenths}`;
                 }, 100);
                 
                 // 啟動下方玩家計時器
                 timerBottomInterval = setInterval(function() {
                     if (!timerBottomElement) return;
                     
                     const currentTime = new Date();
                     const totalElapsedMs = elapsedTimeBeforePauseBottom + (currentTime - startTimeBottom);
                     
                     // 轉換為時間格式
                     const totalElapsedDate = new Date(totalElapsedMs);
                     const minutes = String(totalElapsedDate.getUTCMinutes()).padStart(2, '0');
                     const seconds = String(totalElapsedDate.getUTCSeconds()).padStart(2, '0');
                     const tenths = Math.floor(totalElapsedDate.getUTCMilliseconds() / 100);
                     
                     timerBottomElement.textContent = `${minutes}:${seconds}.${tenths}`;
                 }, 100);
             }
             
             // 停止雙人模式計時器
             function stopMultiplayerTimers() {
                 // 停止上方玩家計時器並保存累計時間
                 if (timerTopInterval) {
                     clearInterval(timerTopInterval);
                     timerTopInterval = null;
                     
                     if (startTimeTop) {
                         const currentTime = new Date();
                         elapsedTimeBeforePauseTop += (currentTime - startTimeTop);
                         startTimeTop = null;
                     }
                 }
                 
                 // 停止下方玩家計時器並保存累計時間
                 if (timerBottomInterval) {
                     clearInterval(timerBottomInterval);
                     timerBottomInterval = null;
                     
                     if (startTimeBottom) {
                         const currentTime = new Date();
                         elapsedTimeBeforePauseBottom += (currentTime - startTimeBottom);
                         startTimeBottom = null;
                     }
                 }
                 
                 // 標記計時器未啟動
                 multiplayerTimersStarted = false;
             }
             
             // 更新双人模式显示
             function updateMultiplayerDisplay() {
                 // 更新上方玩家
                 updatePlayerDisplay(0);
                 // 更新下方玩家
                 updatePlayerDisplay(1);
                 
                 // 更新進度條
                 updateMultiplayerProgress();
                 
                 // 隱藏單人模式進度條
                 const singleProgressContainer = document.querySelector('.w-full.max-w-\\[200px\\]');
                 if (singleProgressContainer) {
                     singleProgressContainer.style.display = 'none';
                 }
             }
             
             // 更新雙人模式進度條
             function updateMultiplayerProgress() {
                 // 上方玩家進度
                 const player1 = window.multiplayerMode.players[0];
                 const player1Progress = player1.correctAnswers;
                 const totalCharsTop = document.getElementById('total-chars-top');
                 const progressTextTop = document.getElementById('progress-text-top');
                 const progressBarTop = document.getElementById('progress-bar-top');
                 
                 // 下方玩家進度
                 const player2 = window.multiplayerMode.players[1];
                 const player2Progress = player2.correctAnswers;
                 const totalCharsBottom = document.getElementById('total-chars-bottom');
                 const progressTextBottom = document.getElementById('progress-text-bottom');
                 const progressBarBottom = document.getElementById('progress-bar-bottom');
                 
                 // 更新顯示
                 if (totalCharsTop) totalCharsTop.textContent = totalNonPunctChars;
                 if (progressTextTop) progressTextTop.textContent = `${player1Progress} / ${totalNonPunctChars}`;
                 if (progressBarTop) {
                     const progressPercentage = (totalNonPunctChars > 0) ? (player1Progress / totalNonPunctChars * 100) : 0;
                     progressBarTop.style.width = `${progressPercentage}%`;
                 }
                 
                 if (totalCharsBottom) totalCharsBottom.textContent = totalNonPunctChars;
                 if (progressTextBottom) progressTextBottom.textContent = `${player2Progress} / ${totalNonPunctChars}`;
                 if (progressBarBottom) {
                     const progressPercentage = (totalNonPunctChars > 0) ? (player2Progress / totalNonPunctChars * 100) : 0;
                     progressBarBottom.style.width = `${progressPercentage}%`;
                 }
             }
             
             // 更新单个玩家显示
             function updatePlayerDisplay(playerIndex) {
                 const player = window.multiplayerMode.players[playerIndex];
                 const position = player.currentPosition;
                 const isTop = playerIndex === 0;
                 const prefix = isTop ? 'top' : 'bottom';
                 
                 const currentCharElement = document.getElementById(`current-char-${prefix}`);
                 const optionsContainer = document.getElementById(`options-container-${prefix}`);
                 const lastAnsweredCharsElement = document.getElementById(`last-answered-chars-${prefix}`);
                 
                 if (!currentCharElement || !optionsContainer) return;
                 
                 // 跳过标点符号
                 while (position < content.length && isPunctuation(content[position])) {
                     player.currentPosition++;
                 }
                 
                 // 更新当前字符显示
                 if (player.currentPosition < content.length) {
                     currentCharElement.textContent = '';
                     
                     // 生成选项
                     generateMultiplayerOptions(playerIndex);
                     
                     // 更新已回答字符
                     if (lastAnsweredCharsElement && player.lastAnsweredChars.length > 0) {
                         let htmlContent = '';
                         
                         // 找出最后一个非标点符号字符的索引
                         let lastNonPunctIndex = -1;
                         for (let i = player.lastAnsweredChars.length - 1; i >= 0; i--) {
                             if (!isPunctuation(player.lastAnsweredChars[i])) {
                                 lastNonPunctIndex = i;
                                 break;
                             }
                         }
                         
                         // 构建HTML内容
                         for (let i = 0; i < player.lastAnsweredChars.length; i++) {
                             // 如果是最后一个非标点符号字符，加粗放大
                             if (i === lastNonPunctIndex) {
                                 htmlContent += `<span class="text-2xl md:text-3xl font-bold">${player.lastAnsweredChars[i]}</span>`;
                             } else {
                                 htmlContent += player.lastAnsweredChars[i];
                             }
                         }
                         
                         lastAnsweredCharsElement.innerHTML = htmlContent;
                     }
                 } else {
                     // 玩家已完成游戏
                     handleMultiplayerGameEnd(playerIndex);
                 }
             }
             
             // 为玩家生成选项
             function generateMultiplayerOptions(playerIndex) {
                 const player = window.multiplayerMode.players[playerIndex];
                 const pos = player.currentPosition;
                 const isTop = playerIndex === 0;
                 const prefix = isTop ? 'top' : 'bottom';
                 
                 const optionsContainer = document.getElementById(`options-container-${prefix}`);
                 if (!optionsContainer || pos >= content.length) return;
                 
                 // 清空选项容器
                 optionsContainer.innerHTML = '';
                 
                 // 获取正确答案
                 const correctAnswer = content[pos];
                 
                 // 生成两个干扰选项
                 let options = [correctAnswer];
                 
                 while (options.length < 3) {
                     const randomIndex = Math.floor(Math.random() * content.length);
                     const randomChar = content[randomIndex];
                     
                     // 确保不重复且不是标点符号
                     if (!options.includes(randomChar) && 
                         !isPunctuation(randomChar) && 
                         randomChar !== correctAnswer) {
                         options.push(randomChar);
                     }
                 }
                 
                 // 打乱选项顺序
                 options = shuffleArray(options);
                 
                 // 创建选项按钮
                 options.forEach(option => {
                     const btn = document.createElement('button');
                     btn.className = 'option-btn h-16 md:h-20 text-2xl md:text-3xl bg-white dark:bg-gray-700 rounded-lg border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none';
                     btn.textContent = option;
                     
                     btn.addEventListener('touchstart', function() {
                         const playerObj = window.multiplayerMode.players[playerIndex];
                         if (!playerObj.canSelect || !window.multiplayerMode.gameStarted) return;
                         
                         if (option === correctAnswer) {
                             handleMultiplayerCorrectAnswer(playerIndex, btn);
                         } else {
                             handleMultiplayerIncorrectAnswer(playerIndex, btn);
                         }
                     });
                     
                     optionsContainer.appendChild(btn);
                 });
             }
             
             // 处理双人模式正确答案
             function handleMultiplayerCorrectAnswer(playerIndex, btn) {
                 const player = window.multiplayerMode.players[playerIndex];
                 player.correctAnswers++;
                 
                 // 添加动画效果
                 btn.classList.add('correct');
                 
                 // 添加当前字符到已回答字符列表
                 player.lastAnsweredChars.push(content[player.currentPosition]);
                 
                 // 保存当前位置并前进
                 const savedPosition = player.currentPosition;
                 player.currentPosition++;
                 
                 // 检查并添加标点符号
                 while (player.currentPosition < content.length && isPunctuation(content[player.currentPosition])) {
                     player.lastAnsweredChars.push(content[player.currentPosition]);
                     player.currentPosition++;
                 }
                 
                 // 如果超出最大显示字符限制，移除最早的字符
                 const MAX_DISPLAYED_CHARS = 15;
                 while (player.lastAnsweredChars.length > MAX_DISPLAYED_CHARS) {
                     player.lastAnsweredChars.shift();
                 }
                 
                 // 即時更新進度條
                 updateMultiplayerProgress();
                 
                 //雙人模式節奏快速
                 setTimeout(() => {
                     updatePlayerDisplay(playerIndex);
                 }, 10); 
             }
             
             // 处理双人模式错误答案
             function handleMultiplayerIncorrectAnswer(playerIndex, btn) {
                 const player = window.multiplayerMode.players[playerIndex];
                 const isTop = playerIndex === 0;
                 const prefix = isTop ? 'top' : 'bottom';
                 
                 // 添加错误效果
                 btn.classList.add('incorrect');
                 
                 // 禁用选择3秒
                 player.canSelect = false;
                 
                 // 显示错误覆盖层和红点计时器
                 const errorOverlay = document.getElementById(`${prefix}-player-error-overlay`);
                 const errorTimer = document.getElementById(`${prefix}-error-timer`);
                 
                 if (errorOverlay && errorTimer) {
                     // 显示覆盖层
                     errorOverlay.classList.remove('hidden');
                     errorOverlay.style.display = 'flex';
                     
                     // 红点计时
                     let dots = 3;
                     errorTimer.textContent = '●●●';
                     
                     // 清除之前的计时器
                     if (player.errorTimer) {
                         clearInterval(player.errorTimer);
                     }
                     
                     // 设置新计时器
                     player.errorTimer = setInterval(() => {
                         dots--;
                         let dotText = '';
                         for (let i = 0; i < dots; i++) {
                             dotText += '●';
                         }
                         errorTimer.textContent = dotText;
                         
                         if (dots <= 0) {
                             clearInterval(player.errorTimer);
                             player.errorTimer = null;
                             errorOverlay.classList.add('hidden');
                             // 確保錯誤覆蓋層完全隱藏
                             errorOverlay.style.display = 'none';
                             player.canSelect = true;
                             
                             // 移除按钮错误效果
                             btn.classList.remove('incorrect');
                         }
                     }, 1000);
                 }
             }
             
             // 處理雙人模式遊戲結束
             function handleMultiplayerGameEnd(winnerIndex) {
                 // 如果已經有獲勝者，不再處理
                 if (window.multiplayerMode.winner !== null) return;
                 
                 // 設置獲勝者
                 window.multiplayerMode.winner = winnerIndex;
                 window.multiplayerMode.gameStarted = false;
                 
                 // 停止計時器
                 stopMultiplayerTimers();
                 
                 // 創建獲勝提示層
                 const victoryOverlay = document.createElement('div');
                 victoryOverlay.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[1000]';
                 victoryOverlay.id = 'multiplayer-victory-overlay';
                 
                 // 獲取雙方進度
                 const player1Progress = window.multiplayerMode.players[0].correctAnswers;
                 const player2Progress = window.multiplayerMode.players[1].correctAnswers;
                 
                 // 獲取勝利玩家的計時器內容
                 const winnerTimerElement = winnerIndex === 0 ? 
                     document.getElementById('timer-top') : 
                     document.getElementById('timer-bottom');
                 
                 const winnerTime = winnerTimerElement ? winnerTimerElement.textContent : "00:00.0";
                 
                 victoryOverlay.innerHTML = `
                     <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 text-center">
                         <h2 class="text-2xl font-bold text-green-600 dark:text-green-400 mb-6">${winnerIndex === 0 ? '上方' : '下方'}玩家獲勝！</h2>
                         <div class="bg-gray-100 dark:bg-gray-700 p-4 rounded-lg mb-5">
                             <p class="text-gray-700 dark:text-gray-300">完成時間: ${winnerTime}</p>
                             <div class="flex justify-between items-center mt-2 px-4">
                                 <span class="text-gray-700 dark:text-gray-300">上方玩家</span>
                                 <span class="font-medium">${player1Progress} 字</span>
                             </div>
                             <div class="flex justify-between items-center mt-1 px-4">
                                 <span class="text-gray-700 dark:text-gray-300">下方玩家</span>
                                 <span class="font-medium">${player2Progress} 字</span>
                             </div>
                         </div>
                         <div class="flex justify-center gap-6 mt-4">
                             <button id="restart-multi-btn" class="w-12 h-12 bg-amber-500 text-white rounded-full hover:bg-amber-600 transition-colors flex items-center justify-center text-xl">
                                 <i class="fas fa-redo"></i>
                             </button>
                             <button id="return-home-multi-btn" class="w-12 h-12 bg-primary text-white rounded-full hover:bg-opacity-90 flex items-center justify-center text-xl">
                                 <i class="fas fa-home"></i>
                             </button>
                         </div>
                     </div>
                 `;
                 
                 document.body.appendChild(victoryOverlay);
                 
                 // 添加按鈕事件
                 document.getElementById('restart-multi-btn').addEventListener('click', function() {
                     // 移除勝利提示
                     document.body.removeChild(victoryOverlay);
                     // 重新開始雙人遊戲
                     startMultiplayerGame();
                 });
                 
                 document.getElementById('return-home-multi-btn').addEventListener('click', function() {
                     // 移除勝利提示
                     document.body.removeChild(victoryOverlay);
                     
                     // 重置狀態
                     window.multiplayerMode.active = false;
                     
                     // 重要：完全重置計時器相關變量
                     if (timerTopInterval) {
                         clearInterval(timerTopInterval);
                         timerTopInterval = null;
                     }
                     if (timerBottomInterval) {
                         clearInterval(timerBottomInterval);
                         timerBottomInterval = null;
                     }
                     startTimeTop = null;
                     startTimeBottom = null;
                     elapsedTimeBeforePauseTop = 0;
                     elapsedTimeBeforePauseBottom = 0;
                     multiplayerTimersStarted = false;
                     
                     // 顯示單人UI，隱藏雙人UI
                     const singlePlayerUI = document.getElementById('single-player-ui');
                     const multiplayerUI = document.getElementById('multiplayer-ui');
                     
                     if (singlePlayerUI && multiplayerUI) {
                         multiplayerUI.classList.add('hidden');
                     }
                     
                     // 切換回單人模式 - 使用新的滑塊
                     if (gameModeSwitch && gameModeSwitch.checked) {
                         gameModeSwitch.checked = false;
                         window.gameMode = 'single';
                         console.log("勝利返回：已切換到單人模式");
                     }
                     
                     // 重新顯示之前隱藏的元素
                     const headerElement = document.querySelector('header');
                     if (headerElement) {
                         headerElement.style.display = 'block';
                     }
                     
                     const passageSelector = document.querySelector('.passage-selector');
                     if (passageSelector) {
                         passageSelector.style.display = 'block';
                     }
                     
                     // 恢復設置按鈕和版本號
                     if (document.getElementById('settings-button')) {
                         document.getElementById('settings-button').style.display = 'flex';
                     }
                     
                     // 恢復底部版本信息
                     const versionInfo = document.querySelector('.text-center.py-3.text-gray-500');
                     if (versionInfo) {
                         versionInfo.style.display = 'block';
                     }
                     
                     // 恢復單人模式UI元素
                     const stopwatch = document.getElementById('stopwatch');
                     if (stopwatch) {
                         stopwatch.style.display = 'block';
                     }
                     
                     const lives = document.getElementById('lives');
                     if (lives) {
                         lives.style.display = 'block';
                     }
                     
                     // 恢復單人模式進度條
                     const progressContainer = document.querySelector('.w-full.max-w-\\[200px\\]');
                     if (progressContainer) {
                         progressContainer.style.display = 'block';
                     }
                     
                     const passageInfo = document.querySelector('.passage-info');
                     if (passageInfo) {
                         passageInfo.style.display = 'block';
                     }
                     
                     // 確保返回主頁按鈕顯示
                     const returnHomeBtn = document.getElementById('return-home-btn-game');
                     if (returnHomeBtn) {
                         returnHomeBtn.classList.remove('hidden');
                         returnHomeBtn.style.display = 'flex';
                     }
                     
                     // 確保暫停按鈕隱藏
                     const pauseBtn = document.getElementById('pause-btn');
                     if (pauseBtn) {
                         pauseBtn.classList.add('hidden');
                     }
                     
                     // 直接返回遊戲開始界面
                     const gameStartScreen = document.getElementById('game-start-screen');
                     const gameContent = document.getElementById('game-content');
                     
                     if (gameStartScreen && gameContent) {
                         // 隱藏遊戲內容，顯示開始畫面
                         gameContent.classList.add('hidden');
                         gameStartScreen.classList.remove('hidden');
                     }
                     
                     console.log("已重置計時器並更新遊戲控制按鈕");
                 });
             }
             
             // 开始游戏按钮事件
             if (startGameBtn) {
                 startGameBtn.addEventListener('click', function() {
                     // 根据当前模式进入相应游戏
                     if (window.gameMode === 'multi') {
                         // 显示双人模式确认对话框
                         showMultiplayerConfirm();
                     } else {
                         // 单人模式原有逻辑
                         gameStartScreen.classList.add('hidden');
                         countdownContainer.classList.remove('hidden');
                         
                         // 確保選擇背誦段落界面關閉
                         passageContent.classList.add('hidden');
                         passageToggle.style.transform = 'rotate(0deg)';
                         passageContainer.style.maxHeight = '46px';
                         
                         // 重置暫停狀態
                         hasPaused = false;
                         
                         // 在倒計時期間禁用設置按鈕
                         window.disableSettingsButton();
                         
                         let countdown = 3;
                         
                         // 显示倒计时
                         function showCountdown() {
                             if (countdown > 0) {
                                 countdownNumber.textContent = countdown;
                                 countdownNumber.style.animation = 'none';
                                 void countdownNumber.offsetWidth; // 重置动画
                                 countdownNumber.style.animation = 'countdown-pulse 1s ease-in-out';
                                 
                                 countdown--;
                                 setTimeout(showCountdown, 1000);
                             } else {
                                 // 倒计时结束，显示"开始！"
                                 countdownNumber.textContent = '開始！';
                                 countdownNumber.style.animation = 'none';
                                 void countdownNumber.offsetWidth;
                                 countdownNumber.style.animation = 'countdown-pulse 0.7s ease-in-out';
                                 
                                 // 开始游戏
                                 setTimeout(function() {
                                     countdownContainer.classList.add('hidden');
                                     gameContent.classList.remove('hidden');
                                     
                                     // 确保显示单人UI
                                     const singlePlayerUI = document.getElementById('single-player-ui');
                                     const multiplayerUI = document.getElementById('multiplayer-ui');
                                     
                                     if (singlePlayerUI && multiplayerUI) {
                                         singlePlayerUI.classList.remove('hidden');
                                         multiplayerUI.classList.add('hidden');
                                     }
                                     
                                     // 切換按鈕顯示為暫停按鈕
                                     updateGameControlButtons('playing');
                                     
                                     // 重置並開始秒表 (確保從0開始)
                                     elapsedTimeBeforePause = 0; // 重置累計時間
                                     resetStopwatch();
                                     
                                     // 遊戲開始后重新啟用設置按鈕
                                     window.enableSettingsButton();
                                     
                                     // 显示游戏内容
                                     updateDisplay();
                                 }, 800);
                             }
                         }
                         
                         showCountdown();
                     }
                 });
             } else {
                 console.error("開始遊戲按鈕未找到");
             }
             
             // 选择篇章功能
             const passageContainer = document.getElementById('passage-container');
             const passageHeader = document.getElementById('passage-header');
             const passageToggle = document.getElementById('passage-toggle');
             const passageContent = document.getElementById('passage-content');
             const categoryBtns = document.querySelectorAll('.category-btn');
             const passageList = document.getElementById('passage-list');
             
         // 完整的事件監聽函數替換
         if (passageHeader && passageToggle && passageContent) {
         // 篇章選擇器默認關閉
         // 用戶需要點擊才會打開
         
         // 在全局變量區域添加一個標記
         let isFirstTimeOpeningSelector = true; // 標記是否是首次打開篇章選擇器
         
         // 切换篇章選擇器
         passageHeader.addEventListener('click', function() {
         console.log("篇章標頭被點擊");
         
         if (passageContent.classList.contains('hidden')) {
         // 打開篇章選擇器
         console.log("打開篇章選擇器");
         passageContent.classList.remove('hidden');
         passageToggle.style.transform = 'rotate(180deg)';
         
         // 添加更自然的開啟動畫效果
         passageContent.style.opacity = '0';
         passageContent.style.transform = 'translateY(-20px)';
         passageContent.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
         passageContainer.style.transition = 'max-height 0.5s cubic-bezier(0.19, 1, 0.22, 1)';
         passageContainer.style.maxHeight = '500px'; // 立即設置足夠的高度
         
         // 觸發重繪並應用動畫
         setTimeout(() => {
             passageContent.style.opacity = '1';
             passageContent.style.transform = 'translateY(0)';
         }, 10);
         
         // 自動關閉段落選擇器
         const paragraphSelector = document.getElementById('paragraph-selector');
         if (paragraphSelector) {
             console.log("自動關閉段落選擇器");
             paragraphSelector.classList.add('hidden');
         }
         
         // 首次打開時不預設任何篇章，但再次打開時加載上次的篇章
         const shouldPreselect = !isFirstTimeOpeningSelector && currentPassageKey && currentPassageKey.length > 0;
         
         if (shouldPreselect) {
             // 如果不是首次打開並且有上次選擇的篇章，則自動打開該篇章
             const passageItems = document.querySelectorAll('.passage-item');
             passageItems.forEach(item => {
                 if (item.dataset.value === currentPassageKey) {
                     // 移除所有篇章的active樣式
                     passageItems.forEach(i => 
                         i.classList.remove('active', 'bg-amber-100', 'dark:bg-amber-900'));
                     
                     // 添加當前篇章的active樣式
                     item.classList.add('active', 'bg-amber-100', 'dark:bg-amber-900');
                     
                     // 顯示該篇章的段落選擇器
                     if (paragraphSelector && paragraphSelector.classList.contains('hidden')) {
                         // 只有在段落選擇器隱藏時才調用，避免重複加載
                         showParagraphSelector(currentPassageKey);
                     }
                     
                     // 如果篇章項目當前是隱藏的，則打開其所屬的分類
                     if (item.classList.contains('hidden')) {
                         const category = item.dataset.category;
                         // 找到並激活對應的分類按鈕
                         categoryBtns.forEach(btn => {
                             if (btn.dataset.category === category) {
                                 // 移除所有按鈕的active樣式
                                 categoryBtns.forEach(b => b.classList.remove('active', 'bg-amber-200', 'dark:bg-amber-700'));
                                 
                                 // 添加當前按鈕的active樣式
                                 btn.classList.add('active', 'bg-amber-200', 'dark:bg-amber-700');
                                 
                                 // 顯示該分類下的所有篇章
                                 passageItems.forEach(i => {
                                     if (i.dataset.category === category) {
                                         i.classList.remove('hidden');
                                     } else {
                                         i.classList.add('hidden');
                                     }
                                 });
                             }
                         });
                     }
                 }
             });
         }
         
         // 更新標記，表示篇章選擇器已被打開過
         isFirstTimeOpeningSelector = false;
         
         } else {
         // 關閉篇章選擇器 - 添加收縮動畫
         console.log("關閉篇章選擇器");
         passageToggle.style.transform = 'rotate(0deg)';
             
             // 添加淡出動畫效果
             passageContent.style.opacity = '0';
             passageContent.style.transform = 'translateY(10px)';
             
             // 先收縮容器高度，然後隱藏內容
             passageContainer.style.transition = 'max-height 0.4s cubic-bezier(0.6, 0.04, 0.98, 0.335)';
             passageContainer.style.maxHeight = '46px';
             
             // 延遲隱藏內容，讓收縮動畫先完成
             setTimeout(() => {
                 passageContent.classList.add('hidden');
                 
                 // 重置動畫狀態，為下次打開做準備
                 setTimeout(() => {
                     passageContent.style.transition = 'none';
                     passageContent.style.opacity = '1';
                     passageContent.style.transform = 'translateY(0)';
                 }, 50);
                 
                 // 強制隱藏段落選擇器
                 const paragraphSelector = document.getElementById('paragraph-selector');
                 if (paragraphSelector) {
                     console.log("隱藏段落選擇器");
                     paragraphSelector.classList.add('hidden');
                     
                     // 重置段落選擇器動畫狀態
                     setTimeout(() => {
                         paragraphSelector.style.transition = 'none';
                         paragraphSelector.style.opacity = '1';
                         paragraphSelector.style.transform = 'translateY(0)';
                     }, 50);
                 } else {
                     console.error("找不到段落選擇器元素");
                 }
             }, 300); // 等待收縮動畫完成
         }
         });
         }            
             // 分类按钮点击事件
             categoryBtns.forEach(btn => {
                 btn.addEventListener('click', function() {
                     // 移除所有按钮的active样式
                     categoryBtns.forEach(b => b.classList.remove('active', 'bg-amber-200', 'dark:bg-amber-700'));
                     
                     // 添加当前按钮的active样式
                     this.classList.add('active', 'bg-amber-200', 'dark:bg-amber-700');
                     
                     // 過濾篇章列表
                     const category = this.dataset.category;
                     const passageItems = document.querySelectorAll('.passage-item');
                     const emptyMessage = document.getElementById('empty-category-message');
                     
                     if (!emptyMessage) {
                         console.error("空分類提示元素未找到");
                         return;
                     }
                     
                     // 先隱藏所有篇章和提示信息
                     passageItems.forEach(item => {
                         item.classList.add('hidden');
                     });
                     emptyMessage.classList.add('hidden');
                     
                     // 檢查顯示符合分類的篇章
                     let hasVisibleItems = false;
                     passageItems.forEach(item => {
                         if (item.dataset.category === category) {
                             item.classList.remove('hidden');
                             hasVisibleItems = true;
                         }
                     });
                     
                     // 如果該分類沒有篇章，顯示提示信息
                     if (!hasVisibleItems) {
                         emptyMessage.classList.remove('hidden');
                     }
                     
                     // 隐藏段落选择器
                     const paragraphSelector = document.getElementById('paragraph-selector');
                     if (paragraphSelector) {
                         paragraphSelector.classList.add('hidden');
                     }
                     
                     // 確保篇章列表容器有足夠高度並可滾動
                     const passageList = document.getElementById('passage-list');
                     if (passageList) {
                         // 計算合適的最大高度 (視口高度的20%)
                         const maxHeight = Math.max(60, window.innerHeight * 0.2) + 'px';
                         passageList.style.maxHeight = maxHeight;
                         
                         // 確保容器可滾動
                         passageList.style.overflowY = 'auto';
                     }
                     
                     // 確保主容器有足夠空間顯示列表
                     if (passageContainer) {
                         // 視口高度的60%，但至少600px
                         passageContainer.style.maxHeight = Math.max(600, window.innerHeight * 0.6) + 'px';
                     }
                 });
             });
             
             // 自動生成篇章項目的函數
             function generatePassageItems() {
                 const container = document.getElementById('passage-list');
                 if (!container) {
                     console.error("篇章列表容器未找到");
                     return;
                 }
                 
                 // 保存空分類提示消息
                 const emptyMessage = document.getElementById('empty-category-message');
                 let savedEmptyMsg = null;
                 if (emptyMessage) {
                     savedEmptyMsg = emptyMessage.cloneNode(true);
                 }
                 
                 // 清空容器
                 container.innerHTML = '';
                 
                 // 恢復空分類提示消息
                 if (savedEmptyMsg) {
                     container.appendChild(savedEmptyMsg);
                 }
                 
                 // 為每個篇章創建項目
                 Object.keys(passages).forEach(key => {
                     const passage = passages[key];
                     
                     // 創建篇章項目元素
                     const item = document.createElement('div');
                     item.className = 'passage-item p-2 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md cursor-pointer hidden';
                     item.dataset.value = key;
                     item.dataset.category = passage.category || '其他'; // 使用篇章中定義的分類
                     item.textContent = `${passage.title} - ${passage.author}`;
                     
                     // 添加到容器中
                     container.appendChild(item);
                 });
                 
                 // 添加篇章項目的點擊事件
                 addPassageItemListeners();
             }
             
             // 为篇章项添加点击事件监听
             function addPassageItemListeners() {
                 document.querySelectorAll('.passage-item').forEach(item => {
                     item.addEventListener('click', function() {
                         // 移除所有篇章的active样式
                         document.querySelectorAll('.passage-item').forEach(i => 
                             i.classList.remove('active', 'bg-amber-100', 'dark:bg-amber-900'));
                         
                         // 添加当前篇章的active样式
                         this.classList.add('active', 'bg-amber-100', 'dark:bg-amber-900');
                         
                         // 获取选中的篇章
                         const passageKey = this.dataset.value;
                         currentPassageKey = passageKey;
                         
                         // 显示段落选择器
                         showParagraphSelector(passageKey);
                     });
                 });
             }
             
             // 自動為所有篇章生成內容
             function initializePassages() {
                 Object.keys(passages).forEach(key => {
                     if (!passages[key].content) {
                         passages[key].content = passages[key].paragraphs.join('');
                     }
                 });
             }
             
             // 显示段落选择器
             function showParagraphSelector(passageKey) {
                 // 添加动画效果 - 用于段落选择器的打开过渡
                 const paragraphSelector = document.getElementById('paragraph-selector');
                 const paragraphList = document.getElementById('paragraph-list');
                 const selectedPassage = passages[passageKey];
                 
                 if (!paragraphSelector || !paragraphList) {
                     console.error("段落選擇器元素未找到");
                     return;
                 }
                 
                 if (!selectedPassage) {
                     console.error("選中的篇章不存在:", passageKey);
                     return;
                 }
                 
                 // 清空段落列表
                 paragraphList.innerHTML = '';
                 
                 // 添加"全文"选项
                 const allOption = document.createElement('div');
                 allOption.className = 'flex items-center mb-2';
                 allOption.innerHTML = `
                     <input type="checkbox" id="paragraph-all" class="mr-2 h-4 w-4 text-primary" checked>
                     <label for="paragraph-all" class="text-gray-700 dark:text-gray-300 cursor-pointer font-medium">全文</label>
                 `;
                 paragraphList.appendChild(allOption);
                 
                 // 全选按钮逻辑
                 const allCheckbox = allOption.querySelector('input');
                 if (allCheckbox) {
                     allCheckbox.addEventListener('change', function() {
                         // 获取所有段落复选框
                         const paragraphCheckboxes = paragraphOptionsContainer.querySelectorAll('.paragraph-checkbox');
                         
                         // 设置所有段落复选框与全选框状态一致
                         paragraphCheckboxes.forEach(checkbox => {
                             checkbox.checked = this.checked;
                         });
                     });
                 }
                 
                 // 创建包含所有段落选项的容器
                 const paragraphOptionsContainer = document.createElement('div');
                 paragraphOptionsContainer.className = 'paragraph-options overflow-y-auto';
                 paragraphList.appendChild(paragraphOptionsContainer);
                 
                 // 添加各段落选项
                 selectedPassage.paragraphs.forEach((paragraph, index) => {
                     const paragraphOption = document.createElement('div');
                     paragraphOption.className = 'flex items-center mb-2';
                     paragraphOption.innerHTML = `
                         <input type="checkbox" id="paragraph-${index+1}" class="mr-2 h-4 w-4 text-primary paragraph-checkbox" data-index="${index}" checked>
                         <label for="paragraph-${index+1}" class="text-gray-700 dark:text-gray-300 cursor-pointer flex-1">
                             <span class="font-medium">第${index+1}段：</span>
                             <span class="text-sm">${paragraph.substring(0, 20)}${paragraph.length > 20 ? '...' : ''}</span>
                         </label>
                     `;
                     paragraphOptionsContainer.appendChild(paragraphOption);
                     
                     // 段落复选框逻辑
                     const checkbox = paragraphOption.querySelector('input');
                     if (checkbox) {
                         checkbox.addEventListener('change', function() {
                             // 检查是否所有段落都被选中
                             const paragraphCheckboxes = paragraphOptionsContainer.querySelectorAll('.paragraph-checkbox');
                             const allCheckbox = document.getElementById('paragraph-all');
                             
                             if (allCheckbox && paragraphCheckboxes) {
                                 const allChecked = Array.from(paragraphCheckboxes).every(cb => cb.checked);
                                 allCheckbox.checked = allChecked;
                             }
                         });
                     }
                 });
                 
                 // 显示段落选择器
                 // 先置頂，避免顯示延遲
                 paragraphSelector.style.cssText = 'transform: translateY(-20px); opacity: 0;';
                 paragraphSelector.classList.remove('hidden');
                 
                 // 強制觸發重繪
                 void paragraphSelector.offsetWidth;
                 
                 // 應用動畫 - 較長的過渡時間提供更流暢的體驗
                 paragraphSelector.style.transition = 'transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s ease-out';
                 paragraphSelector.style.transform = 'translateY(0)';
                 paragraphSelector.style.opacity = '1';
                 
                 // 設置段落列表的滾動屬性
                 if (paragraphOptionsContainer) {
                     // 根據段落數量動態調整高度，增加每段高度並提高最小值
                     const paragraphCount = selectedPassage.paragraphs.length;
                     // 每段約70px高，最少200px，最多視口高度的50%
                     const calculatedHeight = Math.min(
                         Math.max(200, paragraphCount * 70),
                         window.innerHeight * 0.5
                     );
                     paragraphOptionsContainer.style.maxHeight = calculatedHeight + 'px';
                     paragraphOptionsContainer.style.overflowY = 'auto';
                 }
                 
                 // 確保容器高度足夠 - 使用動態計算的高度
                 if (passageContainer) {
                     // 計算當前所有內容的實際高度，包括段落選擇器和確認按鈕
                     const paragraphSelectorHeight = paragraphSelector.scrollHeight;
                     const passageContentHeight = document.getElementById('passage-content').scrollHeight;
                     // 增加額外空間，確保容器高度充足
                     const totalHeight = Math.max(600, passageContentHeight + 50);
                     passageContainer.style.maxHeight = totalHeight + 'px';
                     passageContainer.style.transition = 'max-height 0.3s ease';
                 }
                 
                 // 重新绑定确认按钮事件
                 setupConfirmButton();
             }
             
             // 設置確認按鈕事件
             function setupConfirmButton() {
                 const confirmBtn = document.getElementById('confirm-paragraphs');
                 if (!confirmBtn) {
                     console.error("確認按鈕元素未找到");
                     return;
                 }
                 
                 // 移除現有的事件監聽器
                 const newConfirmBtn = confirmBtn.cloneNode(true);
                 confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
                 
                 // 添加新的事件監聽器 - 改為異步函數以支持等待水墨過渡動畫
                 newConfirmBtn.addEventListener('click', async function() {
                     console.log("確認按鈕被點擊");
                     
                     const paragraphList = document.getElementById('paragraph-list');
                     if (!paragraphList) {
                         console.error("段落列表元素未找到");
                         return;
                     }
                     
                     // 获取选中的段落索引
                     const selectedIndices = [];
                     const paragraphOptions = paragraphList.querySelector('.paragraph-options');
                     if (!paragraphOptions) {
                         console.error("段落選項容器未找到");
                         return;
                     }
                     
                     const checkboxes = paragraphOptions.querySelectorAll('.paragraph-checkbox');
                     
                     checkboxes.forEach(checkbox => {
                         if (checkbox.checked) {
                             selectedIndices.push(parseInt(checkbox.dataset.index));
                         }
                     });
                     
                     // 如果没有选中任何段落，默认选中全部
                     if (selectedIndices.length === 0) {
                         if (passages[currentPassageKey]) {
                             for (let i = 0; i < passages[currentPassageKey].paragraphs.length; i++) {
                                 selectedIndices.push(i);
                             }
                         }
                     }
                     
                     console.log("選中的段落索引:", selectedIndices);
                     
                     // 关闭选择器
                     if (passageContent) {
                         passageContent.classList.add('hidden');
                     }
                     if (passageToggle) {
                         passageToggle.style.transform = 'rotate(0deg)';
                     }
                     if (passageContainer) {
                         passageContainer.style.maxHeight = '46px';
                     }
                     
                     try {
                         // 顯示水墨過渡動畫 - 等待動畫完成後再進入遊戲界面
                         console.log("開始播放水墨過渡動畫");
                         await showLoadingAnimation();
                         console.log("水墨過渡動畫播放完成");
                         
                         // 載入選中的段落 (第三個參數設為true，表示顯示遊戲界面)
                         loadSelectedParagraphs(currentPassageKey, selectedIndices, true);
                         
                         // 確保顯示返回主頁按鈕而非暫停按鈕
                         const pauseBtn = document.getElementById('pause-btn');
                         const returnHomeBtn = document.getElementById('return-home-btn-game');
                         
                         if (pauseBtn && returnHomeBtn) {
                             pauseBtn.classList.add('hidden');
                             returnHomeBtn.classList.remove('hidden');
                             console.log("確認按鈕：已切換為返回主頁按鈕");
                         }
                         
                         // 隱藏用戶資料界面 - 使用強制多層隱藏
                         const userProfileContainer = document.getElementById('user-profile-container');
                         if (userProfileContainer) {
                             // 強制徹底隱藏用戶資料表 - 使用多重方式確保隱藏
                             userProfileContainer.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important;';
                             userProfileContainer.classList.add('hidden');
                             
                             // 移除任何可能顯示用戶資料表的類名
                             userProfileContainer.classList.remove('block', 'flex', 'visible', 'opacity-100');
                             
                             console.log("用戶資料表已被強制隱藏");
                         }
                     } catch (error) {
                         console.error("過渡到遊戲界面時發生錯誤:", error);
                         alert("載入遊戲時發生錯誤，請重試");
                     }
                 });
             }
             
             // 用于存储已回答的字符
             let lastAnsweredChars = [];
             const MAX_DISPLAYED_CHARS = 15;
             
             // 成功背誦50字恢復1點生命值的計數器
             let successfulChars = 0;
             
             // 遊戲當前使用的內容
             let content = '';
             let totalNonPunctChars = 0;
             
             // 創建查看完整文章的功能
             const fullTextModal = document.createElement('div');
             fullTextModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden';
             fullTextModal.id = 'full-text-modal';
             document.body.appendChild(fullTextModal);
             
             // 加載選中段落的函數，不使用水墨過渡動畫
             async function loadSelectedParagraphs(passageKey, paragraphIndices) {
                 console.log("開始加載段落:", passageKey, paragraphIndices);
                 
                 try {
                     // 保存選擇的段落索引到全局變量，供分享使用
                     window.selectedParagraphIndices = paragraphIndices;
                     console.log("已保存段落索引:", window.selectedParagraphIndices);
                     
                     // 確保遊戲頁面存在
                     const gamePage = document.getElementById('game-page');
                     if (!gamePage) {
                         console.error("遊戲頁面元素未找到");
                         return;
                     }
                     
                     // 重置游戏状态
                     currentPosition = 0;
                     correctAnswers = 0;
                     wrongAnswersCount = 0; // 重置錯誤計數
                     lives = 3;
                     updateLives();
                     
                     // 清空已回答的字符
                     successfulChars = 0;
                     const lastAnsweredCharsElem = document.getElementById('last-answered-chars');
                     if (lastAnsweredCharsElem) {
                         lastAnsweredChars = [];
                         lastAnsweredCharsElem.textContent = '';
                     }
                     
                     const completedText = document.getElementById('completed-text');
                     if (completedText) {
                         completedText.textContent = '';
                     }
                     
                     // 獲取選擇的篇章
                     const selectedPassage = passages[passageKey];
                     if (!selectedPassage) {
                         console.error("選中的篇章不存在:", passageKey);
                         return;
                     }
                     
                     // 根据选择的段落索引构建内容
                     content = '';
                     paragraphIndices.sort((a, b) => a - b); // 确保段落按顺序排列
                     
                     paragraphIndices.forEach(index => {
                         if (index >= 0 && index < selectedPassage.paragraphs.length) {
                             content += selectedPassage.paragraphs[index];
                         }
                     });
                     
                     // 計算非標點符號的字符數量
                     totalNonPunctChars = 0;
                     for (let i = 0; i < content.length; i++) {
                         if (!isPunctuation(content[i])) {
                             totalNonPunctChars++;
                         }
                     }
                     
                     console.log("字數計算完成，總非標點字符數：", totalNonPunctChars);
                     
                     // 构建标题（添加所选段落信息）
                     const passageTitle = document.getElementById('passage-title');
                     const passageAuthor = document.getElementById('passage-author');
                     
                     if (passageTitle) {
                         if (paragraphIndices.length === selectedPassage.paragraphs.length) {
                             // 如果選擇了所有段落，只顯示標題
                             passageTitle.textContent = selectedPassage.title;
                         } else {
                             // 如果選擇了部分段落，顯示段落範圍
                             let rangeText = '';
                             if (paragraphIndices.length === 1) {
                                 rangeText = `第${paragraphIndices[0] + 1}段`;
                             } else {
                                 // 判断是否是连续的段落
                                 let isConsecutive = true;
                                 for (let i = 0; i < paragraphIndices.length - 1; i++) {
                                     if (paragraphIndices[i + 1] !== paragraphIndices[i] + 1) {
                                         isConsecutive = false;
                                         break;
                                     }
                                 }
                                 
                                 if (isConsecutive) {
                                     rangeText = `第${paragraphIndices[0] + 1}-${paragraphIndices[paragraphIndices.length - 1] + 1}段`;
                                 } else {
                                     rangeText = `第${paragraphIndices.map(idx => idx + 1).join('、')}段`;
                                 }
                             }
                             passageTitle.textContent = `${selectedPassage.title}（${rangeText}）`;
                         }
                     }
                     
                     if (passageAuthor) {
                         passageAuthor.textContent = selectedPassage.author;
                     }
                     
                     // 停止秒表并重置
                     stopStopwatch();
                     if (timerElement) {
                         timerElement.textContent = "00:00.0";
                     }
                     // 確保恢復秒表時重新開始計時
                     elapsedTimeBeforePause = 0;
                     
                     // 更新進度顯示 - 使用選中段落的總字數
                     const totalCharsElement = document.getElementById('total-chars');
                     const progressTextElement = document.getElementById('progress-text');
                     const progressBarElement = document.getElementById('progress-bar');
                     
                     if (totalCharsElement) {
                         totalCharsElement.textContent = totalNonPunctChars;
                     }
                     
                     if (progressTextElement) {
                         progressTextElement.textContent = `0 / ${totalNonPunctChars}`;
                     }
                     
                     if (progressBarElement) {
                         progressBarElement.style.width = '0%';
                     }
                     
                     // 清空选项容器
                     const optionsContainer = document.getElementById('options-container');
                     if (optionsContainer) {
                         optionsContainer.innerHTML = '';
                         optionsContainer.className = 'grid grid-cols-3 gap-3 md:gap-4 mb-4';
                     }
                     
                     // 確保游戏开始界面準備好
                     if (gameContent) {
                         gameContent.classList.add('hidden');
                     }
                     
                     if (gameStartScreen) {
                         gameStartScreen.classList.remove('hidden');
                     }
                     
                     // 重置暫停狀態
                     isPaused = false;
                     hasPaused = false; // 重置是否使用過暫停的標記
                     
                     // 明確更新按鈕狀態為「未開始」，顯示返回主頁按鈕
                     updateGameControlButtons('not-started');
                     
                     // 直接處理暫停/返回按鈕的顯示
                     const pauseBtn = document.getElementById('pause-btn');
                     const returnHomeBtn = document.getElementById('return-home-btn-game');
                     
                     if (pauseBtn && returnHomeBtn) {
                         // 在遊戲未開始時顯示返回主頁按鈕
                         pauseBtn.classList.add('hidden');
                         returnHomeBtn.classList.remove('hidden');
                         console.log("已切換為返回主頁按鈕 (加載段落)");
                     }
                     
                     // 只有當用戶通過選擇篇章明確調用時才顯示遊戲頁面
                     // 如果不是通過初始載入調用，則顯示遊戲頁面
                     if (arguments.length > 2 && arguments[2] === true) {
                         // 強制徹底顯示遊戲頁面 - 使用多重方式確保顯示
                         console.log("強制顯示遊戲界面");
                         gamePage.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; pointer-events: auto !important;';
                         gamePage.classList.remove('hidden');
                         
                         // 添加顯示類名
                         gamePage.classList.add('block', 'visible', 'opacity-100');
                         
                         // 確保頁面翻轉效果生效
                         const bookPage = document.querySelector('.page');
                         if (bookPage) {
                             bookPage.classList.add('turned');
                         }
                         
                         // 使用延遲檢查遊戲界面狀態
                         setTimeout(() => {
                             console.log("遊戲界面顯示狀態:", window.getComputedStyle(gamePage).display);
                             
                             // 如果遊戲界面仍未顯示，再次嘗試
                             if (window.getComputedStyle(gamePage).display === 'none') {
                                 console.warn("遊戲界面仍未顯示，再次嘗試...");
                                 gamePage.style.cssText = 'display: block !important; visibility: visible !important;';
                             }
                             
                             // 再次確認按鈕顯示狀態
                             if (pauseBtn && returnHomeBtn) {
                                 if (!returnHomeBtn.classList.contains('hidden')) {
                                     console.log("確認返回主頁按鈕顯示正常");
                                 } else {
                                     console.warn("返回主頁按鈕仍然隱藏，重新設置...");
                                     pauseBtn.classList.add('hidden');
                                     returnHomeBtn.classList.remove('hidden');
                                 }
                             }
                             
                             // 再次確認按鈕顯示狀態
                             if (pauseBtn && returnHomeBtn) {
                                 if (!returnHomeBtn.classList.contains('hidden')) {
                                     console.log("確認返回主頁按鈕顯示正常");
                                 } else {
                                     console.warn("返回主頁按鈕仍然隱藏，重新設置...");
                                     pauseBtn.classList.add('hidden');
                                     returnHomeBtn.classList.remove('hidden');
                                 }
                             }
                         }, 50);
                         
                         // 同時強制隱藏用戶資料容器
                         const userProfileContainer = document.getElementById('user-profile-container');
                         if (userProfileContainer) {
                             userProfileContainer.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important;';
                             userProfileContainer.classList.add('hidden');
                             userProfileContainer.classList.remove('block', 'flex', 'visible', 'opacity-100');
                         }
                     } else {
                         // 確保遊戲頁面隱藏
                         gamePage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important;';
                         gamePage.classList.add('hidden');
                         gamePage.classList.remove('block', 'flex', 'visible', 'opacity-100');
                     }
                     
                     console.log("段落加載完成，遊戲準備就緒");
                     
                 } catch (error) {
                     console.error("加載段落時發生錯誤:", error);
                 }
             }
             
             let currentPosition = 0;
             let correctAnswers = 0;
             let canSelect = true;
             let lives = 3;
             
             const completedText = document.getElementById('completed-text');
             const currentChar = document.getElementById('current-char');
             const optionsContainer = document.getElementById('options-container');
             const feedback = document.getElementById('feedback');
             const helpBtn = document.getElementById('help-btn');
             const helpText = document.getElementById('help-text');
             
             // 秒表功能 - 修改為支持暫停/繼續
             function startStopwatch() {
                 if (isPaused) return; // 如果遊戲已暫停，不啟動計時器
                 
                 // 設置開始時間 - 考慮先前累積的時間
                 startTime = new Date();
                 
                 // 啟動計時器
                 timerInterval = setInterval(updateStopwatch, 100);
                 
                 // 遊戲開始後，顯示暫停按鈕而非返回主頁按鈕
                 updateGameControlButtons('playing');
             }
             
             // 更新暫停/返回主頁按鈕顯示狀態
             function updateGameControlButtons(gameState) {
                 const pauseBtn = document.getElementById('pause-btn');
                 const returnHomeBtn = document.getElementById('return-home-btn-game');
                 
                 if (!pauseBtn || !returnHomeBtn) return;
                 
                 if (gameState === 'not-started' || gameState === 'completed' || gameState === 'failed') {
                     // 遊戲開始前、完成後或失敗後，顯示返回主頁按鈕
                     pauseBtn.classList.add('hidden');
                     returnHomeBtn.classList.remove('hidden');
                 } else if (gameState === 'playing') {
                     // 遊戲進行中，顯示暫停按鈕
                     pauseBtn.classList.remove('hidden');
                     returnHomeBtn.classList.add('hidden');
                 }
             }
             
             function stopStopwatch() {
                 // 如果計時器正在運行，停止並保存累計時間
                 if (timerInterval) {
                     clearInterval(timerInterval);
                     timerInterval = null;
                     
                     // 如果是暫停操作（而非遊戲結束等其他原因停止），更新累計時間
                     if (startTime && isPaused) {
                         const currentTime = new Date();
                         elapsedTimeBeforePause += (currentTime - startTime);
                         startTime = null; // 清除開始時間
                     }
                 }
             }
             
             function resetStopwatch() {
                 stopStopwatch();
                 elapsedTimeBeforePause = 0; // 重置累計時間
                 
                 if (timerElement) {
                     timerElement.textContent = "00:00.0";
                 }
                 
                 // 重新開始秒錶
                 startStopwatch();
             }
             
             function updateStopwatch() {
                 if (!timerElement || isPaused) return;
                 
                 const currentTime = new Date();
                 // 計算總經過時間 = 之前累計的時間 + 當前計時段的時間
                 const totalElapsedMs = elapsedTimeBeforePause + (currentTime - startTime);
                 
                 // 轉換為時間格式
                 const totalElapsedDate = new Date(totalElapsedMs);
                 const minutes = String(totalElapsedDate.getUTCMinutes()).padStart(2, '0');
                 const seconds = String(totalElapsedDate.getUTCSeconds()).padStart(2, '0');
                 const tenths = Math.floor(totalElapsedDate.getUTCMilliseconds() / 100);
                 
                 timerElement.textContent = `${minutes}:${seconds}.${tenths}`;
             }
             
             // 获取完成时间（以秒为单位）
             function getCompletionTimeInSeconds() {
                 if (!timerElement) return 0;
                 
                 const timeString = timerElement.textContent;
                 const parts = timeString.split(':');
                 const minutePart = parseInt(parts[0]);
                 const secondParts = parts[1].split('.');
                 const secondPart = parseInt(secondParts[0]);
                 const tenthPart = parseInt(secondParts[1]) / 10;
                 
                 // 返回总秒数（包括小数部分）
                 return minutePart * 60 + secondPart + tenthPart;
             }
             
             // 初始显示，先不启动秒表
             if (timerElement) timerElement.textContent = "00:00.0";
             
             // 帮助按钮 - 添加自動滾動功能
             if (helpBtn && helpText) {
                 helpBtn.addEventListener('click', function() {
                     helpText.classList.toggle('hidden');
                     
                     // 如果幫助文本顯示，滾動頁面使其完全可見
                     if (!helpText.classList.contains('hidden')) {
                         setTimeout(() => {
                             helpText.scrollIntoView({ behavior: 'smooth', block: 'center' });
                         }, 100);
                     }
                 });
             }
             
             // 初始化暫停功能
             function initializePauseSystem() {
                 const pauseBtn = document.getElementById('pause-btn');
                 const pauseOverlay = document.getElementById('pause-overlay');
                 const continueBtn = document.getElementById('continue-btn');
                 const restartFromPauseBtn = document.getElementById('restart-from-pause-btn');
                 const countdownResume = document.getElementById('countdown-resume');
                 const pauseButtons = document.getElementById('pause-buttons');
                 
                 if (!pauseBtn || !pauseOverlay || !continueBtn || !restartFromPauseBtn || !countdownResume) {
                     console.error("暫停系統元素未找到");
                     return;
                 }
                 
                 // 暫停按鈕點擊事件
                 pauseBtn.addEventListener('click', function() {
                     // 只有在遊戲進行中且未暫停時才能暫停
                     if (gameStartScreen.classList.contains('hidden') && gameContent.classList.contains('hidden') === false && !isPaused) {
                         pauseGame();
                     }
                 });
                 
                 // 繼續遊戲按鈕
                 continueBtn.addEventListener('click', function() {
                     // 隱藏按鈕，顯示倒計時
                     pauseButtons.classList.add('hidden');
                     countdownResume.classList.remove('hidden');
                     
                     let count = 3;
                     const countdownNumber = countdownResume.querySelector('.pause-countdown-number');
                     countdownNumber.textContent = count;
                     
                     // 清除可能存在的倒計時
                     if (resumeCountdown) {
                         clearInterval(resumeCountdown);
                     }
                     
                     // 開始新的倒計時
                     resumeCountdown = setInterval(function() {
                         count--;
                         countdownNumber.textContent = count;
                         countdownNumber.style.animation = 'none';
                         void countdownNumber.offsetWidth; // 重置動畫
                         countdownNumber.style.animation = 'countdownPulse 1s ease-out';
                         
                         if (count <= 0) {
                             clearInterval(resumeCountdown);
                             resumeCountdown = null;
                             
                             // 恢復遊戲
                             resumeGame();
                             
                             // 重置界面
                             pauseButtons.classList.remove('hidden');
                             countdownResume.classList.add('hidden');
                         }
                     }, 1000);
                 });
                 
                 // 重新開始按鈕
                 restartFromPauseBtn.addEventListener('click', async function() {
                     // 先關閉暫停菜單
                     pauseOverlay.classList.add('hidden');
                     isPaused = false;
                     
                     // 清除倒計時
                     if (resumeCountdown) {
                         clearInterval(resumeCountdown);
                         resumeCountdown = null;
                     }
                     
                     // 重置界面
                     pauseButtons.classList.remove('hidden');
                     countdownResume.classList.add('hidden');
                     
                     // 執行重新開始
                     await restartGame();
                     
                     // 關鍵修復：確保顯示"返回主頁"按鈕而非暫停按鈕
                     updateGameControlButtons('not-started');
                     console.log("重新開始：已更新按鈕顯示狀態為'未開始'");
                     
                     // 關鍵修復：重新啟用設置齒輪按鈕
                     window.enableSettingsButton();
                     console.log("重新開始：已重新啟用設置齒輪按鈕");
                 });
                 
                 // 返回主頁按鈕
                 const returnHomeBtn = document.getElementById('return-home-btn');
                 if (returnHomeBtn) {
                     returnHomeBtn.addEventListener('click', async function() {
                         console.log("暫停界面的返回主頁按鈕被點擊");
                         
                         try {
                             // 先關閉暫停菜單，避免重複顯示
                             pauseOverlay.classList.add('hidden');
                             isPaused = false;
                             
                             // 清除倒計時
                             if (resumeCountdown) {
                                 clearInterval(resumeCountdown);
                                 resumeCountdown = null;
                             }
                             
                             // 重置界面
                             pauseButtons.classList.remove('hidden');
                             countdownResume.classList.add('hidden');
                             
                             // 顯示水墨過渡動畫
                             await showLoadingAnimation();
                             console.log("水墨過渡動畫播放完成");
                             
                             // 重置遊戲狀態
                             currentPosition = 0;
                             correctAnswers = 0;
                             lives = 3;
                             successfulChars = 0;
                             wrongAnswersCount = 0;
                             lastAnsweredChars = [];
                             
                             const lastAnsweredCharsElem = document.getElementById('last-answered-chars');
                             if (lastAnsweredCharsElem) {
                                 lastAnsweredCharsElem.textContent = '';
                             }
                             
                             canSelect = true;
                             isPaused = false;
                             hasPaused = false;
                             updateLives();
                             
                             if (feedback) {
                                 feedback.textContent = '';
                             }
                             
                             // 停止計時器
                             stopStopwatch();
                             elapsedTimeBeforePause = 0;
                             if (timerElement) {
                                 timerElement.textContent = "00:00.0";
                             }
                             
                             // 更新進度條
                             const progressText = document.getElementById('progress-text');
                             const progressBar = document.getElementById('progress-bar');
                             
                             if (progressText) {
                                 progressText.textContent = `0 / ${totalNonPunctChars}`;
                             }
                             
                             if (progressBar) {
                                 progressBar.style.width = '0%';
                             }
                             
                             // 獲取需要操作的元素
                             const userProfileContainer = document.getElementById('user-profile-container');
                             const gamePage = document.getElementById('game-page');
                             
                             // 隱藏遊戲界面
                             gamePage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
                             gamePage.classList.add('hidden');
                             gamePage.classList.remove('block', 'flex', 'visible', 'opacity-100');
                             
                             // 顯示用戶資料界面
                             userProfileContainer.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                             userProfileContainer.classList.remove('hidden');
                             userProfileContainer.classList.add('block');
                             
                             // 確保書本頁面回到初始狀態
                             const bookPage = document.querySelector('.page');
                             if (bookPage && bookPage.classList.contains('turned')) {
                                 bookPage.classList.remove('turned');
                             }
                             
                             // 滾動到頁面頂部
                             window.scrollTo({
                                 top: 0,
                                 behavior: 'smooth'
                             });
                             
                             // 清空選項並恢復原始的網格佈局
                             if (optionsContainer) {
                                 optionsContainer.innerHTML = '';
                                 optionsContainer.className = 'grid grid-cols-3 gap-3 md:gap-4 mb-4';
                             }
                             
                             // 關鍵修復：重新啟用設置按鈕，因為用戶已返回主頁
                             window.enableSettingsButton();
                             console.log("重新啟用設置按鈕");
                             
                             console.log("從暫停菜單返回主頁成功");
                         } catch (error) {
                             console.error("返回主頁按鈕處理發生錯誤:", error);
                             alert("返回主頁時發生錯誤，請重新載入頁面");
                             // 即使發生錯誤，仍嘗試啟用設置按鈕
                             try {
                                 window.enableSettingsButton();
                             } catch (e) {
                                 console.error("啟用設置按鈕時發生錯誤:", e);
                             }
                         }
                     });
                 } else {
                     console.error("返回主頁按鈕元素未找到");
                 }
                 
                 // 鍵盤事件
                 document.addEventListener('keydown', function(e) {
                     // 按下 ESC 鍵暫停/繼續
                     if (e.key === 'Escape') {
                         if (gameStartScreen.classList.contains('hidden') && gameContent.classList.contains('hidden') === false) {
                             if (isPaused) {
                                 continueBtn.click();
                             } else {
                                 pauseBtn.click();
                             }
                         }
                     }
                 });
             }
             
             // 暫停遊戲
             function pauseGame() {
                 if (isPaused) return; // 防止重複暫停
                 
                 isPaused = true;
                 hasPaused = true; // 標記用戶使用了暫停功能
                 
                 // 暫停計時器 - 保存當前累計時間
                 stopStopwatch();
                 
                 // 禁止選擇選項
                 canSelect = false;
                 
                 // 禁用設置按鈕
                 window.disableSettingsButton();
                 
                 // 顯示暫停覆蓋層
                 const pauseOverlay = document.getElementById('pause-overlay');
                 if (pauseOverlay) {
                     pauseOverlay.classList.remove('hidden');
                 }
                 
                 console.log("遊戲已暫停");
             }
             
             // 恢復遊戲
             function resumeGame() {
                 if (!isPaused) return; // 防止非暫停狀態下恢復
                 
                 isPaused = false;
                 
                 // 隱藏暫停覆蓋層
                 const pauseOverlay = document.getElementById('pause-overlay');
                 if (pauseOverlay) {
                     pauseOverlay.classList.add('hidden');
                 }
                 
                 // 恢復計時器 - 從之前的累計時間繼續
                 startStopwatch();
                 
                 // 允許選擇選項
                 canSelect = true;
                 
                 // 重新啟用設置按鈕
                 window.enableSettingsButton();
                 
                 console.log("遊戲已恢復，累計時間: " + elapsedTimeBeforePause + "ms");
             }
             
             // 重新開始遊戲
             async function restartGame() {
                 // 先顯示載入動畫
                 await showLoadingAnimation();
                 
                 // 重置遊戲狀態
                 currentPosition = 0;
                 correctAnswers = 0;
                 wrongAnswersCount = 0;
                 lives = 3;
                 successfulChars = 0;
                 lastAnsweredChars = [];
                 
                 // 重置UI元素
                 const lastAnsweredCharsElem = document.getElementById('last-answered-chars');
                 if (lastAnsweredCharsElem) {
                     lastAnsweredCharsElem.textContent = '';
                 }
                 
                 updateLives();
                 
                 if (completedText) {
                     completedText.textContent = '';
                 }
                 
                 if (feedback) {
                     feedback.textContent = '';
                     feedback.className = 'mt-4 text-center h-6 text-lg';
                 }
                 
                 // 更新進度條
                 const progressText = document.getElementById('progress-text');
                 const progressBar = document.getElementById('progress-bar');
                 
                 if (progressText) {
                     progressText.textContent = `0 / ${totalNonPunctChars}`;
                 }
                 
                 if (progressBar) {
                     progressBar.style.width = '0%';
                 }
                 
                 // 重置遊戲狀態
                 canSelect = true;
                 isPaused = false;
                 hasPaused = false; // 重置暫停標記
                 
                 // 重置秒表
                 stopStopwatch();
                 elapsedTimeBeforePause = 0; // 重置累計時間
                 if (timerElement) {
                     timerElement.textContent = "00:00.0";
                 }
                 
                 // 顯示開始屏幕
                 if (gameContent && gameStartScreen) {
                     gameContent.classList.add('hidden');
                     gameStartScreen.classList.remove('hidden');
                 }
                 
                 // 清空選項並恢復原始的網格佈局
                 if (optionsContainer) {
                     optionsContainer.innerHTML = '';
                     optionsContainer.className = 'grid grid-cols-3 gap-3 md:gap-4 mb-4';
                 }
                 
                 // 確保選擇篇章界面關閉
                 if (passageContent && passageToggle && passageContainer) {
                     passageContent.classList.add('hidden');
                     passageToggle.style.transform = 'rotate(0deg)';
                     passageContainer.style.maxHeight = '46px';
                 }
                 
                 console.log("遊戲已重新開始");
             }
             
             // 創建查看完整文章功能
             const viewFullTextBtn = document.getElementById('view-full-text-btn');
             if (viewFullTextBtn) {
                 viewFullTextBtn.addEventListener('click', function() {
                     if (!currentPassageKey) {
                         alert('請先選擇一篇文章');
                         return;
                     }
                     
                     // 獲取當前文章完整內容
                     const passage = passages[currentPassageKey];
                     if (!passage) return;
                     
                     // 將段落轉換為HTML格式，使用網格佈局顯示段落編號和內容
                     const formattedParagraphs = passage.paragraphs.map((paragraph, index) => {
                         return `
                         <div class="grid grid-cols-[auto,1px,1fr] gap-3 mb-5">
                             <div class="text-amber-700 dark:text-amber-400 font-medium whitespace-nowrap py-1">第${index + 1}段</div>
                             <div class="bg-gray-300 dark:bg-gray-600 w-px"></div>
                             <div class="text-gray-700 dark:text-gray-300 py-1 text-lg">${paragraph}</div>
                         </div>`;
                     }).join('');
                     
                     // 創建模態框內容
                     fullTextModal.innerHTML = `
                     <div class="bg-white dark:bg-gray-800 p-6 rounded-lg max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                         <div class="flex justify-between items-center mb-4">
                             <h3 class="text-lg font-bold text-gray-800 dark:text-gray-100">${passage.title}</h3>
                             <button id="close-modal-btn" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-gray-100">
                                 <i class="fas fa-times"></i>
                             </button>
                         </div>
                         <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">${passage.author}</p>
                         <div class="bg-gray-50 dark:bg-gray-700/30 p-4 rounded-lg">
                             ${formattedParagraphs}
                         </div>
                     </div>
                     `;
                     
                     // 顯示模態框
                     fullTextModal.classList.remove('hidden');
                     
                     // 關閉按鈕事件
                     document.getElementById('close-modal-btn').addEventListener('click', function() {
                         fullTextModal.classList.add('hidden');
                     });
                     
                     // 點擊背景關閉模態框
                     fullTextModal.addEventListener('click', function(e) {
                         if (e.target === fullTextModal) {
                             fullTextModal.classList.add('hidden');
                         }
                     });
                 });
             }
             
             // 獲取並存儲進度相關的DOM元素
             const progressTextElement = document.getElementById('progress-text');
             const totalCharsElement = document.getElementById('total-chars');
             const progressBarElement = document.getElementById('progress-bar');
             
             function updateDisplay() {
                 // 檢查當前位置字符是否是標點，如果是則跳過
                 while (currentPosition < content.length && isPunctuation(content[currentPosition])) {
                     currentPosition++;
                 }
                 
                 // 確保當前字符元素存在
                 if (!currentChar) {
                     console.error('currentChar element is missing');
                     return;
                 }
                 
                 // 更新顯示，不再預先顯示當前字符
                 if (currentPosition < content.length) {
                     // 清空當前字符顯示區
                     currentChar.textContent = '';
                     
                     // 直接為當前位置生成選項
                     generateOptions(currentPosition);
                 } else {
                     // 完成所有字符
                     completePassage();
                 }
                 
                 // 更新進度顯示
                 updateProgressUI();
             }
             
             // 抽取進度更新為獨立函數
             function updateProgressUI() {
                 // 計算並顯示非標點字符的進度
                 let nonPunctChars = 0;
                 for (let i = 0; i < currentPosition; i++) {
                     if (!isPunctuation(content[i])) {
                         nonPunctChars++;
                     }
                 }
                 
                 // 確保進度條相關元素存在
                 try {
                     // 更新進度條 - 使用選中段落的總字數
                     if (totalCharsElement) totalCharsElement.textContent = totalNonPunctChars;
                     if (progressTextElement) progressTextElement.textContent = `${nonPunctChars} / ${totalNonPunctChars}`;
                     const progressPercentage = (totalNonPunctChars > 0) ? (nonPunctChars / totalNonPunctChars * 100) : 0;
                     if (progressBarElement) progressBarElement.style.width = `${progressPercentage}%`;
                 } catch (e) {
                     console.error('Error updating progress UI:', e);
                 }
             }
             
             function generateOptions(pos) {
                 if (!optionsContainer) {
                     console.error("選項容器元素未找到");
                     return;
                 }
                 
                 // 确保 pos 不是标点符号
                 while (pos < content.length && isPunctuation(content[pos])) {
                     pos++;
                 }
                 
                 // 清空选项容器
                 optionsContainer.innerHTML = '';
                 
                 // 正确答案
                 const correctAnswer = content[pos];
                 
                 // 生成两个干扰选项
                 let options = [correctAnswer];
                 
                 while (options.length < 3) {
                     const randomIndex = Math.floor(Math.random() * content.length);
                     const randomChar = content[randomIndex];
                     
                     // 确保不重复且不是标点符号
                     if (!options.includes(randomChar) && 
                         !isPunctuation(randomChar) && 
                         randomChar !== correctAnswer) {
                         options.push(randomChar);
                     }
                 }
                 
                 // 打乱选项顺序
                 options = shuffleArray(options);
                 
                 // 创建选项按钮
                 options.forEach(option => {
                     const btn = document.createElement('button');
                     btn.className = 'option-btn h-16 md:h-20 text-2xl md:text-3xl bg-white dark:bg-gray-700 rounded-lg border border-gray-300 dark:border-gray-600 text-gray-800 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none';
                     btn.textContent = option;
                     
                     btn.addEventListener('click', function() {
                         if (!canSelect || isPaused) return; // 如果已暫停，不允許選擇
                         
                         if (option === correctAnswer) {
                             // 只在正確答案時創建墨滴效果
                             createInkDrop(btn);
                             handleCorrectAnswer(btn);
                         } else {
                             // 錯誤時不創建墨滴
                             handleIncorrectAnswer(btn);
                         }
                     });
                     
                     optionsContainer.appendChild(btn);
                 });
             }
             
             function handleCorrectAnswer(btn) {
                 canSelect = false;
                 correctAnswers++;
                 
                 // 添加正确效果
                 btn.classList.add('correct');
                 
                 // 不再顯示反饋文字
                 if (feedback) {
                     feedback.textContent = '';
                     feedback.className = 'mt-0 text-center h-0 text-lg';
                 }
                 
                 // 添加当前字符到已回答的字符列表
                 lastAnsweredChars.push(content[currentPosition]);
                 
                 // 保存当前位置
                 const savedPosition = currentPosition;
                 
                 // 检查并添加后续标点符号
                 currentPosition++;
                 while (currentPosition < content.length && isPunctuation(content[currentPosition])) {
                     // 将标点符号也添加到已回答列表
                     lastAnsweredChars.push(content[currentPosition]);
                     currentPosition++;
                 }
                 
                 // 如果超出最大显示字数限制，移除最早的字符
                 while (lastAnsweredChars.length > MAX_DISPLAYED_CHARS) {
                     lastAnsweredChars.shift();
                 }
                 
                 // 更新已回答字符显示
                 const lastAnsweredCharsElem = document.getElementById('last-answered-chars');
                 if (lastAnsweredCharsElem) {
                     // 构建HTML内容，最后一个非标点符号字符使用特殊样式
                     if (lastAnsweredChars.length > 0) {
                         let htmlContent = '';
                         
                         // 找出最后一个非标点符号字符的索引
                         let lastNonPunctIndex = -1;
                         for (let i = lastAnsweredChars.length - 1; i >= 0; i--) {
                             if (!isPunctuation(lastAnsweredChars[i])) {
                                 lastNonPunctIndex = i;
                                 break;
                             }
                         }
                         
                         // 构建HTML内容
                         for (let i = 0; i < lastAnsweredChars.length; i++) {
                             // 如果是最后一个非标点符号字符，加粗放大
                             if (i === lastNonPunctIndex) {
                                 htmlContent += `<span class="text-2xl md:text-3xl font-bold">${lastAnsweredChars[i]}</span>`;
                             } else {
                                 htmlContent += lastAnsweredChars[i];
                             }
                         }
                         
                         lastAnsweredCharsElem.innerHTML = htmlContent;
                     } else {
                         lastAnsweredCharsElem.innerHTML = '';
                     }
                 }
                 
                 // 增加成功背誦字數計數
                 if (!isPunctuation(content[savedPosition])) {
                     successfulChars++;
                     
                     // 每成功背誦50字，恢復1點生命值（上限為3點）
                     if (successfulChars % 50 === 0 && lives < 3) {
                         lives++;
                         updateLives();
                         
                         // 顯示恢復生命值動畫效果
                         const healEffect = document.createElement('div');
                         healEffect.className = 'fixed inset-0 pointer-events-none z-50 flex items-center justify-center';
                         healEffect.innerHTML = `<div class="bg-green-500 bg-opacity-30 p-4 rounded-full text-white text-2xl font-bold animate-pulse">+1 ❤️</div>`;
                         document.body.appendChild(healEffect);
                         
                         setTimeout(() => {
                             healEffect.remove();
                         }, 1500);
                     }
                 }
                 
                 updateDisplay();
                 canSelect = true;
             }
             
             function handleIncorrectAnswer(btn) {
                 // 添加错误效果
                 btn.classList.add('incorrect');
                 
                 // 扣除生命值
                 lives--;
                 updateLives();
                 
                 // 增加錯誤計數
                 wrongAnswersCount++;
                 
                 // 检查游戏是否结束
                 if (lives <= 0) {
                     gameOver();
                     return;
                 }
                 
                 // 不再顯示反饋文字
                 if (feedback) {
                     feedback.textContent = '';
                     feedback.className = 'mt-0 text-center h-0 text-lg';
                 }
                 
                 // 添加屏幕震动效果
                 document.body.classList.add('screen-shake');
                 setTimeout(() => {
                     document.body.classList.remove('screen-shake');
                 }, 500);
                 
                 // 延迟移除效果
                 setTimeout(() => {
                     btn.classList.remove('incorrect');
                 }, 1000);
             }
             
             function updateLives() {
                 const livesContainer = document.getElementById('lives');
                 if (!livesContainer) return;
                 
                 livesContainer.innerHTML = '';
                 
                 for (let i = 0; i < lives; i++) {
                     const heart = document.createElement('i');
                     heart.className = 'fas fa-heart mx-0.5 animate-pulse';
                     livesContainer.appendChild(heart);
                 }
                 
                 for (let i = 0; i < 3 - lives; i++) {
                     const emptyHeart = document.createElement('i');
                     emptyHeart.className = 'far fa-heart mx-0.5 text-gray-400 dark:text-gray-600';
                     livesContainer.appendChild(emptyHeart);
                 }
             }
             
             function gameOver() {
                 // 停止遊戲
                 canSelect = false;
                 stopStopwatch();
                 
                 // 更新按鈕狀態為「失敗」，顯示返回主頁按鈕
                 updateGameControlButtons('failed');
                 
                 // 隱藏遊戲內容
                 if (gameContent) {
                     gameContent.classList.add('hidden');
                 }
                 
                 // 檢查是否過半後失敗並更新成就
                 const progressBar = document.getElementById('progress-bar');
                 if (progressBar) {
                     const progressWidth = progressBar.style.width || '0%';
                     const progressPercent = parseFloat(progressWidth);
                     
                     // 如果進度超過50%，記錄為過半後失敗
                     if (progressPercent >= 50) {
                         // 增加失敗計數
                         globalStats.failAfterHalfwayCount = (globalStats.failAfterHalfwayCount || 0) + 1;
                         
                         // 更新挫敗之路成就等級
                         const failCount = globalStats.failAfterHalfwayCount;
                         
                         if (failCount >= 100 && globalStats.achievements.defeatLevel < 5) {
                             globalStats.achievements.defeatLevel = 5; // 心如止水 (100次)
                         } else if (failCount >= 50 && globalStats.achievements.defeatLevel < 4) {
                             globalStats.achievements.defeatLevel = 4; // 小強是我 (50次)
                         } else if (failCount >= 30 && globalStats.achievements.defeatLevel < 3) {
                             globalStats.achievements.defeatLevel = 3; // 鋼鐵意志 (30次)
                         } else if (failCount >= 5 && globalStats.achievements.defeatLevel < 2) {
                             globalStats.achievements.defeatLevel = 2; // 堅毅 (5次)
                         } else if (failCount >= 1 && globalStats.achievements.defeatLevel < 1) {
                             globalStats.achievements.defeatLevel = 1; // 初嘗敗績 (1次)
                         }
                         
                         console.log(`過半後失敗，總計: ${failCount}次，成就等級: ${globalStats.achievements.defeatLevel}`);
                         
                         // 保存更新的統計數據
                         saveStats();
                     }
                 }
                 
                 // 計算已完成字符的經驗值獎勵
                 const progressText = document.getElementById('progress-text');
                 if (progressText) {
                     const progressInfo = progressText.textContent.split('/');
                     if (progressInfo.length === 2) {
                         const completedChars = parseInt(progressInfo[0].trim());
                         if (!isNaN(completedChars) && completedChars > 0) {
                             const expGained = completedChars *1.5;
                             addExperience(expGained);
                             console.log(`遊戲失敗，獲得經驗值: ${expGained} (已完成${completedChars}字符)`);
                             
                             // 顯示獲得的經驗值訊息
                             const expNotification = document.createElement('div');
                             expNotification.className = 'fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-amber-100 dark:bg-amber-800 text-amber-900 dark:text-amber-100 py-2 px-4 rounded-lg shadow-lg z-[9999] flex items-center';
                             expNotification.style.animation = 'fadeInOut 3s ease-in-out forwards';
                             expNotification.innerHTML = `
                                 <i class="fas fa-star text-amber-500 dark:text-amber-300 mr-2"></i>
                                 <div>獲得 <span class="font-bold">${expGained}</span> 經驗值</div>
                             `;
                             document.body.appendChild(expNotification);
                             setTimeout(() => {
                                 expNotification.remove();
                             }, 3000);
                         }
                     }
                 }
                 
                 // 清空選項容器
                 if (!optionsContainer) {
                     console.error("選項容器未找到，無法顯示遊戲結束界面");
                     return;
                 }
                 
                 // 重置容器樣式
                 optionsContainer.innerHTML = '';
                 optionsContainer.className = 'flex justify-center items-center mb-4';
                 
                 // 創建遊戲結束視圖的容器
                 const gameOverContainer = document.createElement('div');
                 gameOverContainer.id = 'game-over-container';
                 gameOverContainer.className = 'text-center bg-white dark:bg-gray-700 p-6 rounded-lg shadow-md w-4/5';
                 
                 // 設置結果信息
                 gameOverContainer.innerHTML = `
                     <p class="text-2xl text-red-600 dark:text-red-500 mb-6 font-bold">可惜！</p>
                     <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg mb-5">
                         <p class="text-gray-700 dark:text-gray-300">時間: ${timerElement ? timerElement.textContent : "00:00.0"}</p>
                         <p class="text-gray-700 dark:text-gray-300">錯誤次數: ${wrongAnswersCount}</p>
                     </div>
                     <div id="game-over-buttons" class="flex justify-center gap-6 mt-4">
                         <!-- 按鈕將通過JS動態添加 -->
                     </div>
                 `;
                 
                 // 添加到DOM
                 optionsContainer.appendChild(gameOverContainer);
                 
                 // 創建按鈕
                 const buttonsContainer = document.getElementById('game-over-buttons');
                 
                 // 1. 分享按鈕
                 const shareButton = document.createElement('button');
                 shareButton.id = 'share-failed-btn';
                 shareButton.className = 'w-12 h-12 bg-green-600 text-white rounded-full hover:bg-green-700 transition-colors flex items-center justify-center text-xl';
                 shareButton.innerHTML = '<i class="fas fa-share-alt"></i>';
                 buttonsContainer.appendChild(shareButton);
                 
                 // 2. 重來按鈕
                 const restartButton = document.createElement('button');
                 restartButton.id = 'restart-failed-btn';
                 restartButton.className = 'w-12 h-12 bg-amber-500 text-white rounded-full hover:bg-amber-600 transition-colors flex items-center justify-center text-xl';
                 restartButton.innerHTML = '<i class="fas fa-redo"></i>';
                 buttonsContainer.appendChild(restartButton);
                
                 
                 // 添加震動效果
                 document.body.classList.add('game-over-shake');
                 setTimeout(() => {
                     document.body.classList.remove('game-over-shake');
                 }, 1000);
                 
                 // 定義公共的遊戲重置邏輯
                 function resetGameState() {
                     console.log("重置遊戲狀態");
                     currentPosition = 0;
                     correctAnswers = 0;
                     lives = 3;
                     successfulChars = 0;
                     wrongAnswersCount = 0;
                     lastAnsweredChars = [];
                     
                     const lastAnsweredCharsElem = document.getElementById('last-answered-chars');
                     if (lastAnsweredCharsElem) {
                         lastAnsweredCharsElem.textContent = '';
                     }
                     
                     canSelect = true;
                     isPaused = false;
                     hasPaused = false;
                     updateLives();
                     
                     if (feedback) {
                         feedback.textContent = '';
                     }
                     
                     // 更新進度條
                     const progressText = document.getElementById('progress-text');
                     const progressBar = document.getElementById('progress-bar');
                     
                     if (progressText) {
                         progressText.textContent = `0 / ${totalNonPunctChars}`;
                     }
                     
                     if (progressBar) {
                         progressBar.style.width = '0%';
                     }
                     
                     // 清空選項容器
                     if (optionsContainer) {
                         optionsContainer.innerHTML = '';
                         optionsContainer.className = 'grid grid-cols-3 gap-3 md:gap-4 mb-4';
                     }
                 }
                 
                 // === 直接添加事件處理器 ===
                 
                 // 1. 分享按鈕事件
                 shareButton.onclick = function() {
                     console.log("分享按鈕被點擊");
                     
                     // 顯示加載中動畫
                     const loadingOverlay = document.createElement('div');
                     loadingOverlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[101]';
                     loadingOverlay.innerHTML = `
                         <div class="bg-white dark:bg-gray-800 p-6 rounded-lg flex flex-col items-center">
                             <i class="fas fa-spinner fa-spin text-3xl text-primary mb-3"></i>
                             <p class="text-gray-700 dark:text-gray-300">正在生成分享圖片...</p>
                         </div>
                     `;
                     document.body.appendChild(loadingOverlay);
                     
                     // 獲取段落索引
                     const paragraphInfo = window.selectedParagraphIndices || [];
                     
                     // 創建分享卡片
                     const selectedPassage = passages[currentPassageKey];
                     if (selectedPassage) {
                         createShareCard(
                             selectedPassage.title, 
                             selectedPassage.author, 
                             timerElement ? timerElement.textContent : "00:00.0", 
                             wrongAnswersCount, 
                             totalNonPunctChars, 
                             [], 
                             paragraphInfo
                         ).then(imageData => {
                             document.body.removeChild(loadingOverlay);
                             handleShare(imageData);
                         }).catch(err => {
                             console.error('創建分享卡片失敗:', err);
                             document.body.removeChild(loadingOverlay);
                             alert('生成分享圖片失敗，請稍後再試。');
                         });
                     } else {
                         document.body.removeChild(loadingOverlay);
                         alert('無法獲取當前篇章信息，分享失敗。');
                     }
                 };
                 
                 // 2. 重來按鈕事件 - 修復重新開始功能
                 restartButton.onclick = async function() {
                     console.log("重來按鈕被點擊");
                     
                     try {
                         // 顯示載入動畫
                         await showLoadingAnimation();
                         
                         // 重置遊戲狀態
                         currentPosition = 0;
                         correctAnswers = 0;
                         wrongAnswersCount = 0;
                         lives = 3;
                         successfulChars = 0;
                         lastAnsweredChars = [];
                         
                         // 重置UI元素
                         const lastAnsweredCharsElem = document.getElementById('last-answered-chars');
                         if (lastAnsweredCharsElem) {
                             lastAnsweredCharsElem.textContent = '';
                         }
                         
                         updateLives();
                         
                         if (completedText) {
                             completedText.textContent = '';
                         }
                         
                         if (feedback) {
                             feedback.textContent = '';
                             feedback.className = 'mt-4 text-center h-6 text-lg';
                         }
                         
                         // 更新進度條
                         const progressText = document.getElementById('progress-text');
                         const progressBar = document.getElementById('progress-bar');
                         
                         if (progressText) {
                             progressText.textContent = `0 / ${totalNonPunctChars}`;
                         }
                         
                         if (progressBar) {
                             progressBar.style.width = '0%';
                         }
                         
                         // 重置遊戲狀態
                         canSelect = true;
                         isPaused = false;
                         hasPaused = false; // 重置暫停標記
                         
                         // 重置秒表
                         stopStopwatch();
                         elapsedTimeBeforePause = 0; // 重置累計時間
                         if (timerElement) {
                             timerElement.textContent = "00:00.0";
                         }
                         
                         // 顯示開始屏幕
                         if (gameContent && gameStartScreen) {
                             gameContent.classList.add('hidden');
                             gameStartScreen.classList.remove('hidden');
                         }
                         
                         // 清空選項並恢復原始的網格佈局
                         if (optionsContainer) {
                             optionsContainer.innerHTML = '';
                             optionsContainer.className = 'grid grid-cols-3 gap-3 md:gap-4 mb-4';
                         }
                         
                         console.log("遊戲已重置，返回開始界面");
                     } catch (error) {
                         console.error("重新開始時出錯:", error);
                         alert("重新開始時發生錯誤，請重新載入頁面");
                     }
                 };
                 
                 // 3. 返回按鈕事件 - 徹底重寫，並添加頁面滾動至頂部功能
                 returnButton.onclick = function() {
                     console.log("返回按鈕被點擊");
                     
                     try {
                         // 重置遊戲狀態
                         resetGameState();
                         
                         // 獲取需要操作的元素
                         const userProfileContainer = document.getElementById('user-profile-container');
                         const gamePage = document.getElementById('game-page');
                         
                         // 簡單地檢查元素是否存在
                         if (!userProfileContainer || !gamePage) {
                             console.error("未找到必要的DOM元素");
                             alert("返回失敗，請重新載入頁面");
                             return;
                         }
                         
                         // ===== 強制徹底隱藏遊戲界面 =====
                         console.log("開始執行界面切換");
                         
                         // 先徹底隱藏遊戲界面 - 使用多重方式確保隱藏
                         gamePage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important;';
                         gamePage.classList.add('hidden');
                         
                         // 移除任何可能顯示遊戲界面的類名
                         gamePage.classList.remove('block', 'flex', 'visible', 'opacity-100');
                         
                         // ===== 強制徹底顯示用戶資料表 =====
                         
                         // 確保用戶資料表顯示
                         userProfileContainer.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important; pointer-events: auto !important;';
                         userProfileContainer.classList.remove('hidden');
                         
                         // 添加顯示類名
                         userProfileContainer.classList.add('block');
                         
                         // 確保書本頁面回到初始狀態
                         const bookPage = document.querySelector('.page');
                         if (bookPage && bookPage.classList.contains('turned')) {
                             bookPage.classList.remove('turned');
                         }
                         
                         // **新功能** 滾動頁面至頂部
                         window.scrollTo({
                             top: 0,
                             behavior: 'smooth'
                         });
                         
                         // 使用延遲檢查元素最終狀態
                         setTimeout(() => {
                             // 檢查狀態並記錄
                             console.log("界面切換結果檢查:");
                             console.log("- 遊戲界面顯示狀態:", window.getComputedStyle(gamePage).display);
                             console.log("- 用戶資料表顯示狀態:", window.getComputedStyle(userProfileContainer).display);
                             
                             // 強制再次確認
                             if (window.getComputedStyle(gamePage).display !== 'none') {
                                 console.warn("遊戲界面仍未隱藏，再次嘗試...");
                                 gamePage.style.cssText = 'display: none !important; visibility: hidden !important;';
                             }
                             
                             if (window.getComputedStyle(userProfileContainer).display !== 'block') {
                                 console.warn("用戶資料表未顯示，再次嘗試...");
                                 userProfileContainer.style.cssText = 'display: block !important; visibility: visible !important;';
                             }
                             
                             // 再次確保頁面滾動至頂部
                             window.scrollTo({
                                 top: 0,
                                 behavior: 'smooth'
                             });
                         }, 50);
                         
                         console.log("界面切換指令已執行");
                     } catch (error) {
                         console.error("返回按鈕處理發生錯誤:", error);
                         alert("返回時發生錯誤，請重新載入頁面");
                     }
                 };
             }
             
             // 顯示墨水擴散載入動畫
             function showLoadingAnimation() {
                 // 創建全屏覆蓋層和墨點容器
                 const loadingContainer = document.createElement('div');
                 loadingContainer.id = 'loading-container';
                 loadingContainer.style.position = 'fixed';
                 loadingContainer.style.top = '0';
                 loadingContainer.style.left = '0';
                 loadingContainer.style.width = '100%';
                 loadingContainer.style.height = '100%';
                 loadingContainer.style.backgroundColor = 'rgba(245, 242, 234, 1)'; // 完全不透明背景
                 loadingContainer.style.zIndex = '9999'; // 確保在最上層
                 loadingContainer.style.display = 'flex';
                 loadingContainer.style.justifyContent = 'center';
                 loadingContainer.style.alignItems = 'center';
                 loadingContainer.style.opacity = '0';
                 loadingContainer.style.animation = 'fadeIn 0.15s ease forwards';
                 loadingContainer.innerHTML = `
                     <div id="main-splash"></div>
                 `;
                 document.body.appendChild(loadingContainer);
         
                 // 動畫結束後返回
                 return new Promise(resolve => {
                     setTimeout(function() {
                         hideLoadingAnimation();
                         resolve();
                     }, 900);
                 });
             }
         
             function hideLoadingAnimation() {
                 const container = document.getElementById('loading-container');
                 if (container) {
                     container.classList.add('fade-out');
                     // 加快淡出時間
                     setTimeout(function() {
                         container.remove();
                     }, 200);
                 }
             }            
         
             // 創建紙屑慶祝效果
             function createConfetti() {
                 // 加載 canvas-confetti 庫
                 const script = document.createElement('script');
                 script.src = 'https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js';
                 document.head.appendChild(script);
                 
                 // 建立 canvas 元素
                 const canvas = document.createElement('canvas');
                 canvas.id = 'confetti-canvas';
                 document.body.appendChild(canvas);
                 
                 script.onload = function() {
                     // 設置 confetti
                     const myConfetti = confetti.create(canvas, {
                         resize: true,
                         useWorker: true
                     });
                     
                     // 開始紙屑效果
                     
                     // 第一波：從頂部射出
                     myConfetti({
                         particleCount: 180,
                         spread: 100,
                         origin: { y: 0 },
                         colors: ['#5D5CDE', '#FF8C00', '#4CAF50', '#FF5252', '#FFC107', '#2196F3'],
                         startVelocity: 30,
                         gravity: 0.7,
                         scalar: 0.9
                     });
                     
                     // 從左右兩側射出
                     setTimeout(() => {
                         // 左側紙屑
                         myConfetti({
                             particleCount: 100,
                             angle: 60,
                             spread: 55,
                             origin: { x: 0, y: 0.5 },
                             colors: ['#5D5CDE', '#4CAF50', '#FFC107', '#2196F3']
                         });
                         
                         // 右側紙屑
                         myConfetti({
                             particleCount: 100,
                             angle: 120,
                             spread: 55,
                             origin: { x: 1, y: 0.5 },
                             colors: ['#FF8C00', '#FF5252', '#E91E63', '#9C27B0']
                         });
                     }, 700);
                     
                     // 第二波紙屑 - 從底部向上射出
                     setTimeout(() => {
                         myConfetti({
                             particleCount: 120,
                             spread: 120,
                             origin: { y: 0.9 },
                             startVelocity: 45,
                             gravity: 1,
                             scalar: 0.7
                         });
                     }, 1500);
                     
                     // 第三波 - 爆炸效果
                     setTimeout(() => {
                         myConfetti({
                             particleCount: 150,
                             spread: 180,
                             origin: { x: 0.5, y: 0.5 }
                         });
                     }, 2500);
                     
                     // 清理資源
                     setTimeout(() => {
                         canvas.remove();
                     }, 8000);
                 };
             }
             
             // 創建結果分享卡片
             function createShareCard(passageTitle, author, finalTime, wrongAnswersCount, totalNonPunctChars, achievements, paragraphIndices) {
                 return new Promise((resolve, reject) => {
                     try {
                         // 創建一個離屏的卡片元素用於截圖
                         const card = document.createElement('div');
                         card.id = 'share-card';
                         // 強制使用深色模式樣式，無論當前應用模式如何
                         card.className = 'fixed top-0 left-0 bg-gray-800 border-8 border-amber-900 p-6 rounded-lg shadow-xl';
                         card.style.width = '350px';
                         card.style.zIndex = '-100'; // 確保在屏幕外不可見
                         
                         // 處理標題，添加段落範圍信息
                         let displayTitle = passageTitle;
                         let rangeText = "";
                         
                         // 取得全局保存的段落索引，如果提供的參數無效
                         let indicesToUse = [];
                         if (paragraphIndices && Array.isArray(paragraphIndices) && paragraphIndices.length > 0) {
                             indicesToUse = paragraphIndices;
                             console.log("使用提供的段落索引:", indicesToUse);
                         } else if (window.selectedParagraphIndices && Array.isArray(window.selectedParagraphIndices) && window.selectedParagraphIndices.length > 0) {
                             indicesToUse = window.selectedParagraphIndices;
                             console.log("使用全局保存的段落索引:", indicesToUse);
                         } else {
                             console.log("未找到段落索引資訊");
                         }
                         
                         // 如果有段落索引數組，構建顯示範圍
                         if (indicesToUse.length > 0) {
                             const selectedPassage = passages[currentPassageKey];
                             if (selectedPassage) {
                                 // 檢查是否是完整篇章
                                 const isFullPassage = indicesToUse.length >= selectedPassage.paragraphs.length;
                                 
                                 if (!isFullPassage) {
                                     // 對段落索引進行排序
                                     indicesToUse.sort((a, b) => a - b);
                                     
                                     // 確定是否是連續的段落
                                     let isConsecutive = true;
                                     for (let i = 0; i < indicesToUse.length - 1; i++) {
                                         if (indicesToUse[i + 1] !== indicesToUse[i] + 1) {
                                             isConsecutive = false;
                                             break;
                                         }
                                     }
                                     
                                     if (indicesToUse.length === 1) {
                                         rangeText = `第${indicesToUse[0] + 1}段`;
                                     } else if (isConsecutive) {
                                         rangeText = `第${indicesToUse[0] + 1}-${indicesToUse[indicesToUse.length - 1] + 1}段`;
                                     } else {
                                         rangeText = `第${indicesToUse.map(idx => idx + 1).join('、')}段`;
                                     }
                                     
                                     displayTitle = `${passageTitle}（${rangeText}）`;
                                     console.log("生成的顯示標題:", displayTitle);
                                 }
                             }
                         }
                         
                         // 生成成就徽章HTML - 修正印章內文字居中問題
                         let achievementsHTML = '';
                         if (achievements && achievements.length > 0) {
                             achievementsHTML = `
                             <div class="mt-4 mb-3 border-t border-gray-600 pt-3">
                                 <p class="text-sm font-medium text-amber-400 mb-2">獲得成就:</p>
                                 <div class="flex flex-wrap justify-center mb-2" style="margin: 0 -8px;">
                             `;
                             
                             // 添加每個成就徽章 - 改進文字居中和邊距
                             achievements.forEach(achievement => {
                                 // 提取SVG
                                 const svg = achievement.svg;
                                 
                                 achievementsHTML += `
                                 <div style="width: 70px; height: 70px; position: relative; display: inline-flex; justify-content: center; align-items: center; transform: rotate(-5deg); margin: 4px;">
                                     <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                                         ${svg}
                                     </div>
                                     <div style="position: relative; z-index: 10; font-family: 'Noto Serif TC', serif; font-weight: bold; color: #fff; display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 100%;">
                                         <span style="font-size: 10px; line-height: 1.2; text-align: center; width: 80%; display: block;">${achievement.title}</span>
                                     </div>
                                 </div>`;
                             });
                             
                             achievementsHTML += `</div></div>`;
                         }
                         
                         // 卡片內容 - 使用深色模式的文字顏色
                         card.innerHTML = `
                             <div class="relative">
                                 <div class="text-center mb-3">
                                     <h2 class="text-xl font-bold text-gray-100">${displayTitle}</h2>
                                     <p class="text-gray-400 text-sm">${author}</p>
                                 </div>
                                 
                                 <div class="bg-gray-700 p-3 rounded-lg">
                                     <div class="flex justify-between mb-1">
                                         <span class="text-gray-300 text-sm">完成時間:</span>
                                         <span class="font-medium text-gray-200">${finalTime}</span>
                                     </div>
                                     <div class="flex justify-between mb-1">
                                         <span class="text-gray-300 text-sm">錯誤次數:</span>
                                         <span class="font-medium text-gray-200">${wrongAnswersCount}</span>
                                     </div>
                                     <div class="flex justify-between">
                                         <span class="text-gray-300 text-sm">總字數:</span>
                                         <span class="font-medium text-gray-200">${totalNonPunctChars}</span>
                                     </div>
                                 </div>
                                 
                                 ${achievementsHTML}
                                 
                                 <div class="mt-3 text-center text-xs text-gray-400">
                                     文言大師之旅 © ${new Date().getFullYear()}
                                 </div>
                             </div>
                         `;
                         
                         document.body.appendChild(card);
                         
                         // 給元素一些時間渲染
                         setTimeout(() => {
                             html2canvas(card, {
                                 backgroundColor: '#181818', // 強制使用深色背景
                                 scale: 2, // 高解析度
                                 logging: false,
                                 allowTaint: true,
                                 useCORS: true
                             }).then(canvas => {
                                 const imageData = canvas.toDataURL('image/png');
                                 document.body.removeChild(card);
                                 resolve(imageData);
                             }).catch(err => {
                                 document.body.removeChild(card);
                                 reject(err);
                             });
                         }, 100);
                     } catch (error) {
                         reject(error);
                     }
                 });
             }
         
             // 處理分享功能
             function handleShare(imageData) {
                 // 檢查是否支持 Web Share API
                 if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([dataURItoBlob(imageData)], 'result.png', { type: 'image/png' })] })) {
                     // 手機分享方式
                     navigator.share({
                         files: [new File([dataURItoBlob(imageData)], 'result.png', { type: 'image/png' })],
                         title: '文言大師之旅',
                         text: '我剛剛完成了文言文背誦挑戰！'
                     }).catch(err => {
                         console.log('分享失敗:', err);
                         // 如果Web Share API失敗，提供備用選項
                         showShareOptions(imageData);
                     });
                 } else {
                     // 桌面版或不支持Web Share API時的分享選項
                     showShareOptions(imageData);
                 }
             }
             
             // 顯示分享選項
             function showShareOptions(imageData) {
                 const shareModal = document.createElement('div');
                 shareModal.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[100]';
                 shareModal.innerHTML = `
                 <div class="bg-white dark:bg-gray-800 rounded-lg p-4 max-w-md w-full mx-4">
                     <div class="flex justify-between items-center mb-3">
                         <h3 class="text-lg font-bold text-gray-800 dark:text-gray-100">分享您的成績</h3>

                         <button id="close-share-modal" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-gray-100">
                             <i class="fas fa-times"></i>
                         </button>
                     </div>
                     <div class="flex justify-center mb-4">
                         <img src="${imageData}" alt="成績卡片" class="max-h-[350px] border border-gray-200 dark:border-gray-700 rounded-lg shadow-md" />
                     </div>
                     <div class="flex justify-center gap-4">
                         <button id="download-share-image" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-opacity-90">
                             <i class="fas fa-download mr-2"></i>下載圖片
                         </button>
                     </div>
                     <p class="text-center text-sm text-gray-500 mt-3">保存圖片後可以分享到社交媒體</p>
                 </div>
                 `;
                 
                 document.body.appendChild(shareModal);
                 
                 // 關閉按鈕
                 document.getElementById('close-share-modal').addEventListener('click', () => {
                     document.body.removeChild(shareModal);
                 });
                 
                 // 下載圖片
                 document.getElementById('download-share-image').addEventListener('click', () => {
                     const link = document.createElement('a');
                     link.href = imageData;
                     link.download = '文言文背誦成績.png';
                     document.body.appendChild(link);
                     link.click();
                     document.body.removeChild(link);
                 });
                 
                 // 點擊背景關閉模態框
                 shareModal.addEventListener('click', (e) => {
                     if (e.target === shareModal) {
                         document.body.removeChild(shareModal);
                     }
                 });
             }
             
             // 將DataURI轉換為Blob
             function dataURItoBlob(dataURI) {
                 const byteString = atob(dataURI.split(',')[1]);
                 const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
                 const ab = new ArrayBuffer(byteString.length);
                 const ia = new Uint8Array(ab);
                 
                 for (let i = 0; i < byteString.length; i++) {
                     ia[i] = byteString.charCodeAt(i);
                 }
                 
                 return new Blob([ab], { type: mimeString });
             }
         
             function completePassage() {
                 // 停止遊戲内容顯示
                 if (gameContent) {
                     gameContent.classList.add('hidden');
                 }
                 
                 // 更新按鈕狀態為「完成」，顯示返回主頁按鈕
                 updateGameControlButtons('completed');
                 
                 // 如果指定的DOM元素不存在，則記錄錯誤並中止
                 if (!optionsContainer) {
                     console.error("optionsContainer未找到，無法顯示遊戲完成界面");
                     return;
                 }
                 
                 // 清空当前字符显示
                 if (currentChar) {
                     currentChar.textContent = '';
                 }
                 
                 // 停止秒錶
                 stopStopwatch();
                 const finalTime = timerElement ? timerElement.textContent : "00:00.0";
                 
                 // 計算總完成時間（秒）
                 const totalSeconds = getCompletionTimeInSeconds();
                 
                 // 記錄通關成績 - 檢查是否為完整篇章
                 const selectedPassage = passages[currentPassageKey];
                 if (selectedPassage) {
                     // 確保用於檢查完整篇章時顯示正確的結果
                     let allParagraphsContent = selectedPassage.paragraphs.join('');
                     const isFullPassage = (content === allParagraphsContent);
                     
                     console.log("完成挑戰");
                     console.log("篇章鍵值:", currentPassageKey);
                     console.log("是否為完整篇章:", isFullPassage);
                     console.log("完成時間(秒):", totalSeconds);
                     
                     // 只有完整篇章才記錄成績
                     recordCompletionStats(currentPassageKey, totalSeconds, isFullPassage);
                 }
                 
                 // 播放紙屑慶祝效果
                 createConfetti();
                 
                 // 判斷成就
                 const isPerfect = wrongAnswersCount === 0;
                 const isLightningFast = totalSeconds <= totalNonPunctChars * 0.8; // 使用总字数*0.8秒作为閃電俠阈值
                 const isMaster = totalNonPunctChars >= 300; // 記憶大師（字數超過300）
                 const isSnail = totalSeconds >= totalNonPunctChars * 3; // 蝸牛（時間超過字數*3秒）
                 const isTireless = !hasPaused; // 不知疲倦（全程不暫停）
                 
                 // 檢查特殊時間成就 - 在這裡也檢查一次，確保成就及時展示
                 // 判斷夜貓成就 (01:00-03:00)
                 const now = new Date();
                 const hours = now.getHours();
                 const minutes = now.getMinutes();
                 
                 // 判斷是否符合夜貓時間條件
                 const isNightOwl = (hours >= 1 && hours < 3);
                 
                 // 判斷是否符合腸胃不好時間條件
                 const isBadDigestion = ((hours == 11 && minutes >= 59) || (hours == 12 && minutes <= 45));
                 
                 // 更新極速之路和完美之路成就
                 if (isLightningFast) {
                     // 增加獲得閃電俠成就次數
                     globalStats.lightningAchievementCount = (globalStats.lightningAchievementCount || 0) + 1;
                     
                     // 更新極速之路成就等級
                     const lightningCount = globalStats.lightningAchievementCount;
                     
                     if (lightningCount >= 100 && globalStats.achievements.speedRouteLevel < 4) {
                         globalStats.achievements.speedRouteLevel = 4; // 世界第一束光 (100次)
                     } else if (lightningCount >= 50 && globalStats.achievements.speedRouteLevel < 3) {
                         globalStats.achievements.speedRouteLevel = 3; // 無影手 (50次)
                     } else if (lightningCount >= 10 && globalStats.achievements.speedRouteLevel < 2) {
                         globalStats.achievements.speedRouteLevel = 2; // 肌肉記憶 (10次)
                     } else if (lightningCount >= 1 && globalStats.achievements.speedRouteLevel < 1) {
                         globalStats.achievements.speedRouteLevel = 1; // 敏捷 (1次)
                     }
                     
                     console.log(`獲得閃電俠成就，總計: ${lightningCount}次，極速之路等級: ${globalStats.achievements.speedRouteLevel}`);
                 }
                 
                 if (isPerfect) {
                     // 增加獲得完美無瑕成就次數
                     globalStats.perfectAchievementCount = (globalStats.perfectAchievementCount || 0) + 1;
                     
                     // 更新完美之路成就等級
                     const perfectCount = globalStats.perfectAchievementCount;
                     
                     if (perfectCount >= 100 && globalStats.achievements.perfectRouteLevel < 4) {
                         globalStats.achievements.perfectRouteLevel = 4; // 至善 (100次)
                     } else if (perfectCount >= 50 && globalStats.achievements.perfectRouteLevel < 3) {
                         globalStats.achievements.perfectRouteLevel = 3; // 滿月 (50次)
                     } else if (perfectCount >= 10 && globalStats.achievements.perfectRouteLevel < 2) {
                         globalStats.achievements.perfectRouteLevel = 2; // 完美主義 (10次)
                     } else if (perfectCount >= 1 && globalStats.achievements.perfectRouteLevel < 1) {
                         globalStats.achievements.perfectRouteLevel = 1; // 如沐春風 (1次)
                     }
                     
                     console.log(`獲得完美無瑕成就，總計: ${perfectCount}次，完美之路等級: ${globalStats.achievements.perfectRouteLevel}`);
                 }
                 
                 // 創建成就徽章
                 const createSealSVG = (colors, borderColor) => {
                     // 確保每個SVG有唯一ID
                     const uniqueId = 'seal_' + Math.random().toString(36).substr(2, 9);
                     return `
                     <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                         <defs>
                             <radialGradient id="${uniqueId}" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                                 <stop offset="0%" style="stop-color:${colors.center}" />
                                 <stop offset="70%" style="stop-color:${colors.middle}" />
                                 <stop offset="100%" style="stop-color:${colors.outer}" />
                             </radialGradient>
                         </defs>
                         <circle cx="50" cy="50" r="45" fill="url(#${uniqueId})" />
                         <circle cx="50" cy="50" r="42" fill="none" stroke="${borderColor}" stroke-width="1" stroke-dasharray="2,1" />
                         <circle cx="50" cy="50" r="38" fill="none" stroke="${borderColor}" stroke-width="0.5" />
                     </svg>
                     `;
                 };
                 
                 // 定義各成就蠟章顏色
                 const perfectColors = { center: '#8B0000', middle: '#5C0000', outer: '#400000' };
                 const lightningColors = { center: '#4B0082', middle: '#2A004D', outer: '#1C0033' };
                 const masterColors = { center: '#006400', middle: '#004D00', outer: '#003300' };
                 const snailColors = { center: '#8B4513', middle: '#6B3100', outer: '#4A2100' };
                 const tirelessColors = { center: '#1E3A8A', middle: '#1E40AF', outer: '#1D4ED8' }; // 藍色調代表專注和堅持
                 const nightOwlColors = { center: '#3E2723', middle: '#33211B', outer: '#2E1B15' }; // 深咖啡色代表夜晚
                 const badDigestionColors = { center: '#E65100', middle: '#D84315', outer: '#BF360C' }; // 橙紅色代表不舒服
                 
                 // 格式化成就信息
                 const achievements = [];
                 
                 if (isPerfect) {
                     achievements.push({
                         svg: createSealSVG(perfectColors, '#FFD700'),
                         title: '完美無瑕',
                         desc: '零錯誤通關'
                     });
                 }
                 
                 if (isLightningFast) {
                     achievements.push({
                         svg: createSealSVG(lightningColors, '#00FFFF'),
                         title: '閃電俠',
                         desc: '神速完成'
                     });
                 }
                 
                 if (isMaster) {
                     // 增加獲得記憶大師成就次數
                     globalStats.memoryAchievementCount = (globalStats.memoryAchievementCount || 0) + 1;
                     
                     // 更新記憶之路成就等級
                     const memoryCount = globalStats.memoryAchievementCount;
                     
                     if (memoryCount >= 50 && globalStats.achievements.memoryRouteLevel < 4) {
                         globalStats.achievements.memoryRouteLevel = 4; // 流如背倒 (50次)
                     } else if (memoryCount >= 30 && globalStats.achievements.memoryRouteLevel < 3) {
                         globalStats.achievements.memoryRouteLevel = 3; // 移動圖書館 (30次)
                     } else if (memoryCount >= 10 && globalStats.achievements.memoryRouteLevel < 2) {
                         globalStats.achievements.memoryRouteLevel = 2; // 記憶麵包 (10次)
                     } else if (memoryCount >= 1 && globalStats.achievements.memoryRouteLevel < 1) {
                         globalStats.achievements.memoryRouteLevel = 1; // 激活腦細胞 (1次)
                     }
                     
                     console.log(`獲得記憶大師成就，總計: ${memoryCount}次，記憶之路等級: ${globalStats.achievements.memoryRouteLevel}`);
                     
                     achievements.push({
                         svg: createSealSVG(masterColors, '#7CFC00'),
                         title: '記憶大師',
                         desc: '一口氣300字+'
                     });
                 }
                 
                 if (isSnail) {
                     achievements.push({
                         svg: createSealSVG(snailColors, '#DAA520'),
                         title: '蝸牛',
                         desc: '慢工出細活'
                     });
                 }
                 
                 // 添加新成就：不知疲倦，並更新相關計數
                 if (isTireless) {
                     // 增加獲得不知疲倦成就次數
                     globalStats.tirelessAchievementCount = (globalStats.tirelessAchievementCount || 0) + 1;
                     
                     // 檢查是否達成「眼乾」成就（獲得不知疲倦30次）
                     if (globalStats.tirelessAchievementCount >= 30 && !globalStats.achievements.dryEyes) {
                         globalStats.achievements.dryEyes = true;
                         console.log("獲得獨立成就：眼乾（獲得不知疲倦30次）");
                     }
                     
                     achievements.push({
                         svg: createSealSVG(tirelessColors, '#38BDF8'),
                         title: '不知疲倦',
                         desc: '全程不暫停'
                     });
                 }
                 
                 // 添加夜貓成就 - 在這裡直接添加，確保用戶可以看到
                 if (isNightOwl) {
                     // 更新全局統計
                     globalStats.achievements.nightOwl = true;
                     globalStats.nightOwlAchievementCount = (globalStats.nightOwlAchievementCount || 0) + 1;
                     
                     // 檢查是否達成「夜貓王」成就
                     if (globalStats.nightOwlAchievementCount >= 20 && !globalStats.achievements.nightOwlKing) {
                         globalStats.achievements.nightOwlKing = true;
                         console.log("獲得獨立成就：夜貓王（獲得夜貓20次）");
                     }
                     
                     // 添加到成就列表
                     achievements.push({
                         svg: createSealSVG(nightOwlColors, '#4E342E'),
                         title: '夜貓',
                         desc: '夜深時仍不休'
                     });
                     
                     console.log(`獲得夜貓成就，總計: ${globalStats.nightOwlAchievementCount}次`);
                 }
                 
                 // 添加腸胃不好成就 - 在這裡直接添加，確保用戶可以看到
                 if (isBadDigestion) {
                     // 更新全局統計
                     globalStats.achievements.badDigestion = true;
                     globalStats.badDigestionAchievementCount = (globalStats.badDigestionAchievementCount || 0) + 1;
                     
                     // 檢查是否達成「請專心吃飯」成就
                     if (globalStats.badDigestionAchievementCount >= 20 && !globalStats.achievements.focusOnEating) {
                         globalStats.achievements.focusOnEating = true;
                         console.log("獲得獨立成就：請專心吃飯（獲得腸胃不好20次）");
                     }
                     
                     // 添加到成就列表
                     achievements.push({
                         svg: createSealSVG(badDigestionColors, '#BF360C'),
                         title: '腸胃不好',
                         desc: '用餐時間仍勤學'
                     });
                     
                     console.log(`獲得腸胃不好成就，總計: ${globalStats.badDigestionAchievementCount}次`);
                 }
                 
                 // 保存更新的統計和成就
                 saveStats();
                 
                 // 清空選項容器並修改布局為flex布局
                 optionsContainer.innerHTML = '';
                 optionsContainer.className = 'flex flex-col justify-center items-center mb-4';
                 
                 const completionMessage = document.createElement('div');
                 completionMessage.className = 'text-center bg-white dark:bg-gray-700 p-6 rounded-lg shadow-md w-full sm:w-4/5';
                 completionMessage.id = 'completion-result';
                 
                 // 添加經驗值獎勵
                 const expGained = totalNonPunctChars*3; // 經驗值 = 該遊戲字數
                 addExperience(expGained);
                 console.log(`遊戲完成，獲得經驗值: ${expGained}`);
                 
                 // 顯示獲得的經驗值訊息
                 const expNotification = document.createElement('div');
                 expNotification.className = 'fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-amber-100 dark:bg-amber-800 text-amber-900 dark:text-amber-100 py-2 px-4 rounded-lg shadow-lg z-[9999] flex items-center';
                 expNotification.style.animation = 'fadeInOut 3s ease-in-out forwards';
                 
                 expNotification.innerHTML = `
                     <i class="fas fa-star text-amber-500 dark:text-amber-300 mr-2"></i>
                     <div>獲得 <span class="font-bold">${expGained}</span> 經驗值</div>
                 `;
                 
                 document.body.appendChild(expNotification);
                 
                 setTimeout(() => {
                     expNotification.remove();
                 }, 3000);
                 
                 // 生成成就徽章HTML
                 let achievementsHTML = '';
                 if (achievements.length > 0) {
                     achievementsHTML = `
                     <div class="mb-5 mt-4">
                         <p class="text-lg font-medium text-amber-700 dark:text-amber-400 mb-3">獲得成就:</p>
                         <div class="achievements-container" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 0px;">
                     `;
                     
                     // 添加每個成就徽章，设置为一行至少显示三个
                     achievements.forEach(achievement => {
                         achievementsHTML += `
                         <div class="achievement-seal" style="width: calc(33.333% - 0px); min-width: 70px; max-width: 100px; flex-grow: 0; flex-shrink: 0;">
                             ${achievement.svg}
                             <div class="seal-text">
                                 <span class="seal-title">${achievement.title}</span>
                                 <span class="seal-desc">${achievement.desc}</span>
                             </div>
                         </div>`;
                     });
                     
                     achievementsHTML += `</div></div>`;
                 }
                 
                 // 準備按鈕HTML，先不包含onClick事件，稍後會直接在DOM元素上設置
                 const buttonsHTML = `
                     <div class="flex justify-center gap-6 mt-4">
                         <button id="share-result-btn" class="w-12 h-12 bg-green-600 text-white rounded-full hover:bg-green-700 transition-colors flex items-center justify-center text-xl">
                             <i class="fas fa-share-alt"></i>
                         </button>
                         <button id="restart-result-btn" class="w-12 h-12 bg-amber-500 text-white rounded-full hover:bg-amber-600 transition-colors flex items-center justify-center text-xl">
                             <i class="fas fa-redo"></i>
                         </button>
                     </div>
                 `;
                 
                 // 生成完整信息HTML
                 completionMessage.innerHTML = `
                     <p class="text-2xl text-green-600 dark:text-green-400 mb-6 font-bold">恭喜完成！</p>
                     <div class="bg-gray-100 dark:bg-gray-800 p-4 rounded-lg mb-4">
                         <p class="text-gray-700 dark:text-gray-300">完成時間: ${finalTime}</p>
                         <p class="text-gray-700 dark:text-gray-300">錯誤次數: ${wrongAnswersCount}</p>
                         <p class="text-gray-700 dark:text-gray-300">總字數: ${totalNonPunctChars}</p>
                     </div>
                     ${achievementsHTML}
                     ${buttonsHTML}
                 `;
                 
                 optionsContainer.appendChild(completionMessage);
                 
                 // 定義重置遊戲狀態的函數
                 function resetGameState() {
                     console.log("重置遊戲狀態");
                     currentPosition = 0;
                     correctAnswers = 0;
                     lives = 3;
                     successfulChars = 0;
                     wrongAnswersCount = 0;
                     lastAnsweredChars = [];
                     
                     const lastAnsweredCharsElem = document.getElementById('last-answered-chars');
                     if (lastAnsweredCharsElem) {
                         lastAnsweredCharsElem.textContent = '';
                     }
                     
                     canSelect = true;
                     isPaused = false;
                     hasPaused = false;
                     updateLives();
                     
                     if (feedback) {
                         feedback.textContent = '';
                     }
                     
                     // 更新進度條
                     const progressText = document.getElementById('progress-text');
                     const progressBar = document.getElementById('progress-bar');
                     
                     if (progressText) {
                         progressText.textContent = `0 / ${totalNonPunctChars}`;
                     }
                     
                     if (progressBar) {
                         progressBar.style.width = '0%';
                     }
                     
                     // 清空選項容器
                     if (optionsContainer) {
                         optionsContainer.innerHTML = '';
                         optionsContainer.className = 'grid grid-cols-3 gap-3 md:gap-4 mb-4';
                     }
                 }
                 
                 // 獲取按鈕元素
                 const shareResultBtn = document.getElementById('share-result-btn');
                 const restartResultBtn = document.getElementById('restart-result-btn');
                 const completionReturnBtn = document.getElementById('completion-return-btn');
                 
                 // 立即為按鈕添加點擊事件
                 if (shareResultBtn) {
                     shareResultBtn.onclick = function() {
                         console.log("分享按鈕被點擊");
                         
                         // 顯示加載中動畫
                         const loadingOverlay = document.createElement('div');
                         loadingOverlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[101]';
                         loadingOverlay.innerHTML = `
                             <div class="bg-white dark:bg-gray-800 p-6 rounded-lg flex flex-col items-center">
                                 <i class="fas fa-spinner fa-spin text-3xl text-primary mb-3"></i>
                                 <p class="text-gray-700 dark:text-gray-300">正在生成分享圖片...</p>
                             </div>
                         `;
                         document.body.appendChild(loadingOverlay);
                         
                         // 獲取當前選擇的段落索引
                         const paragraphInfo = window.selectedParagraphIndices || [];
                         
                         // 創建分享卡片
                         createShareCard(
                             selectedPassage.title, 
                             selectedPassage.author, 
                             finalTime, 
                             wrongAnswersCount, 
                             totalNonPunctChars, 
                             achievements,
                             paragraphInfo
                         ).then(imageData => {
                             document.body.removeChild(loadingOverlay);
                             handleShare(imageData);
                         }).catch(err => {
                             console.error('創建分享卡片失敗:', err);
                             document.body.removeChild(loadingOverlay);
                             alert('生成分享圖片失敗，請稍後再試。');
                         });
                     };
                     console.log("已為分享按鈕設置點擊事件");
                 }
                 
                 if (restartResultBtn) {
                     restartResultBtn.addEventListener('click', async function() {
                         console.log("重來按鈕被點擊");
                         
                         try {
                             // 顯示載入動畫
                             await showLoadingAnimation();
                             
                             // 使用全局重置函數
                             resetGameState();
                             
                             // 確保遊戲頁面顯示
                             if (gamePage && gamePage.classList.contains('hidden')) {
                                 gamePage.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                                 gamePage.classList.remove('hidden');
                             }
                             
                             // 先隱藏遊戲內容，確保切換到開始畫面
                             if (gameContent) {
                                 gameContent.classList.add('hidden');
                             }
                             
                             // 確保開始畫面顯示
                             if (gameStartScreen) {
                                 gameStartScreen.classList.remove('hidden');
                                 console.log("成功切換到開始屏幕");
                             } else {
                                 console.error("找不到開始屏幕元素");
                             }
                             
                             // 重置秒表
                             stopStopwatch();
                             elapsedTimeBeforePause = 0;
                             if (timerElement) {
                                 timerElement.textContent = "00:00.0";
                             }
                             
                             console.log("遊戲已重置，準備重新開始");
                         } catch (error) {
                             console.error("重新開始時出錯:", error);
                             alert("重新開始時發生錯誤: " + error.message);
                         }
                     });
                     console.log("已為重來按鈕設置點擊事件(addEventListener)");
                 }
                 
                 if (completionReturnBtn) {
                     completionReturnBtn.onclick = function() {
                         console.log("返回按鈕被點擊");
                         
                         try {
                             // 重置遊戲狀態
                             resetGameState();
                             
                             // 獲取需要操作的元素
                             const userProfileContainer = document.getElementById('user-profile-container');
                             const gamePage = document.getElementById('game-page');
                             
                             if (!userProfileContainer || !gamePage) {
                                 console.error("未找到必要的DOM元素");
                                 alert("返回失敗，請重新載入頁面");
                                 return;
                             }
                             
                             // 隱藏遊戲界面
                             gamePage.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
                             gamePage.classList.add('hidden');
                             gamePage.classList.remove('block', 'flex', 'visible', 'opacity-100');
                             
                             // 顯示用戶資料界面
                             userProfileContainer.style.cssText = 'display: block !important; visibility: visible !important; opacity: 1 !important;';
                             userProfileContainer.classList.remove('hidden');
                             userProfileContainer.classList.add('block');
                             
                             // 確保書本頁面回到初始狀態
                             const bookPage = document.querySelector('.page');
                             if (bookPage && bookPage.classList.contains('turned')) {
                                 bookPage.classList.remove('turned');
                             }
                             
                             // 滾動到頁面頂部
                             window.scrollTo(0, 0);
                             
                             console.log("返回主頁成功");
                         } catch (error) {
                             console.error("返回按鈕處理發生錯誤:", error);
                             alert("返回時發生錯誤，請重新載入頁面");
                         }
                     };
                     console.log("已為返回按鈕設置點擊事件");
                 }
                 
                 // 以防萬一，添加額外的事件代理
                 optionsContainer.addEventListener('click', function(event) {
                     const target = event.target;
                     
                     // 檢查是否是按鈕或按鈕內的元素
                     if (target.closest('#restart-result-btn')) {
                         console.log("通過代理偵測到重來按鈕點擊");
                         const btn = document.getElementById('restart-result-btn');
                         if (btn && typeof btn.onclick === 'function') {
                             btn.onclick();
                         }
                     }
                     
                     if (target.closest('#completion-return-btn')) {
                         console.log("通過代理偵測到返回按鈕點擊");
                         const btn = document.getElementById('completion-return-btn');
                         if (btn && typeof btn.onclick === 'function') {
                             btn.onclick();
                         }
                     }
                     
                     if (target.closest('#share-result-btn')) {
                         console.log("通過代理偵測到分享按鈕點擊");
                         const btn = document.getElementById('share-result-btn');
                         if (btn && typeof btn.onclick === 'function') {
                             btn.onclick();
                         }
                     }
                 });
             }
             
             // 创建墨滴效果
             function createInkDrop(element) {
                 if (!element) return;
                 
                 const inkDrop = document.createElement('div');
                 inkDrop.className = 'ink-drop';
                 
                 // 计算点击位置
                 const rect = element.getBoundingClientRect();
                 const x = Math.random() * (rect.width - 10);
                 const y = Math.random() * (rect.height - 10);
                 
                 inkDrop.style.left = `${x}px`;
                 inkDrop.style.top = `${y}px`;
                 
                 // 不再設置position和overflow，因為已經在CSS中預設了
                 element.appendChild(inkDrop);
                 
                 // 移除元素
                 setTimeout(() => {
                     if (inkDrop.parentNode === element) {
                         inkDrop.remove();
                     }
                 }, 2000);
             }
             
             // 辅助函数
             function isPunctuation(char) {
                 // 檢查所有可能的冒號變體和其他標點
                 if (!char) return false;
                 
                 const charCode = char.charCodeAt(0);
                 // 全形冒號(U+FF1A)和半形冒號(U+003A)
                 if (charCode === 0xFF1A || charCode === 0x003A) {
                     return true;
                 }
                 // 檢查其他標點符號
                 return '「」：︰！，。；!?----……『』、？:'.includes(char);
             }
             
             function shuffleArray(array) {
                 const newArray = [...array];
                 for (let i = newArray.length - 1; i > 0; i--) {
                     const j = Math.floor(Math.random() * (i + 1));
                     [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                 }
                 return newArray;
             }
             
             // 初始化設置按鈕及相關功能
             initializeSettings();
             
             // 首先声明全局变量，确保它们在使用之前已完成初始化
             // 用於替代localStorage的內存存儲
             let userRecordsMemory = {};
             
             // 全局成就和統計跟踪
             let globalStats = {
                 totalCompletionCount: 0,      // 總完成次數
                 failAfterHalfwayCount: 0,     // 遊戲過半後失敗次數
                 lightningAchievementCount: 0, // 獲得閃電俠成就次數
                 perfectAchievementCount: 0,   // 獲得完美無瑕成就次數
                 memoryAchievementCount: 0,    // 獲得記憶大師成就次數
                 tirelessAchievementCount: 0,  // 獲得不知疲倦成就次數
                 nightOwlAchievementCount: 0,  // 獲得夜貓成就次數
                 badDigestionAchievementCount: 0, // 獲得腸胃不好成就次數
                 achievements: {
                     // 特殊時間成就
                     nightOwl: false,         // 夜貓（01:00-03:00完成）
                     badDigestion: false,     // 腸胃不好（11:59-12:45完成）
                     
                     // 特殊累積成就
                     dryEyes: false,          // 眼乾（獲得「不知疲倦」30次）
                     nightOwlKing: false,     // 夜貓王（獲得「夜貓」20次）
                     focusOnEating: false,    // 請專心吃飯（獲得「腸胃不好」20次）
                     
                     // 冒險之路成就
                     adventureLevel: 0,       // 0:未獲得 1:初心者 2:勇者 3:大師 4:偏執狂 5:掃地僧
                     
                     // 挫敗之路成就
                     defeatLevel: 0,          // 0:未獲得 1:初嘗敗績 2:堅毅 3:鋼鐵意志 4:小強是我 5:心如止水
                     
                     // 極速之路成就
                     speedRouteLevel: 0,      // 0:未獲得 1:敏捷 2:肌肉記憶 3:無影手 4:世界第一束光
                     
                     // 完美之路成就
                     perfectRouteLevel: 0,     // 0:未獲得 1:如沐春風 2:完美主義 3:滿月 4:至善
                     
                     // 記憶之路成就
                     memoryRouteLevel: 0       // 0:未獲得 1:激活腦細胞 2:記憶麵包 3:移動圖書館 4:流如背倒
                 }
             };
             
             // 用戶資料和經驗值系統
             let userProfile = {
                 name: "文言大師",
                 level: 1,
                 exp: 0,
                 nextLevelExp: 100
             };
             
             // 計算升級所需經驗值
             function calculateExpForNextLevel(level) {
                 if (level <= 10) return 100;
                 if (level <= 20) return 180;
                 if (level <= 30) return 260;
                 if (level <= 40) return 320;
                 if (level <= 50) return 400;
                 if (level <= 60) return 480;
                 if (level <= 70) return 560;
                 if (level <= 80) return 640;
                 if (level <= 90) return 720;
                 if (level <= 100) return 800;
                 if (level <= 999) return 500;             
                 return Infinity; // 1000級為滿級
             }
             
             // 添加經驗值
             function addExperience(amount) {
                 if (userProfile.level >= 1000) return; // 已達到滿級
                 
                 userProfile.exp += amount;
                 console.log(`添加經驗值: ${amount}, 當前經驗值: ${userProfile.exp}/${userProfile.nextLevelExp}`);
                 
                 // 檢查是否升級
                 while (userProfile.exp >= userProfile.nextLevelExp && userProfile.level < 1000) {
                     userProfile.level++;
                     userProfile.exp -= userProfile.nextLevelExp;
                     userProfile.nextLevelExp = calculateExpForNextLevel(userProfile.level);
                     
                     console.log(`升級! 新等級: ${userProfile.level}, 下一級所需經驗: ${userProfile.nextLevelExp}`);
                     
                     // 顯示升級提示
                     showLevelUpNotification(userProfile.level);
                 }
                 
                 // 更新經驗值顯示
                 updateExpDisplay();
                 
                 // 保存用戶資料
                 saveUserProfile();
             }
             
             // 顯示升級提示
             function showLevelUpNotification(newLevel) {
                 const notification = document.createElement('div');
                 notification.className = 'fixed top-1/4 left-1/2 transform -translate-x-1/2 bg-amber-100 dark:bg-amber-800 text-amber-900 dark:text-amber-100 py-3 px-6 rounded-lg shadow-lg z-[9999] flex flex-col items-center';
                 notification.style.animation = 'fadeInOut 3s ease-in-out forwards';
                 
                 notification.innerHTML = `
                     <div class="text-2xl font-bold mb-1">恭喜升級!</div>
                     <div class="text-3xl font-bold text-primary">Lv.${newLevel}</div>
                 `;
                 
                 document.body.appendChild(notification);
                 
                 // 添加淡入淡出動畫樣式
                 const style = document.createElement('style');
                 style.textContent = `
                     @keyframes fadeInOut {
                         0% { opacity: 0; transform: translate(-50%, -20px); }
                         15% { opacity: 1; transform: translate(-50%, 0); }
                         85% { opacity: 1; transform: translate(-50%, 0); }
                         100% { opacity: 0; transform: translate(-50%, -20px); }
                     }
                 `;
                 document.head.appendChild(style);
                 
                 // 檢查是否有新解鎖的頭像
                 checkNewUnlockedAvatars(newLevel);
                 
                 // 刪除通知
                 setTimeout(() => {
                     notification.remove();
                     style.remove();
                 }, 3000);
             }
             
             // 檢查新解鎖的頭像並顯示通知
             function checkNewUnlockedAvatars(newLevel) {
                 // 獲取所有等級為當前等級的頭像
                 const newUnlockedAvatars = [];
                 
                 Object.keys(window.avatarUnlockLevels).forEach(avatarKey => {
                     const requiredLevel = window.avatarUnlockLevels[avatarKey];
                     if (requiredLevel <= newLevel) {
                         // 找到此等級解鎖的頭像
                         const avatarData = avatarPixelData[avatarKey];
                         if (avatarData) {
                             newUnlockedAvatars.push({
                                 key: avatarKey,
                                 name: avatarData.name
                             });
                         }
                     }
                 });
                 
                 if (newUnlockedAvatars.length > 0) {
                     // 延遲顯示解鎖通知，讓升級通知先顯示
                     setTimeout(() => {
                         showAvatarUnlockNotification(newUnlockedAvatars);
                         
                         // 如果頭像選擇器是打開的，則重新生成頭像選項
                         const avatarSelector = document.getElementById('avatar-selector-modal');
                         if (avatarSelector && !avatarSelector.classList.contains('hidden')) {
                             const avatarGrid = document.getElementById('avatar-grid');
                             if (avatarGrid) {
                                 generateAvatarOptions(avatarGrid);
                             }
                         }
                     }, 1000);
                 }
             }
             
             // 顯示頭像解鎖通知
             function showAvatarUnlockNotification(avatars) {
                 const notification = document.createElement('div');
                 notification.className = 'fixed top-1/3 left-1/2 transform -translate-x-1/2 bg-blue-100 dark:bg-blue-800 text-blue-900 dark:text-blue-100 py-3 px-6 rounded-lg shadow-lg z-[9999] flex flex-col items-center max-w-sm';
                 notification.style.animation = 'fadeInOut 4s ease-in-out forwards';
                 
                 // 創建通知內容
                 let avatarsList = '';
                 avatars.forEach(avatar => {
                     avatarsList += `<li class="mb-1">${avatar.name}</li>`;
                 });
                 
                 notification.innerHTML = `
                     <div class="text-xl font-bold mb-2">新頭像解鎖!</div>
                     <div class="text-m mt-2">刷新頁面後在「頭像」頁面查看！</div>
                 `;
                 
                 document.body.appendChild(notification);
                 
                 // 刪除通知
                 setTimeout(() => {
                     notification.remove();
                 }, 4000);
             }
             
             // 更新經驗值顯示
             function updateExpDisplay() {
                 const expBar = document.getElementById('exp-bar');
                 const expText = document.getElementById('exp-text');
                 const userLevel = document.getElementById('user-level');
                 
                 if (expBar && expText && userLevel) {
                     const percentage = userProfile.level >= 100 ? 100 : (userProfile.exp / userProfile.nextLevelExp * 100);
                     expBar.style.width = `${percentage}%`;
                     expText.textContent = userProfile.level >= 100 
                         ? "滿級" 
                         : `${userProfile.exp} / ${userProfile.nextLevelExp}`;
                     userLevel.textContent = `Lv.${userProfile.level}`;
                 }
             }
             
             // 從localStorage加載用戶資料
             function loadUserProfile() {
                 try {
                     const savedProfile = localStorage.getItem('MemoryMaster_userProfile');
                     if (savedProfile) {
                         userProfile = JSON.parse(savedProfile);
                         console.log("加載用戶資料:", userProfile);
                         updateExpDisplay();
                         
                         // 更新顯示的用戶名稱
                         const userNameElement = document.getElementById('user-name');
                         if (userNameElement && userProfile.name) {
                             userNameElement.textContent = userProfile.name;
                         }
                     }
                 } catch (error) {
                     console.error("加載用戶資料出錯:", error);
                 }
             }
             
             // 保存用戶資料到localStorage
             function saveUserProfile() {
                 try {
                     localStorage.setItem('MemoryMaster_userProfile', JSON.stringify(userProfile));
                     console.log("保存用戶資料成功");
                 } catch (error) {
                     console.error("保存用戶資料出錯:", error);
                 }
             }
             
             // 用戶名稱編輯功能
             function initializeNameEditor() {
                 const editNameBtn = document.getElementById('edit-name-btn');
                 const saveNameBtn = document.getElementById('save-name-btn');
                 const cancelNameBtn = document.getElementById('cancel-name-btn');
                 const nameDisplayMode = document.getElementById('name-display-mode');
                 const nameEditMode = document.getElementById('name-edit-mode');
                 const userNameElement = document.getElementById('user-name');
                 const userNameInput = document.getElementById('user-name-input');
                 const charCounter = document.getElementById('char-counter');
                 
                 // 檢查必要元素是否存在
                 if (!editNameBtn || !saveNameBtn || !cancelNameBtn || !nameDisplayMode || !nameEditMode || !userNameElement || !userNameInput || !charCounter) {
                     console.error("用戶名稱編輯器初始化失敗：缺少必要元素");
                     return;
                 }
                 
                 // 更新字符計數器
                 function updateCharCounter() {
                     const currentLength = userNameInput.value.length;
                     const maxLength = userNameInput.maxLength;
                     charCounter.textContent = `${currentLength}/${maxLength}`;
                     
                     // 當接近字符上限時改變計數器顏色
                     if (currentLength >= maxLength) {
                         charCounter.classList.add('text-red-500');
                         charCounter.classList.remove('text-gray-500', 'text-amber-500');
                     } else if (currentLength >= maxLength * 0.75) {
                         charCounter.classList.add('text-amber-500');
                         charCounter.classList.remove('text-gray-500', 'text-red-500');
                     } else {
                         charCounter.classList.add('text-gray-500');
                         charCounter.classList.remove('text-amber-500', 'text-red-500');
                     }
                 }
                 
                 // 編輯按鈕點擊事件
                 editNameBtn.addEventListener('click', function() {
                     // 將目前的用戶名填入輸入框
                     userNameInput.value = userNameElement.textContent;
                     
                     // 更新字符計數
                     updateCharCounter();
                     
                     // 切換到編輯模式
                     nameDisplayMode.classList.add('hidden');
                     nameEditMode.classList.remove('hidden');
                     
                     // 自動聚焦輸入框
                     userNameInput.focus();
                 });
                 
                 // 輸入時更新字符計數
                 userNameInput.addEventListener('input', updateCharCounter);
                 
                 // 保存按鈕點擊事件
                 saveNameBtn.addEventListener('click', function() {
                     // 獲取輸入的新名稱
                     const newName = userNameInput.value.trim();
                     
                     // 名稱不能為空
                     if (newName === '') {
                         alert('用戶名稱不能為空');
                         return;
                     }
                     
                     // 更新用戶名稱
                     userNameElement.textContent = newName;
                     
                     // 更新用戶資料
                     userProfile.name = newName;
                     
                     // 保存到localStorage
                     saveUserProfile();
                     
                     // 切換回顯示模式
                     nameEditMode.classList.add('hidden');
                     nameDisplayMode.classList.remove('hidden');
                     
                     // 顯示成功提示
                     const notification = document.createElement('div');
                     notification.className = 'fixed bottom-5 left-1/2 transform -translate-x-1/2 bg-green-100 text-green-800 py-2 px-4 rounded-lg shadow-lg z-50';
                     notification.innerHTML = '<i class="fas fa-check-circle mr-2"></i>用戶名稱已保存';
                     document.body.appendChild(notification);
                     
                     // 3秒後移除提示
                     setTimeout(() => {
                         notification.remove();
                     }, 3000);
                 });
                 
                 // 取消按鈕點擊事件
                 cancelNameBtn.addEventListener('click', function() {
                     // 不做任何更改，切換回顯示模式
                     nameEditMode.classList.add('hidden');
                     nameDisplayMode.classList.remove('hidden');
                 });
                 
                 // 支持按Enter鍵保存
                 userNameInput.addEventListener('keydown', function(event) {
                     if (event.key === 'Enter') {
                         saveNameBtn.click();
                     } else if (event.key === 'Escape') {
                         cancelNameBtn.click();
                     }
                 });
                 
                 console.log("用戶名稱編輯器初始化完成");
             }
             
             // 初始化本地存儲功能 - 用於記錄用戶成績
             initializeLocalStorage();
             
             // 加載用戶資料
             loadUserProfile();
             
             // 在遊戲初始化時設置按鈕狀態為「未開始」
             updateGameControlButtons('not-started');
             
             // 設置功能初始化
             function initializeSettings() {
                 const settingsButton = document.getElementById('settings-button');
                 const settingsMenu = document.getElementById('settings-menu');
                 const closeSettings = document.getElementById('close-settings');
                 const settingsOptions = document.querySelectorAll('.settings-option');
                 const infoModal = document.getElementById('info-modal');
                 const closeInfoModal = document.getElementById('close-info-modal');
                 const infoModalTitle = document.getElementById('info-modal-title');
                 const infoModalContent = document.getElementById('info-modal-content');
                 
                 if (!settingsButton || !settingsMenu || !closeSettings || !infoModal || !closeInfoModal || !infoModalTitle || !infoModalContent) {
                     console.error('設置相關元素未找到');
                     return;
                 }
                 
                 // 添加設置按鈕狀態控制功能 - 設為全局函數以便在其他地方調用
                 window.disableSettingsButton = function() {
                     settingsButton.classList.add('disabled');
                     settingsButton.style.opacity = '0.5';
                     settingsButton.style.cursor = 'not-allowed';
                     settingsButton.style.pointerEvents = 'none'; // 阻止所有點擊
                 }
                 
                 window.enableSettingsButton = function() {
                     settingsButton.classList.remove('disabled');
                     settingsButton.style.opacity = '1';
                     settingsButton.style.cursor = 'pointer';
                     settingsButton.style.pointerEvents = 'auto';
                 }
                 
                 // 打開設置菜單
                 settingsButton.addEventListener('click', function() {
                     settingsMenu.classList.remove('hidden');
                     // 禁用設置按鈕直到關閉菜單
                     disableSettingsButton();
                 });
                 
                 // 關閉設置菜單並重新啟用設置按鈕
                 closeSettings.addEventListener('click', function() {
                     settingsMenu.classList.add('hidden');
                     enableSettingsButton();
                 });
                 
                 // 點擊背景關閉設置菜單並重新啟用設置按鈕
                 settingsMenu.addEventListener('click', function(e) {
                     if (e.target === settingsMenu) {
                         settingsMenu.classList.add('hidden');
                         enableSettingsButton();
                     }
                 });
                 
                 // 關閉信息模態框時重新啟用設置按鈕
                 closeInfoModal.addEventListener('click', function() {
                     infoModal.classList.add('hidden');
                     enableSettingsButton();
                 });
                 
                 // 點擊背景關閉信息模態框時重新啟用設置按鈕
                 infoModal.addEventListener('click', function(e) {
                     if (e.target === infoModal) {
                         infoModal.classList.add('hidden');
                         enableSettingsButton();
                     }
                 });
                 
                 // 設置選項點擊事件 - 修正版本，附帶調試輸出
                 settingsOptions.forEach(option => {
                     option.addEventListener('click', function() {
                         const section = this.dataset.section;
                         console.log(`點擊了設置選項: ${section}`);
                         
                         try {
                             // 關閉設置菜單
                             settingsMenu.classList.add('hidden');
                             
                             // 確保模態框元素及其內容區域可用
                             if (!infoModal || !infoModalTitle || !infoModalContent) {
                                 console.error("模態框元素未找到:", {
                                     infoModal: !!infoModal,
                                     infoModalTitle: !!infoModalTitle,
                                     infoModalContent: !!infoModalContent
                                 });
                                 alert("系統錯誤：無法顯示信息視窗");
                                 return;
                             }
                             
                             // 根據選項顯示不同內容
                             if (section === 'help') {
                                 // 遊玩說明 - 顯示遊玩說明內容
                                 infoModalTitle.textContent = '遊玩說明';
                                 infoModalContent.innerHTML = `
                                     <div class="space-y-4">
                                         <ol class="list-decimal pl-5 space-y-1">
                                             <li><strong>螢幕將顯示文章背誦進度；</strong></li>
                                             <li><strong>從三個選項中選擇正確答案；</strong></li>
                                             <li><strong>初始擁有3點生命值，每次錯誤扣除1點；</strong></li>
                                             <li><strong>每完成50個字恢復1點生命值（最多3點）；</strong></li>
                                             <li><strong>以最快的時間完成挑戰，爭取獲得成就！</strong></li>
                                         </ol>
                                         <div class="mt-4 p-3 bg-amber-50 dark:bg-amber-900/30 rounded-lg">
                                             <p class="text-amber-800 dark:text-amber-400 font-medium">成就系統：</p>
                                             <ul class="list-disc pl-5 mt-2 text-gray-700 dark:text-gray-300">
                                                 <li><strong>完美無瑕</strong></li>
                                                 <li><strong>閃電俠</strong></li>
                                                 <li><strong>記憶大師</strong></li>
                                                 <li><strong>不知疲倦</strong></li>
                                                 <li><strong>更多隱藏成就！</strong></li>
                                             </ul>
                                         </div>
                                         <p class="mt-2">更多功能，敬請期待！</p>
                                     </div>
                                 `;
                                 infoModal.classList.remove('hidden');
                                 console.log("已顯示遊玩說明");
                                 
                             } else if (section === 'records') {
                                 try {
                                     // 我的記錄 - 顯示用戶的記錄
                                     infoModalTitle.textContent = '我的記錄（只計算完整篇章）';
                                     
                                     // 檢查userRecordsMemory是否已初始化
                                     if (typeof userRecordsMemory !== 'object' || userRecordsMemory === null) {
                                         userRecordsMemory = {};
                                         console.log("在點擊處理函數中初始化userRecordsMemory");
                                     }
                                     
                                     // 檢查displayUserRecords函數是否存在
                                     if (typeof displayUserRecords !== 'function') {
                                         console.error("displayUserRecords函數未定義");
                                         infoModalContent.innerHTML = `
                                             <div class="text-center p-4">
                                                 <i class="fas fa-exclamation-triangle text-amber-500 text-3xl mb-3"></i>
                                                 <p class="text-gray-700 dark:text-gray-300">系統錯誤：無法顯示記錄功能</p>
                                             </div>
                                         `;
                                     } else {
                                         // 先顯示加載訊息
                                         infoModalContent.innerHTML = `
                                             <div class="text-center p-4">
                                                 <i class="fas fa-spinner fa-spin text-amber-500 text-3xl mb-3"></i>
                                                 <p class="text-gray-700 dark:text-gray-300">載入記錄中...</p>
                                             </div>
                                         `;
                                         
                                         // 確保模態框先顯示
                                         infoModal.classList.remove('hidden');
                                         
                                         // 使用setTimeout讓UI先更新，再調用顯示記錄函數
                                         setTimeout(() => {
                                             try {
                                                 displayUserRecords();
                                                 console.log("已顯示用戶記錄");
                                             } catch (err) {
                                                 console.error("顯示記錄時發生錯誤:", err);
                                                 infoModalContent.innerHTML = `
                                                     <div class="text-center p-4">
                                                         <i class="fas fa-exclamation-triangle text-amber-500 text-3xl mb-3"></i>
                                                         <p class="text-gray-700 dark:text-gray-300">載入記錄時發生錯誤</p>
                                                         <p class="text-gray-500 dark:text-gray-400 text-sm mt-2">${err.message}</p>
                                                     </div>
                                                 `;
                                             }
                                         }, 50);
                                     }
                                 } catch (err) {
                                     console.error("處理記錄選項時發生錯誤:", err);
                                     infoModalContent.innerHTML = `
                                         <div class="text-center p-4">
                                             <i class="fas fa-exclamation-triangle text-amber-500 text-3xl mb-3"></i>
                                             <p class="text-gray-700 dark:text-gray-300">處理記錄時發生錯誤</p>
                                             <p class="text-gray-500 dark:text-gray-400 text-sm mt-2">${err.message}</p>
                                         </div>
                                     `;
                                     infoModal.classList.remove('hidden');
                                 }
                                 
                             } else if (section === 'saveload') {
                                 // 保存及載入進度 - 顯示保存及載入進度界面
                                 infoModalTitle.textContent = '保存及載入進度';
                                 infoModalContent.innerHTML = `
                                     <div class="space-y-6">
                                         <div class="bg-gray-50 dark:bg-gray-700/50 rounded-lg p-5">
                                             <h4 class="text-lg font-medium text-amber-700 dark:text-amber-400 mb-3">保存進度</h4>
                                             <p class="text-gray-700 dark:text-gray-300 mb-4">點擊下方按鈕獲取當前進度代碼。保存此代碼以便日後載入進度。</p>
                                             <div class="text-center">
                                                 <button id="generate-save-code-btn" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-opacity-90">
                                                     <i class="fas fa-save mr-2"></i>生成進度代碼
                                                 </button>
                                             </div>
                                             <div id="save-code-container" class="mt-4 hidden">
                                                 <p class="text-gray-600 dark:text-gray-400 text-sm mb-2">您的進度代碼（請保存此代碼）：</p>
                                                 <div class="relative">
                                                     <textarea id="save-code" class="w-full h-24 p-3 bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg text-gray-800 dark:text-gray-200 text-sm font-mono" readonly></textarea>
                                                     <button id="copy-save-code-btn" class="absolute top-2 right-2 p-2 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 rounded-lg text-gray-700 dark:text-gray-300">
                                                         <i class="fas fa-copy"></i>
                                                     </button>
                                                 </div>
                                             </div>
                                         </div>
                                         
                                         <div class="bg-gray-50 dark:bg-gray-700/50 rounded-lg p-5">
                                             <h4 class="text-lg font-medium text-amber-700 dark:text-amber-400 mb-3">載入進度</h4>
                                             <p class="text-gray-700 dark:text-gray-300 mb-4">將保存的進度代碼粘貼到下方輸入框，然後點擊載入按鈕。</p>
                                             <textarea id="load-code-input" class="w-full h-24 p-3 bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-lg text-gray-800 dark:text-gray-200 text-sm font-mono" placeholder="在此處粘貼您的進度代碼..."></textarea>
                                             <div class="text-center mt-4">
                                                 <button id="load-save-code-btn" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-opacity-90">
                                                     <i class="fas fa-upload mr-2"></i>載入進度
                                                 </button>
                                             </div>
                                         </div>
                                         
                                         <div class="p-4 bg-amber-50 dark:bg-amber-900/30 rounded-lg">
                                             <p class="text-amber-800 dark:text-amber-400 font-medium">提示</p>
                                             <ul class="list-disc pl-5 mt-2 text-gray-700 dark:text-gray-300 text-sm space-y-1">
                                                 <li>進度代碼包含您的用戶資料和歷史成就</li>
                                                 <li>載入新進度將覆蓋當前進度，請謹慎操作</li>
                                                 <li>建議定期保存進度，避免資料丟失</li>
                                             </ul>
                                         </div>
                                     </div>
                                 `;
                                 
                                 // 確保模態框先顯示
                                 infoModal.classList.remove('hidden');
                                 
                                 // 使用setTimeout讓UI先更新，再添加事件監聽器
                                 setTimeout(() => {
                                     // 生成進度代碼按鈕點擊事件
                                     const generateSaveCodeBtn = document.getElementById('generate-save-code-btn');
                                     const saveCodeContainer = document.getElementById('save-code-container');
                                     const saveCodeTextarea = document.getElementById('save-code');
                                     const copySaveCodeBtn = document.getElementById('copy-save-code-btn');
                                     
                                     if (generateSaveCodeBtn && saveCodeContainer && saveCodeTextarea) {
                                         generateSaveCodeBtn.addEventListener('click', function() {
                                             try {
                                                 // 收集需要保存的數據
                                                 const saveData = {
                                                     userProfile: userProfile,
                                                     userRecordsMemory: userRecordsMemory,
                                                     globalStats: globalStats,
                                                     userAvatar: userSelectedAvatar,
                                                     selectedAchievements: []
                                                 };
                                                 
                                                 // 嘗試從localStorage獲取已選擇的成就
                                                 try {
                                                     const saved = localStorage.getItem('MemoryMaster_selectedAchievements');
                                                     if (saved) {
                                                         saveData.selectedAchievements = JSON.parse(saved);
                                                     }
                                                 } catch (e) {
                                                     console.error("讀取選擇的成就出錯:", e);
                                                 }
                                                 
                                                 // 將數據轉換為JSON字符串
                                                 const jsonData = JSON.stringify(saveData);
                                                 
                                                 // 使用 UTF-8 安全的 Base64 編碼方式，以支持中文等非 Latin1 字符
                                                 // 通過 encodeURIComponent 先轉換為 URL 編碼，再進行 Base64 編碼
                                                 const encodedData = btoa(encodeURIComponent(jsonData));
                                                 
                                                 // 生成隨機字符前綴和後綴，增加代碼複雜度
                                                 const prefix = Math.random().toString(36).substring(2, 8);
                                                 const suffix = Math.random().toString(36).substring(2, 8);
                                                 
                                                 // 組合最終代碼
                                                 const finalCode = `WY-${prefix}-${encodedData}-${suffix}`;
                                                 
                                                 // 顯示代碼
                                                 saveCodeTextarea.value = finalCode;
                                                 saveCodeContainer.classList.remove('hidden');
                                                 
                                                 // 顯示成功提示
                                                 const notification = document.createElement('div');
                                                 notification.className = 'fixed bottom-5 left-1/2 transform -translate-x-1/2 bg-green-100 text-green-800 py-2 px-4 rounded-lg shadow-lg z-50';
                                                 notification.innerHTML = '<i class="fas fa-check-circle mr-2"></i>進度代碼已生成';
                                                 document.body.appendChild(notification);
                                                 
                                                 // 3秒後移除提示
                                                 setTimeout(() => {
                                                     notification.remove();
                                                 }, 3000);
                                                 
                                             } catch (error) {
                                                 console.error("生成進度代碼時出錯:", error);
                                                 alert("生成進度代碼失敗: " + error.message);
                                             }
                                         });
                                     }
                                     
                                     // 複製進度代碼按鈕點擊事件
                                     if (copySaveCodeBtn && saveCodeTextarea) {
                                         copySaveCodeBtn.addEventListener('click', function() {
                                             // 選中文本
                                             saveCodeTextarea.select();
                                             saveCodeTextarea.setSelectionRange(0, 99999); // 對於移動設備
                                             
                                             try {
                                                 // 複製到剪貼板
                                                 const successful = document.execCommand('copy');
                                                 
                                                 // 顯示成功提示
                                                 const notification = document.createElement('div');
                                                 notification.className = 'fixed bottom-5 left-1/2 transform -translate-x-1/2 bg-green-100 text-green-800 py-2 px-4 rounded-lg shadow-lg z-50';
                                                 notification.innerHTML = '<i class="fas fa-check-circle mr-2"></i>進度代碼已複製到剪貼板';
                                                 document.body.appendChild(notification);
                                                 
                                                 // 3秒後移除提示
                                                 setTimeout(() => {
                                                     notification.remove();
                                                 }, 3000);
                                             } catch (err) {
                                                 console.error("複製文本時出錯:", err);
                                                 alert("複製失敗: " + err.message);
                                             }
                                         });
                                     }
                                     
                                     // 載入進度代碼按鈕點擊事件
                                     const loadSaveCodeBtn = document.getElementById('load-save-code-btn');
                                     const loadCodeInput = document.getElementById('load-code-input');
                                     
                                     if (loadSaveCodeBtn && loadCodeInput) {
                                         loadSaveCodeBtn.addEventListener('click', function() {
                                             try {
                                                 const inputCode = loadCodeInput.value.trim();
                                                 
                                                 if (!inputCode) {
                                                     alert("請輸入進度代碼");
                                                     return;
                                                 }
                                                 
                                                 // 驗證代碼格式
                                                 if (!inputCode.startsWith('WY-') || inputCode.split('-').length < 4) {
                                                     alert("無效的進度代碼格式");
                                                     return;
                                                 }
                                                 
                                                 // 確認用戶是否確實要加載進度
                                                 if (!confirm("載入進度將覆蓋當前所有數據，確定要繼續嗎？")) {
                                                     return;
                                                 }
                                                 
                                                 // 提取編碼部分
                                                 const parts = inputCode.split('-');
                                                 const encodedData = parts.slice(2, -1).join('-');
                                                 
                                                 // 解碼數據 - 先進行 Base64 解碼，再進行 URL 解碼以支持中文等非 Latin1 字符
                                                 const jsonData = decodeURIComponent(atob(encodedData));
                                                 
                                                 // 解析JSON
                                                 const saveData = JSON.parse(jsonData);
                                                 
                                                 // 應用數據
                                                 if (saveData.userProfile) {
                                                     userProfile = saveData.userProfile;
                                                     // 更新UI顯示
                                                     const userNameElement = document.getElementById('user-name');
                                                     if (userNameElement && userProfile.name) {
                                                         userNameElement.textContent = userProfile.name;
                                                     }
                                                     
                                                     // 更新經驗值和等級顯示
                                                     updateExpDisplay();
                                                 }
                                                 
                                                 if (saveData.userRecordsMemory) {
                                                     userRecordsMemory = saveData.userRecordsMemory;
                                                 }
                                                 
                                                 if (saveData.globalStats) {
                                                     globalStats = saveData.globalStats;
                                                 }
                                                 
                                                 if (saveData.userAvatar !== undefined) {
                                                     userSelectedAvatar = saveData.userAvatar;
                                                     // 更新頭像顯示
                                                     const userAvatarElement = document.getElementById('user-avatar');
                                                     if (userAvatarElement) {
                                                         renderUserAvatar(userAvatarElement, userSelectedAvatar);
                                                     }
                                                 }
                                                 
                                                 if (saveData.selectedAchievements) {
                                                     // 更新成就展示
                                                     updateAchievementsDisplay(saveData.selectedAchievements);
                                                 }
                                                 
                                                 // 保存到localStorage
                                                 try {
                                                     localStorage.setItem('MemoryMaster_userProfile', JSON.stringify(userProfile));
                                                     localStorage.setItem('MemoryMaster_userRecords', JSON.stringify(userRecordsMemory));
                                                     localStorage.setItem('MemoryMaster_globalStats', JSON.stringify(globalStats));
                                                     
                                                     if (userSelectedAvatar === null) {
                                                         localStorage.removeItem('MemoryMaster_userAvatar');
                                                     } else {
                                                         localStorage.setItem('MemoryMaster_userAvatar', userSelectedAvatar);
                                                     }
                                                     
                                                     localStorage.setItem('MemoryMaster_selectedAchievements', JSON.stringify(saveData.selectedAchievements || []));
                                                 } catch (e) {
                                                     console.error("保存數據到localStorage時出錯:", e);
                                                 }
                                                 
                                                 // 顯示成功提示
                                                 const notification = document.createElement('div');
                                                 notification.className = 'fixed bottom-5 left-1/2 transform -translate-x-1/2 bg-green-100 text-green-800 py-2 px-4 rounded-lg shadow-lg z-50';
                                                 notification.innerHTML = '<i class="fas fa-check-circle mr-2"></i>進度已成功載入';
                                                 document.body.appendChild(notification);
                                                 
                                                 // 3秒後移除提示
                                                 setTimeout(() => {
                                                     notification.remove();
                                                 }, 3000);
                                                 
                                                 // 關閉模態框
                                                 infoModal.classList.add('hidden');
                                                 
                                                 // 在載入進度後，稍微延遲刷新頁面
                                                 setTimeout(() => {
                                                     window.location.reload();
                                                 }, 2000);
                                                 
                                             } catch (error) {
                                                 console.error("載入進度代碼時出錯:", error);
                                                 alert("載入進度失敗: " + error.message);
                                             }
                                         });
                                     }
                                 }, 100);
                                 
                             } else if (section === 'version') {
                                 // 版本資訊 - 顯示版本更新內容
                                 infoModalTitle.textContent = '版本資訊（只顯示主要更新）';
                                 infoModalContent.innerHTML = `
                                     <div class="space-y-4">
         
                                         <div class="p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                                             <h4 class="text-lg font-medium text-primary mb-3">v1.5 更新資訊（重大更新！）</h4>
                                             <ul class="list-disc pl-4 text-gray-700 dark:text-gray-300 space-y-2">
                                                 <li>新增雙人競技模式！</li>
                                                 <li>新增保存及載入進度功能！轉換裝置無煩惱！</li>
                                                 <li>調整經驗獲取公式！遊戲失敗也可獲得經驗！</li>
                                                 <li>稍微加快遊戲節奏。</li>
                                             </ul>
                                         </div>

                                         <div class="p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                                             <h4 class="text-lg font-medium text-primary mb-3">v1.4 更新資訊</h4>
                                             <ul class="list-disc pl-4 text-gray-700 dark:text-gray-300 space-y-2">
                                                 <li>新增頭像</li>
                                                 <li>減少升級所需經驗，調整部分成就條件</li>
                                                 <li>完善成就設計及展示功能</li>
                                                 <li>添加更多篇章</li>
                                             </ul>
                                         </div>
                                         
                                         <div class="p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                                             <h4 class="text-lg font-medium text-primary mb-3">v1.3 更新資訊</h4>
                                             <ul class="list-disc pl-4 text-gray-700 dark:text-gray-300 space-y-2">
                                                 <li>添加本地儲存功能，儲存用戶資料和成就</li>
                                                 <li>記錄功能改進：只在完成全文時才計入記錄</li>
                                                 <li>修復已知問題，提升遊戲穩定性</li>
                                             </ul>
                                         </div>
         
                                         <div class="p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                                             <h4 class="text-lg font-medium text-primary mb-3">v1.2 更新資訊</h4>
                                             <ul class="list-disc pl-5 text-gray-700 dark:text-gray-300 space-y-2">
                                                 <li>新增設置中心，包含遊玩說明、記錄和成就查詢、版本資訊等</li>
                                                 <li>新增用戶記錄功能，可查看各篇章通關次數和最佳成績</li>
                                                 <li>新增若干成就</li>
                                                 <li>改善遊戲介面，提升視覺效果和用戶體驗</li>
                                                 <li>修復已知問題，提升遊戲穩定性</li>
                                             </ul>
                                         </div>
                                         
                                         <div class="p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                                             <h4 class="text-lg font-medium text-primary mb-3">v1.1 更新資訊</h4>
                                             <ul class="list-disc pl-5 text-gray-700 dark:text-gray-300 space-y-2">
                                                 <li>新增暫停功能</li>
                                                 <li>新增多種成就獎勵</li>
                                                 <li>改善選擇篇章界面</li>
                                                 <li>新增生命恢復機制</li>
                                             </ul>
                                         </div>
                                         
                                         <div class="p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                                             <h4 class="text-lg font-medium text-primary mb-3">v1.0 初始版本</h4>
                                             <ul class="list-disc pl-5 text-gray-700 dark:text-gray-300 space-y-2">
                                                 <li>基礎遊戲功能上線</li>
                                                 <li>支持多篇文言文背誦</li>
                                                 <li>支持分段練習</li>
                                             </ul>
                                         </div>
                                         
                                     </div>
                                 `;
                                 infoModal.classList.remove('hidden');
                                 console.log("已顯示版本資訊");
                                 
                             } else if (section === 'achievements') {
                                 // 顯示歷史成就
                                 infoModalTitle.textContent = '歷史成就';
                                 
                                 // 確保顯示成就函數已定義
                                 if (typeof displayAchievements !== 'function') {
                                     console.error("displayAchievements函數未定義");
                                     infoModalContent.innerHTML = `
                                         <div class="text-center p-4">
                                             <i class="fas fa-exclamation-triangle text-amber-500 text-3xl mb-3"></i>
                                             <p class="text-gray-700 dark:text-gray-300">系統錯誤：無法顯示成就功能</p>
                                         </div>
                                     `;
                                 } else {
                                     // 先顯示加載訊息
                                     infoModalContent.innerHTML = `
                                         <div class="text-center p-4">
                                             <i class="fas fa-spinner fa-spin text-amber-500 text-3xl mb-3"></i>
                                             <p class="text-gray-700 dark:text-gray-300">載入成就中...</p>
                                         </div>
                                     `;
                                     
                                     // 確保模態框先顯示
                                     infoModal.classList.remove('hidden');
                                     
                                     // 使用setTimeout讓UI先更新，再調用顯示成就函數
                                     setTimeout(() => {
                                         try {
                                             displayAchievements();
                                             console.log("已顯示歷史成就");
                                         } catch (err) {
                                             console.error("顯示成就時發生錯誤:", err);
                                             infoModalContent.innerHTML = `
                                                 <div class="text-center p-4">
                                                     <i class="fas fa-exclamation-triangle text-amber-500 text-3xl mb-3"></i>
                                                     <p class="text-gray-700 dark:text-gray-300">載入成就時發生錯誤</p>
                                                     <p class="text-gray-500 dark:text-gray-400 text-sm mt-2">${err.message}</p>
                                                 </div>
                                             `;
                                         }
                                     }, 50);
                                 }
                             } else if (section === 'about') {
                                 // 關於製作者 - 顯示製作者相關信息
                                 infoModalTitle.textContent = '關於製作者';
                                 infoModalContent.innerHTML = `
                                     <div class="space-y-4">
                                         <div class="flex flex-col items-center mb-4">
                                             <div class="w-20 h-20 bg-amber-100 dark:bg-amber-800 rounded-full flex items-center justify-center text-2xl text-amber-800 dark:text-amber-100 mb-2">
                                                 <i class="fas fa-user"></i>
                                             </div>
                                             <h3 class="text-lg font-medium">IG：@dse.chinese.meme</h3>
                                             <p class="text-gray-500 dark:text-gray-400 text-sm">瀝源邨校 中文科老師</p>
                                         </div>
                                         
                                         <p class="text-gray-700 dark:text-gray-300">
                                             最近沉迷用POE製作教學工具。早前跟同事展示文言文翻譯bot時，有同事提了一句：「我們是不是讓學習文言文變得枯燥了？」我驀然想起《範文爭霸戰》，一款我中學時風靡一時，卻不知何時消失於歷史的遊戲。於是，我用相同的概念做了《文言大師之旅》。
                                         </p>
                                         
                                         <p class="text-gray-700 dark:text-gray-300">
                                             知之者不如好之者，好之者不如樂之者。我想，如果熱愛一件事，總能把它做好的。
                                         </p>
                                         
                                         <div class="mt-4 p-3 bg-gray-50 dark:bg-gray-700/50 rounded-lg">
                                             <p class="text-gray-600 dark:text-gray-400 text-sm text-center">
                                                 沒什麼事情是做不到的，除了數學。
                                             </p>
                                         </div>
                                     </div>
                                 `;
                                 infoModal.classList.remove('hidden');
                                 console.log("已顯示關於製作者");
                             }
                         } catch (err) {
                             console.error("設置選項點擊處理發生錯誤:", err);
                             alert("發生錯誤，請檢查控制台以獲取詳細信息");
                         }
                     });
                 });
             }
             
             // 初始化本地存儲功能
             function initializeLocalStorage() {
                 console.log("初始化本地存儲功能...");
                 
                 // 首先檢查瀏覽器是否支持localStorage
                 try {
                     // 進行測試寫入和讀取以確認localStorage可用性
                     localStorage.setItem('test', 'test');
                     if (localStorage.getItem('test') !== 'test') {
                         throw new Error("localStorage讀寫測試失敗");
                     }
                     localStorage.removeItem('test');
                     console.log("localStorage可用性測試通過");
                 } catch (e) {
                     console.error("localStorage不可用:", e);
                     // 儲存功能不可用時繼續使用內存存儲
                     userRecordsMemory = {};
                     initializeDefaultStats();
                     alert("注意：本地儲存功能不可用，您的記錄將不會被保存。可能原因：私隱模式瀏覽或瀏覽器限制。");
                     return;
                 }
                 
                 try {
                     // 從localStorage載入用戶記錄
                     let rawUserRecords = localStorage.getItem('MemoryMaster_userRecords');
                     // 關鍵點：修正了localStorage的鍵名，添加了應用前綴避免命名衝突
                     
                     console.log("原始用戶記錄數據:", rawUserRecords);
                     
                     if (rawUserRecords) {
                         try {
                             userRecordsMemory = JSON.parse(rawUserRecords);
                             console.log("解析後的用戶記錄:", userRecordsMemory);
                             console.log("從localStorage載入記錄成功:", Object.keys(userRecordsMemory).length, "個記錄");
                         } catch (e) {
                             console.error("解析userRecords時出錯:", e);
                             console.log("無效的JSON格式:", rawUserRecords);
                             userRecordsMemory = {};
                             localStorage.setItem('MemoryMaster_userRecords', JSON.stringify({}));
                         }
                     } else {
                         console.log("未找到現有記錄，創建新的空記錄");
                         userRecordsMemory = {};
                         localStorage.setItem('MemoryMaster_userRecords', JSON.stringify({}));
                         console.log("初始化userRecords本地存儲");
                     }
                     
                     // 從localStorage載入全局統計數據
                     let rawGlobalStats = localStorage.getItem('MemoryMaster_globalStats');
                     console.log("原始全局統計數據:", rawGlobalStats);
                     
                     if (rawGlobalStats) {
                         try {
                             globalStats = JSON.parse(rawGlobalStats);
                             console.log("解析後的全局統計:", globalStats);
                             console.log("從localStorage載入統計數據成功");
                         } catch (e) {
                             console.error("解析globalStats時出錯:", e);
                             console.log("無效的JSON格式:", rawGlobalStats);
                             initializeDefaultStats();
                         }
                     } else {
                         console.log("未找到現有全局統計，創建默認統計數據");
                         initializeDefaultStats();
                         console.log("初始化globalStats本地存儲");
                     }
                     
                     // 立即保存一次，確認數據能夠正確寫入
                     saveStats(true);
                 } catch (error) {
                     console.error("載入本地存儲數據時出錯:", error);
                     // 初始化默認數據
                     userRecordsMemory = {};
                     initializeDefaultStats();
                 }
             }
             
             // 初始化默認統計數據
             function initializeDefaultStats() {
                 console.log("初始化默認統計數據");
                 globalStats = {
                     totalCompletionCount: 0,
                     failAfterHalfwayCount: 0,
                     lightningAchievementCount: 0,
                     perfectAchievementCount: 0,
                     memoryAchievementCount: 0,
                     tirelessAchievementCount: 0,
                     nightOwlAchievementCount: 0,
                     badDigestionAchievementCount: 0,
                     // 記錄各分類篇章完成情況
                     specifiedTextCompletions: {}, // 指定文言篇章完成次數
                     literatureCompletions: {},   // 文學篇章完成次數
                     achievements: {
                         nightOwl: false,
                         badDigestion: false,
                         dryEyes: false,
                         nightOwlKing: false,
                         focusOnEating: false,
                         adventureLevel: 0,
                         defeatLevel: 0,
                         speedRouteLevel: 0,
                         perfectRouteLevel: 0,
                         memoryRouteLevel: 0,
                         specifiedTextRouteLevel: 0, // 指定文言篇章大師之路
                         literatureRouteLevel: 0     // 文學冒險者之路
                     }
                 };
                 
                 try {
                     localStorage.setItem('MemoryMaster_globalStats', JSON.stringify(globalStats));
                     console.log("默認統計數據已保存到localStorage");
                 } catch (e) {
                     console.error("保存默認統計數據時出錯:", e);
                 }
             }
             
             // 保存統計數據到localStorage
             function saveStats(isInitial = false) {
                 if (!isInitial) {
                     console.log("保存統計數據到localStorage...");
                 }
                 
                 // 測試localStorage可用性
                 try {
                     localStorage.setItem('test', 'test');
                     localStorage.removeItem('test');
                 } catch (e) {
                     console.error("localStorage不可用，無法保存數據:", e);
                     return false;
                 }
                 
                 try {
                     // 將要保存的數據轉為JSON字符串
                     const userRecordsJson = JSON.stringify(userRecordsMemory);
                     const globalStatsJson = JSON.stringify(globalStats);
                     
                     // 檢查數據大小是否超過瀏覽器限制(通常約5MB)
                     const totalSize = userRecordsJson.length + globalStatsJson.length;
                     if (totalSize > 4 * 1024 * 1024) { // 4MB警告閾值
                         console.warn("數據大小接近localStorage限制:", totalSize, "bytes");
                     }
                     
                     // 保存用戶記錄和全局統計
                     localStorage.setItem('MemoryMaster_userRecords', userRecordsJson);
                     localStorage.setItem('MemoryMaster_globalStats', globalStatsJson);
                     
                     // 驗證保存是否成功
                     const savedUserRecords = localStorage.getItem('MemoryMaster_userRecords');
                     const savedGlobalStats = localStorage.getItem('MemoryMaster_globalStats');
                     
                     if (savedUserRecords !== userRecordsJson || savedGlobalStats !== globalStatsJson) {
                         console.error("數據驗證失敗，保存的數據與原始數據不一致");
                         return false;
                     }
                     
                     if (!isInitial) {
                         console.log("數據已成功保存並驗證");
                     }
                     return true;
                 } catch (error) {
                     console.error("保存數據到localStorage時出錯:", error);
                     return false;
                 }
             }
             
             // 顯示用戶記錄 - 改良版 (包含未完成篇章)
             function displayUserRecords() {
                 const infoModalContent = document.getElementById('info-modal-content');
                 if (!infoModalContent) return;
                 
                 // 使用內存中的記錄
                 const hasRecords = Object.keys(userRecordsMemory).length > 0;
                 
                 // 定義分類順序
                 const categoryOrder = ['中一', '中二', '中三', '指定文言', '文學', '其他'];
                 
                 // 分類選擇器
                 let recordsHTML = `
                 <div class="mb-6">
                     <div class="flex items-center justify-between mb-3">
                         <h4 class="text-lg font-medium text-amber-800 dark:text-amber-400">按分類查看</h4>
                     </div>
                     <div class="flex flex-wrap gap-2">
                         <button class="category-filter py-1 px-3 bg-primary text-white rounded-lg hover:bg-opacity-90 text-sm" data-category="all">全部</button>
                 `;
                 
                 // 分類所有篇章，包括尚未完成的
                 const categorizedPassages = {};
                 
                 // 先將所有篇章按分類整理
                 Object.keys(passages).forEach(passageKey => {
                     const passage = passages[passageKey];
                     const category = passage.category || '其他';
                     
                     if (!categorizedPassages[category]) {
                         categorizedPassages[category] = [];
                     }
                     
                     // 檢查是否有記錄
                     const record = userRecordsMemory[passageKey] || null;
                     
                     categorizedPassages[category].push({
                         passageKey,
                         title: passage.title,
                         author: passage.author,
                         category: category,
                         record: record,
                         hasRecord: !!record
                     });
                 });
                 
                 // 為每個有篇章的分類創建篩選按鈕
                 categoryOrder.forEach(category => {
                     if (categorizedPassages[category] && categorizedPassages[category].length > 0) {
                         recordsHTML += `
                             <button class="category-filter py-1 px-3 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 text-sm" data-category="${category}">
                                 ${category}
                             </button>
                         `;
                     }
                 });
                 
                 recordsHTML += `</div></div>`;
                 
                 // 如果完全沒有篇章記錄
                 if (Object.keys(categorizedPassages).length === 0) {
                     recordsHTML += `
                         <div class="text-center p-4">
                             <i class="fas fa-info-circle text-amber-500 text-3xl mb-3"></i>
                             <p class="text-gray-700 dark:text-gray-300">尚未加載任何篇章</p>
                         </div>
                     `;
                     infoModalContent.innerHTML = recordsHTML;
                     return;
                 }
                 
                 recordsHTML += `<div class="space-y-4 records-container">`;
                 
                 // 按照預定義順序處理分類
                 categoryOrder.forEach(category => {
                     if (categorizedPassages[category] && categorizedPassages[category].length > 0) {
                         recordsHTML += `
                             <div class="category-section mb-4" data-category="${category}">
                                 <h4 class="text-lg font-medium text-amber-800 dark:text-amber-400 mb-2">${category}</h4>
                                 <div class="bg-gray-50 dark:bg-gray-700/50 rounded-lg overflow-hidden">
                         `;
                         
                         // 對該分類中的所有篇章按標題排序
                         categorizedPassages[category].sort((a, b) => {
                             if (a.title < b.title) return -1;
                             if (a.title > b.title) return 1;
                             return 0;
                         });
                         
                         // 生成該分類下的所有篇章記錄 (包括未完成的)
                         categorizedPassages[category].forEach((item, index) => {
                             // 判斷是否有記錄
                             if (item.hasRecord) {
                                 // 格式化最佳時間
                                 let bestTimeFormatted = "未有記錄";
                                 if (item.record.bestTime) {
                                     const minutes = Math.floor(item.record.bestTime / 60);
                                     const seconds = (item.record.bestTime % 60).toFixed(1);
                                     bestTimeFormatted = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(4, '0')}`;
                                 }
                                 
                                 recordsHTML += `
                                     <div class="p-3 ${index > 0 ? 'border-t border-gray-200 dark:border-gray-600' : ''}">
                                         <div class="flex justify-between items-start">
                                             <div>
                                                 <p class="font-medium text-gray-800 dark:text-gray-200">${item.title}</p>
                                                 <p class="text-sm text-gray-500 dark:text-gray-400">${item.author}</p>
                                             </div>
                                             <div class="text-right">
                                                 <p class="text-gray-700 dark:text-gray-300">完成：<span class="font-medium">${item.record.completionCount || 0}</span> 次</p>
                                                 <p class="text-gray-700 dark:text-gray-300">最佳：<span class="font-medium">${bestTimeFormatted}</span></p>
                                             </div>
                                         </div>
                                     </div>
                                 `;
                             } else {
                                 // 顯示未完成的篇章
                                 recordsHTML += `
                                     <div class="p-3 ${index > 0 ? 'border-t border-gray-200 dark:border-gray-600' : ''} bg-gray-50 dark:bg-gray-800/30">
                                         <div class="flex justify-between items-start">
                                             <div>
                                                 <p class="font-medium text-gray-600 dark:text-gray-400">${item.title}</p>
                                                 <p class="text-sm text-gray-500 dark:text-gray-500">${item.author}</p>
                                             </div>
                                             <div class="text-right">
                                                 <p class="text-amber-600 dark:text-amber-500 italic text-sm">未有記錄</p>
                                             </div>
                                         </div>
                                     </div>
                                 `;
                             }
                         });
                         
                         recordsHTML += `</div></div>`;
                     }
                 });
                 
                 recordsHTML += `</div>`;
                 
                 infoModalContent.innerHTML = recordsHTML;
                 
                 // 為分類篩選按鈕添加事件監聽器
                 setTimeout(() => {
                     const categoryFilters = infoModalContent.querySelectorAll('.category-filter');
                     const categorySections = infoModalContent.querySelectorAll('.category-section');
                     
                     categoryFilters.forEach(filter => {
                         filter.addEventListener('click', function() {
                             // 移除所有按鈕的高亮樣式
                             categoryFilters.forEach(btn => {
                                 btn.classList.remove('bg-primary', 'text-white');
                                 btn.classList.add('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800', 'dark:text-gray-200');
                             });
                             
                             // 高亮當前選中的按鈕
                             this.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800', 'dark:text-gray-200');
                             this.classList.add('bg-primary', 'text-white');
                             
                             // 獲取選中的分類
                             const selectedCategory = this.dataset.category;
                             
                             // 顯示/隱藏相應的分類板塊
                             if (selectedCategory === 'all') {
                                 // 顯示所有分類
                                 categorySections.forEach(section => {
                                     section.style.display = 'block';
                                 });
                             } else {
                                 // 只顯示選中的分類
                                 categorySections.forEach(section => {
                                     if (section.dataset.category === selectedCategory) {
                                         section.style.display = 'block';
                                     } else {
                                         section.style.display = 'none';
                                     }
                                 });
                             }
                         });
                     });
                     
                     // 默認選中"全部"按鈕
                     const allFilter = infoModalContent.querySelector('.category-filter[data-category="all"]');
                     if (allFilter) {
                         allFilter.click();
                     }
                 }, 100);
             }
             
             // 完全移除重複的宣告和對象定義，因為這些已經在前面定義過了
             
             // 記錄通關成績
             function recordCompletionStats(passageKey, completionTime, isFullPassage) {
                 // 只記錄完整篇章的成績
                 if (!isFullPassage) {
                     console.log("非完整篇章，不記錄成績");
                     return;
                 }
                 
                 try {
                     // 確保userRecordsMemory已初始化
                     if (typeof userRecordsMemory !== 'object' || userRecordsMemory === null) {
                         userRecordsMemory = {};
                         console.log("初始化userRecordsMemory");
                     }
                     
                     // 確保globalStats已初始化
                     if (typeof globalStats !== 'object' || globalStats === null) {
                         initializeDefaultStats();
                     }
                     
                     // 確保分類完成情況記錄已初始化
                     if (!globalStats.specifiedTextCompletions) {
                         globalStats.specifiedTextCompletions = {};
                     }
                     if (!globalStats.literatureCompletions) {
                         globalStats.literatureCompletions = {};
                     }
                     
                     // 更新記錄
                     if (!userRecordsMemory[passageKey]) {
                         userRecordsMemory[passageKey] = {
                             completionCount: 0,
                             bestTime: null
                         };
                     }
                     
                     // 增加完成次數
                     userRecordsMemory[passageKey].completionCount = (userRecordsMemory[passageKey].completionCount || 0) + 1;
                     
                     // 更新全局完成次數
                     globalStats.totalCompletionCount = (globalStats.totalCompletionCount || 0) + 1;
                     
                     // 獲取當前篇章資訊
                     const passage = passages[passageKey];
                     if (passage) {
                         const category = passage.category || '其他';
                         
                         // 更新分類完成統計
                         if (category === '指定文言') {
                             if (!globalStats.specifiedTextCompletions[passageKey]) {
                                 globalStats.specifiedTextCompletions[passageKey] = 0;
                             }
                             globalStats.specifiedTextCompletions[passageKey]++;
                             
                             // 檢查更新指定文言篇章大師之路成就等級
                             updateSpecifiedTextAchievement();
                         } else if (category === '文學') {
                             if (!globalStats.literatureCompletions[passageKey]) {
                                 globalStats.literatureCompletions[passageKey] = 0;
                             }
                             globalStats.literatureCompletions[passageKey]++;
                             
                             // 檢查更新文學冒險者之路成就等級
                             updateLiteratureAchievement();
                         }
                     }
                     
                     // 更新冒險之路成就
                     if (globalStats.totalCompletionCount >= 300 && globalStats.achievements.adventureLevel < 5) {
                         globalStats.achievements.adventureLevel = 5; // 掃地僧
                     } else if (globalStats.totalCompletionCount >= 150 && globalStats.achievements.adventureLevel < 4) {
                         globalStats.achievements.adventureLevel = 4; // 偏執狂
                     } else if (globalStats.totalCompletionCount >= 50 && globalStats.achievements.adventureLevel < 3) {
                         globalStats.achievements.adventureLevel = 3; // 大師
                     } else if (globalStats.totalCompletionCount >= 10 && globalStats.achievements.adventureLevel < 2) {
                         globalStats.achievements.adventureLevel = 2; // 勇者
                     } else if (globalStats.totalCompletionCount >= 1 && globalStats.achievements.adventureLevel < 1) {
                         globalStats.achievements.adventureLevel = 1; // 初心者
                     }
                     
                     // 檢查特殊時間成就
                     const now = new Date();
                     const hours = now.getHours();
                     const minutes = now.getMinutes();
                     
                     // 判斷夜貓成就 (01:00-03:00)
                     if (hours >= 1 && hours < 3) {
                         globalStats.achievements.nightOwl = true;
                         
                         // 增加獲得夜貓成就次數
                         globalStats.nightOwlAchievementCount = (globalStats.nightOwlAchievementCount || 0) + 1;
                         
                         // 檢查是否達成「夜貓王」成就（獲得夜貓20次）
                         if (globalStats.nightOwlAchievementCount >= 20 && !globalStats.achievements.nightOwlKing) {
                             globalStats.achievements.nightOwlKing = true;
                             console.log("獲得獨立成就：夜貓王（獲得夜貓20次）");
                         }
                     }
                     
                     // 判斷腸胃不好成就 (11:59-12:45)
                     if ((hours == 11 && minutes >= 59) || (hours == 12 && minutes <= 45)) {
                         globalStats.achievements.badDigestion = true;
                         
                         // 增加獲得腸胃不好成就次數
                         globalStats.badDigestionAchievementCount = (globalStats.badDigestionAchievementCount || 0) + 1;
                         
                         // 檢查是否達成「請專心吃飯」成就（獲得腸胃不好20次）
                         if (globalStats.badDigestionAchievementCount >= 20 && !globalStats.achievements.focusOnEating) {
                             globalStats.achievements.focusOnEating = true;
                             console.log("獲得獨立成就：請專心吃飯（獲得腸胃不好20次）");
                         }
                     }
                     
                     // 更新最佳時間（如果比現有記錄更好或沒有記錄）
                     if (userRecordsMemory[passageKey].bestTime === null || completionTime < userRecordsMemory[passageKey].bestTime) {
                         userRecordsMemory[passageKey].bestTime = completionTime;
                     }
                     
                     // 保存更新後的數據到localStorage
                     saveStats();
                     
                     console.log(`更新記錄：${passageKey}，完成次數: ${userRecordsMemory[passageKey].completionCount}, 最佳時間: ${userRecordsMemory[passageKey].bestTime}`);
                     console.log("當前記錄數據：", JSON.stringify(userRecordsMemory));
                     console.log("全局統計：", JSON.stringify(globalStats));
                 } catch (e) {
                     console.error('記錄成績時發生錯誤', e);
                 }
             }
             
             // 檢查並更新指定文言篇章大師之路成就
             function updateSpecifiedTextAchievement() {
                 // 要求的完成次數對應每個等級
                 const requirements = [1, 3, 10, 20];
                 
                 // 獲取所有指定文言類別的篇章
                 const specifiedTextPassages = Object.keys(passages).filter(key => 
                     passages[key].category === '指定文言'
                 );
                 
                 // 如果沒有指定文言篇章，則退出
                 if (specifiedTextPassages.length === 0) return;
                 
                 // 獲取每個指定文言篇章的完成次數
                 const completionCounts = specifiedTextPassages.map(key => 
                     globalStats.specifiedTextCompletions[key] || 0
                 );
                 
                 // 找出最小完成次數（所有篇章中完成次數最少的）
                 const minCompletions = Math.min(...completionCounts);
                 
                 // 更新成就等級
                 for (let i = requirements.length - 1; i >= 0; i--) {
                     if (minCompletions >= requirements[i]) {
                         // 所有篇章至少都完成了這個等級的要求次數
                         if (globalStats.achievements.specifiedTextRouteLevel < i + 1) {
                             globalStats.achievements.specifiedTextRouteLevel = i + 1;
                             console.log(`更新指定文言篇章大師之路成就等級: ${i + 1}`);
                         }
                         break;
                     }
                 }
             }
             
             // 檢查並更新文學冒險者之路成就
             function updateLiteratureAchievement() {
                 // 要求的完成次數對應每個等級
                 const requirements = [1, 3, 10, 20];
                 
                 // 獲取所有文學類別的篇章
                 const literaturePassages = Object.keys(passages).filter(key => 
                     passages[key].category === '文學'
                 );
                 
                 // 如果沒有文學篇章，則退出
                 if (literaturePassages.length === 0) return;
                 
                 // 獲取每個文學篇章的完成次數
                 const completionCounts = literaturePassages.map(key => 
                     globalStats.literatureCompletions[key] || 0
                 );
                 
                 // 找出最小完成次數（所有篇章中完成次數最少的）
                 const minCompletions = Math.min(...completionCounts);
                 
                 // 更新成就等級
                 for (let i = requirements.length - 1; i >= 0; i--) {
                     if (minCompletions >= requirements[i]) {
                         // 所有篇章至少都完成了這個等級的要求次數
                         if (globalStats.achievements.literatureRouteLevel < i + 1) {
                             globalStats.achievements.literatureRouteLevel = i + 1;
                             console.log(`更新文學冒險者之路成就等級: ${i + 1}`);
                         }
                         break;
                     }
                 }
             }
             
             // 顯示歷史成就
         function displayAchievements() {
         const infoModalContent = document.getElementById('info-modal-content');
         if (!infoModalContent) return;
         
         // 確保globalStats已初始化
         if (typeof globalStats !== 'object' || globalStats === null) {
         initializeDefaultStats();
         }
         
         // 創建SVG徽章
         const createAchievementSVG = (colors, borderColor) => {
         const uniqueId = 'seal_' + Math.random().toString(36).substr(2, 9);
         return `
         <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
             <defs>
                 <radialGradient id="${uniqueId}" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                     <stop offset="0%" style="stop-color:${colors.center}" />
                     <stop offset="70%" style="stop-color:${colors.middle}" />
                     <stop offset="100%" style="stop-color:${colors.outer}" />
                 </radialGradient>
             </defs>
             <circle cx="50" cy="50" r="45" fill="url(#${uniqueId})" />
             <circle cx="50" cy="50" r="42" fill="none" stroke="${borderColor}" stroke-width="1" stroke-dasharray="2,1" />
             <circle cx="50" cy="50" r="38" fill="none" stroke="${borderColor}" stroke-width="0.5" />
         </svg>
         `;
         };
         
         // 各成就顏色定義
         // 冒險之路成就顏色
         const adventureColors = [
         { center: '#B3E5FC', middle: '#4FC3F7', outer: '#0288D1' }, // 初心者
         { center: '#EF5350', middle: '#E53935', outer: '#C62828' }, // 勇者
         { center: '#FFD54F', middle: '#FFC107', outer: '#FFA000' }, // 大師
         { center: '#BA68C8', middle: '#AB47BC', outer: '#8E24AA' }, // 偏執狂
         { center: '#A5D6A7', middle: '#81C784', outer: '#4CAF50' }  // 掃地僧
         ];
         
         // 挫敗之路成就顏色
         const defeatColors = [
         { center: '#D7CCC8', middle: '#8D6E63', outer: '#4E342E' }, // 初嘗敗績
         { center: '#E3F2FD', middle: '#90CAF9', outer: '#1565C0' }, // 堅毅
         { center: '#80DEEA', middle: '#26A69A', outer: '#004D40' }, // 鋼鐵意志
         { center: '#FFE0B2', middle: '#FFB74D', outer: '#E65100' }, // 小強是我
         { center: '#E0F7FA', middle: '#80DEEA', outer: '#00838F' }  // 心如止水
         ];
         
         // 極速之路成就顏色
         const speedColors = [
         { center: '#FF5252', middle: '#D50000', outer: '#B71C1C' }, // 敏捷
         { center: '#FF9800', middle: '#F57C00', outer: '#E65100' }, // 肌肉記憶
         { center: '#00B4D8', middle: '#0096C7', outer: '#023E8A' }, // 無影手
         { center: '#FFEE58', middle: '#FFD600', outer: '#F9A825' }  // 世界第一束光
         ];
         
         // 完美之路成就顏色
         const perfectColors = [
         { center: '#80CBC4', middle: '#4DB6AC', outer: '#E8F5E9' }, // 如沐春風
         { center: '#F06292', middle: '#EC407A', outer: '#AD1457' }, // 完美主義
         { center: '#FFD54F', middle: '#FFB300', outer: '#5D4037' }, // 滿月
         { center: '#B39DDB', middle: '#7E57C2', outer: '#4527A0' }  // 至善
         ];
         
         // 記憶之路成就顏色
         const memoryColors = [
         { center: '#00E5FF', middle: '#00B8D4', outer: '#006064' }, // 激活腦細胞
         { center: '#FFD54F', middle: '#FFB300', outer: '#F57F17' }, // 記憶麵包
         { center: '#5C6BC0', middle: '#3949AB', outer: '#283593' }, // 移動圖書館
         { center: '#26C6DA', middle: '#00ACC1', outer: '#00838F' }  // 流如背倒
         ];
         
         // 特殊累積成就顏色
         const dryEyesColors = { center: '#FFCC80', middle: '#FFA726', outer: '#EF6C00' }; // 眼乾
         const nightOwlKingColors = { center: '#5D4037', middle: '#3E2723', outer: '#1B0000' }; // 夜貓王
         const focusOnEatingColors = { center: '#FFFFFF', middle: '#FFD0B0', outer: '#FF8A65' }; // 請專心吃飯
         
         let contentHTML = `
         <div class="space-y-6">
         <!-- 冒險之路成就 -->
         <div>
             <h4 class="text-xl font-bold text-amber-700 dark:text-amber-400 mb-4">冒險之路（只計算完整篇章）</h4>
             <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-5">
         `;
         
         // 冒險之路成就等級名稱
         const adventureLevels = ['初心者', '勇者', '大師', '偏執狂', '掃地僧'];
         const adventureRequirements = [1, 10, 50, 150, 300];
         const adventureBorderColors = ['#90CAF9', '#4CAF50', '#F4511E', '#673AB7', '#FFC107'];
         
         // 當前冒險等級
         const currentLevel = globalStats.achievements.adventureLevel;
         
         // 如果已經達成任何等級
         if (currentLevel > 0) {
         // 顯示當前等級成就
         const levelIndex = currentLevel - 1;
         contentHTML += `
             <div class="flex items-center mb-6">
                 <div class="achievement-seal" style="width: 110px; height: 110px;">
                     ${createAchievementSVG(adventureColors[levelIndex], adventureBorderColors[levelIndex])}
                     <div class="seal-text">
                         <span class="seal-title text-lg">${adventureLevels[levelIndex]}</span>
                         <span class="seal-desc">完成${adventureRequirements[levelIndex]}次</span>
                     </div>
                 </div>
                 <div class="ml-5">
                     <p class="text-lg font-bold text-gray-800 dark:text-gray-200">目前等級：${adventureLevels[levelIndex]}</p>
                     <p class="text-gray-600 dark:text-gray-400">總完成次數：${globalStats.totalCompletionCount}</p>
         `;
         
         // 如果還有下一等級，顯示進度
         if (currentLevel < 5) {
             const nextLevelIndex = currentLevel;
             const nextRequirement = adventureRequirements[nextLevelIndex];
             const progress = Math.min(100, (globalStats.totalCompletionCount / nextRequirement) * 100);
             
             contentHTML += `
                     <div class="mt-3">
                         <p class="text-sm text-gray-700 dark:text-gray-300 mb-1">距離 "${adventureLevels[nextLevelIndex]}" 還需 ${nextRequirement - globalStats.totalCompletionCount} 次</p>
                         <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                             <div class="h-full bg-primary rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                         </div>
                     </div>
             `;
         } else {
             contentHTML += `
                     <p class="mt-3 text-sm text-green-500 dark:text-green-400"><i class="fas fa-crown mr-1"></i> 已達成最高等級！</p>
             `;
         }
         
         contentHTML += `
                 </div>
             </div>
         `;
         } else {
         // 顯示尚未獲得任何成就的提示
         contentHTML += `
             <div class="text-center py-8">
                 <i class="fas fa-medal text-gray-300 dark:text-gray-600 text-4xl mb-3"></i>
                 <p class="text-gray-600 dark:text-gray-400">尚未獲得冒險成就</p>
                 <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">完成至少1次挑戰解鎖「初心者」成就</p>
             </div>
         `;
         }
         
         contentHTML += `
             </div>
         </div>
         
         <!-- 挫敗之路成就 -->
         <div>
             <h4 class="text-xl font-bold text-amber-700 dark:text-amber-400 mb-4">挫敗之路（只計算完整篇章）</h4>
             <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-5">
         `;
         
         // 挫敗之路成就等級名稱
         const defeatLevels = ['初嘗敗績', '堅毅', '鋼鐵意志', '小強是我', '心如止水'];
         const defeatRequirements = [1, 5, 30, 50, 100];
         const defeatBorderColors = ['#7E57C2', '#42A5F5', '#00796B', '#F57C00', '#D32F2F'];
         
         // 當前挫敗等級
         const currentDefeatLevel = globalStats.achievements.defeatLevel;
         
         // 如果已經達成任何等級
         if (currentDefeatLevel > 0) {
         // 顯示當前等級成就
         const levelIndex = currentDefeatLevel - 1;
         contentHTML += `
             <div class="flex items-center mb-6">
                 <div class="achievement-seal" style="width: 110px; height: 110px;">
                     ${createAchievementSVG(defeatColors[levelIndex], defeatBorderColors[levelIndex])}
                     <div class="seal-text">
                         <span class="seal-title text-lg">${defeatLevels[levelIndex]}</span>
                         <span class="seal-desc">失敗${defeatRequirements[levelIndex]}次</span>
                     </div>
                 </div>
                 <div class="ml-5">
                     <p class="text-lg font-bold text-gray-800 dark:text-gray-200">目前等級：${defeatLevels[levelIndex]}</p>
                     <p class="text-gray-600 dark:text-gray-400">遊戲過半後失敗：${globalStats.failAfterHalfwayCount}次</p>
         `;
         
         // 如果還有下一等級，顯示進度
         if (currentDefeatLevel < 5) {
             const nextLevelIndex = currentDefeatLevel;
             const nextRequirement = defeatRequirements[nextLevelIndex];
             const progress = Math.min(100, (globalStats.failAfterHalfwayCount / nextRequirement) * 100);
             
             contentHTML += `
                     <div class="mt-3">
                         <p class="text-sm text-gray-700 dark:text-gray-300 mb-1">距離 "${defeatLevels[nextLevelIndex]}" 還需 ${nextRequirement - globalStats.failAfterHalfwayCount} 次</p>
                         <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                             <div class="h-full bg-primary rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                         </div>
                     </div>
             `;
         } else {
             contentHTML += `
                     <p class="mt-3 text-sm text-green-500 dark:text-green-400"><i class="fas fa-crown mr-1"></i> 已達成最高等級！</p>
             `;
         }
         
         contentHTML += `
                 </div>
             </div>
         `;
         } else {
         // 顯示尚未獲得任何成就的提示
         contentHTML += `
             <div class="text-center py-8">
                 <i class="fas fa-bolt-lightning text-gray-300 dark:text-gray-600 text-4xl mb-3"></i>
                 <p class="text-gray-600 dark:text-gray-400">尚未獲得挫敗成就</p>
                 <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">在遊戲過半後失敗至少1次解鎖「初嘗敗績」成就</p>
             </div>
         `;
         }
         
         contentHTML += `
             </div>
         </div>
         
         <!-- 極速之路成就 -->
         <div>
             <h4 class="text-xl font-bold text-amber-700 dark:text-amber-400 mb-4">極速之路</h4>
             <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-5">
         `;
         
         // 極速之路成就等級名稱
         const speedLevels = ['敏捷', '肌肉記憶', '無影手', '世界第一束光'];
         const speedRequirements = [1, 10, 50, 100];
         const speedBorderColors = ['#311B92', '#283593', '#1565C0', '#0277BD'];
         
         // 當前極速等級
         const currentSpeedLevel = globalStats.achievements.speedRouteLevel;
         
         // 如果已經達成任何等級
         if (currentSpeedLevel > 0) {
         // 顯示當前等級成就
         const levelIndex = currentSpeedLevel - 1;
         contentHTML += `
             <div class="flex items-center mb-6">
                 <div class="achievement-seal" style="width: 110px; height: 110px;">
                     ${createAchievementSVG(speedColors[levelIndex], speedBorderColors[levelIndex])}
                     <div class="seal-text">
                         <span class="seal-title text-lg">${speedLevels[levelIndex]}</span>
                         <span class="seal-desc">獲得${speedRequirements[levelIndex]}次</span>
                     </div>
                 </div>
                 <div class="ml-5">
                     <p class="text-lg font-bold text-gray-800 dark:text-gray-200">目前等級：${speedLevels[levelIndex]}</p>
                     <p class="text-gray-600 dark:text-gray-400">閃電俠成就獲得次數：${globalStats.lightningAchievementCount}次</p>
         `;
         
         // 如果還有下一等級，顯示進度
         if (currentSpeedLevel < 4) {
             const nextLevelIndex = currentSpeedLevel;
             const nextRequirement = speedRequirements[nextLevelIndex];
             const progress = Math.min(100, (globalStats.lightningAchievementCount / nextRequirement) * 100);
             
             contentHTML += `
                     <div class="mt-3">
                         <p class="text-sm text-gray-700 dark:text-gray-300 mb-1">距離 "${speedLevels[nextLevelIndex]}" 還需 ${nextRequirement - globalStats.lightningAchievementCount} 次</p>
                         <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                             <div class="h-full bg-primary rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                         </div>
                     </div>
             `;
         } else {
             contentHTML += `
                     <p class="mt-3 text-sm text-green-500 dark:text-green-400"><i class="fas fa-crown mr-1"></i> 已達成最高等級！</p>
             `;
         }
         
         contentHTML += `
                 </div>
             </div>
         `;
         } else {
         // 顯示尚未獲得任何成就的提示
         contentHTML += `
             <div class="text-center py-8">
                 <i class="fas fa-bolt text-gray-300 dark:text-gray-600 text-4xl mb-3"></i>
                 <p class="text-gray-600 dark:text-gray-400">尚未獲得極速成就</p>
                 <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">獲得「閃電俠」成就至少1次解鎖「敏捷」成就</p>
             </div>
         `;
         }
         
         contentHTML += `
             </div>
         </div>
         
         <!-- 完美之路成就 -->
         <div>
             <h4 class="text-xl font-bold text-amber-700 dark:text-amber-400 mb-4">完美之路</h4>
             <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-5">
         `;
         
         // 完美之路成就等級名稱
         const perfectLevels = ['如沐春風', '完美主義', '滿月', '至善'];
         const perfectRequirements = [1, 10, 50, 100];
         const perfectBorderColors = ['#AD1457', '#6A1B9A', '#4527A0', '#283593'];
         
         // 當前完美等級
         const currentPerfectLevel = globalStats.achievements.perfectRouteLevel;
         
         // 如果已經達成任何等級
         if (currentPerfectLevel > 0) {
         // 顯示當前等級成就
         const levelIndex = currentPerfectLevel - 1;
         contentHTML += `
             <div class="flex items-center mb-6">
                 <div class="achievement-seal" style="width: 110px; height: 110px;">
                     ${createAchievementSVG(perfectColors[levelIndex], perfectBorderColors[levelIndex])}
                     <div class="seal-text">
                         <span class="seal-title text-lg">${perfectLevels[levelIndex]}</span>
                         <span class="seal-desc">獲得${perfectRequirements[levelIndex]}次</span>
                     </div>
                 </div>
                 <div class="ml-5">
                     <p class="text-lg font-bold text-gray-800 dark:text-gray-200">目前等級：${perfectLevels[levelIndex]}</p>
                     <p class="text-gray-600 dark:text-gray-400">完美無瑕成就獲得次數：${globalStats.perfectAchievementCount}次</p>
         `;
         
         // 如果還有下一等級，顯示進度
         if (currentPerfectLevel < 4) {
             const nextLevelIndex = currentPerfectLevel;
             const nextRequirement = perfectRequirements[nextLevelIndex];
             const progress = Math.min(100, (globalStats.perfectAchievementCount / nextRequirement) * 100);
             
             contentHTML += `
                     <div class="mt-3">
                         <p class="text-sm text-gray-700 dark:text-gray-300 mb-1">距離 "${perfectLevels[nextLevelIndex]}" 還需 ${nextRequirement - globalStats.perfectAchievementCount} 次</p>
                         <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                             <div class="h-full bg-primary rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                         </div>
                     </div>
             `;
         } else {
             contentHTML += `
                     <p class="mt-3 text-sm text-green-500 dark:text-green-400"><i class="fas fa-crown mr-1"></i> 已達成最高等級！</p>
             `;
         }
         
         contentHTML += `
                 </div>
             </div>
         `;
         } else {
         // 顯示尚未獲得任何成就的提示
         contentHTML += `
             <div class="text-center py-8">
                 <i class="fas fa-gem text-gray-300 dark:text-gray-600 text-4xl mb-3"></i>
                 <p class="text-gray-600 dark:text-gray-400">尚未獲得完美成就</p>
                 <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">獲得「完美無瑕」成就至少1次解鎖「如沐春風」成就</p>
             </div>
         `;
         }
         
         contentHTML += `
             </div>
         </div>
         
         <!-- 記憶之路成就 -->
         <div>
             <h4 class="text-xl font-bold text-amber-700 dark:text-amber-400 mb-4">記憶之路</h4>
             <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-5">
         `;
         
         // 記憶之路成就等級名稱
         const memoryLevels = ['激活腦細胞', '記憶麵包', '移動圖書館', '流如背倒'];
         const memoryRequirements = [1, 10, 30, 50];
         const memoryBorderColors = ['#004D40', '#00838F', '#2E7D32', '#558B2F'];
         
         // 當前記憶等級
         const currentMemoryLevel = globalStats.achievements.memoryRouteLevel;
         
         // 如果已經達成任何等級
         if (currentMemoryLevel > 0) {
         // 顯示當前等級成就
         const levelIndex = currentMemoryLevel - 1;
         contentHTML += `
             <div class="flex items-center mb-6">
                 <div class="achievement-seal" style="width: 110px; height: 110px;">
                     ${createAchievementSVG(memoryColors[levelIndex], memoryBorderColors[levelIndex])}
                     <div class="seal-text">
                         <span class="seal-title text-lg">${memoryLevels[levelIndex]}</span>
                         <span class="seal-desc">獲得${memoryRequirements[levelIndex]}次</span>
                     </div>
                 </div>
                 <div class="ml-5">
                     <p class="text-lg font-bold text-gray-800 dark:text-gray-200">目前等級：${memoryLevels[levelIndex]}</p>
                     <p class="text-gray-600 dark:text-gray-400">記憶大師成就獲得次數：${globalStats.memoryAchievementCount}次</p>
         `;
         
         // 如果還有下一等級，顯示進度
         if (currentMemoryLevel < 4) {
             const nextLevelIndex = currentMemoryLevel;
             const nextRequirement = memoryRequirements[nextLevelIndex];
             const progress = Math.min(100, (globalStats.memoryAchievementCount / nextRequirement) * 100);
             
             contentHTML += `
                     <div class="mt-3">
                         <p class="text-sm text-gray-700 dark:text-gray-300 mb-1">距離 "${memoryLevels[nextLevelIndex]}" 還需 ${nextRequirement - globalStats.memoryAchievementCount} 次</p>
                         <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                             <div class="h-full bg-primary rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                         </div>
                     </div>
             `;
         } else {
             contentHTML += `
                     <p class="mt-3 text-sm text-green-500 dark:text-green-400"><i class="fas fa-crown mr-1"></i> 已達成最高等級！</p>
             `;
         }
         
         contentHTML += `
                 </div>
             </div>
         `;
         } else {
         // 顯示尚未獲得任何成就的提示
         contentHTML += `
             <div class="text-center py-8">
                 <i class="fas fa-brain text-gray-300 dark:text-gray-600 text-4xl mb-3"></i>
                 <p class="text-gray-600 dark:text-gray-400">尚未獲得記憶成就</p>
                 <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">獲得「記憶大師」成就至少1次解鎖「激活腦細胞」成就</p>
             </div>
         `;
         }
         
         contentHTML += `
             </div>
         </div>
         
         <!-- 指定文言篇章大師之路成就 -->
         <div>
             <h4 class="text-xl font-bold text-amber-700 dark:text-amber-400 mb-4">指定文言篇章大師之路（只計算完整篇章）</h4>
             <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-5">
         `;
         
         // 指定文言篇章大師之路成就等級名稱
         const specifiedTextLevels = ['新兵上陣', '唯手熟爾', '功在不舍', '四望如一'];
         const specifiedTextRequirements = [1, 3, 10, 20];
         const specifiedTextBorderColors = ['#8D6E63', '#6D4C41', '#5D4037', '#4E342E'];
         const specifiedTextColors = [
         { center: '#A1887F', middle: '#8D6E63', outer: '#795548' }, // 新兵上陣
         { center: '#8D6E63', middle: '#795548', outer: '#6D4C41' }, // 唯手熟爾
         { center: '#795548', middle: '#6D4C41', outer: '#5D4037' }, // 功在不舍
         { center: '#6D4C41', middle: '#5D4037', outer: '#4E342E' }  // 四望如一
         ];
         
         // 獲取所有「指定文言」分類的篇章
         const specifiedTextPassages = Object.keys(passages).filter(key => 
         passages[key].category === '指定文言'
         );
         
         // 從用戶記錄中讀取每篇篇章的完成次數
         const completionCounts = specifiedTextPassages.map(key => 
         userRecordsMemory[key]?.completionCount || 0
         );
         
         // 找出最小完成次數
         const minCompletions = completionCounts.length > 0 ? Math.min(...completionCounts) : 0;
         
         // 確定成就等級 - 基於所有篇章的最小完成次數
         let calculatedLevel = 0;
         for (let i = 0; i < specifiedTextRequirements.length; i++) {
         if (minCompletions >= specifiedTextRequirements[i]) {
             calculatedLevel = i + 1;
         } else {
             break;
         }
         }
         
         // 更新全局統計中的成就等級（如果計算出的等級更高）
         if (calculatedLevel > globalStats.achievements.specifiedTextRouteLevel) {
         globalStats.achievements.specifiedTextRouteLevel = calculatedLevel;
         // 保存更新的統計
         saveStats();
         }
         
         // 使用更新後的等級
         const currentSpecifiedTextLevel = globalStats.achievements.specifiedTextRouteLevel;
         
         // 如果已經達成任何等級
         if (currentSpecifiedTextLevel > 0) {
         // 顯示當前等級成就
         const levelIndex = currentSpecifiedTextLevel - 1;
         contentHTML += `
             <div class="flex items-center mb-6">
                 <div class="achievement-seal" style="width: 110px; height: 110px;">
                     ${createAchievementSVG(specifiedTextColors[levelIndex], specifiedTextBorderColors[levelIndex])}
                     <div class="seal-text">
                         <span class="seal-title text-lg">${specifiedTextLevels[levelIndex]}</span>
                         <span class="seal-desc">完成各${specifiedTextRequirements[levelIndex]}次</span>
                     </div>
                 </div>
                 <div class="ml-4 flex-1">
                     <p class="text-lg font-bold text-gray-800 dark:text-gray-200">目前等級：${specifiedTextLevels[levelIndex]}</p>
                     <p class="text-gray-600 dark:text-gray-400">指定文言篇章最少完成：${minCompletions}次</p>
         `;
         
         // 如果還有下一等級，顯示進度
         if (currentSpecifiedTextLevel < 4) {
             const nextLevelIndex = currentSpecifiedTextLevel;
             const nextRequirement = specifiedTextRequirements[nextLevelIndex];
             const progress = Math.min(100, (minCompletions / nextRequirement) * 100);
             
             contentHTML += `
                     <div class="mt-3">
                         <p class="text-sm text-gray-700 dark:text-gray-300 mb-1">距離 "${specifiedTextLevels[nextLevelIndex]}" 還需完成所有指定文言篇章至少${nextRequirement - minCompletions}次</p>
                         <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                             <div class="h-full bg-primary rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                         </div>
                     </div>
             `;
         } else {
             contentHTML += `
                     <p class="mt-3 text-sm text-green-500 dark:text-green-400"><i class="fas fa-crown mr-1"></i> 已達成最高等級！</p>
             `;
         }
         
         contentHTML += `
                 </div>
             </div>
         `;
         } else {
         // 顯示尚未獲得任何成就的提示
         contentHTML += `
             <div class="text-center py-8">
                 <i class="fas fa-book-open text-gray-300 dark:text-gray-600 text-4xl mb-3"></i>
                 <p class="text-gray-600 dark:text-gray-400">尚未獲得指定文言篇章大師成就</p>
                 <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">完成所有「指定文言篇章」各1次解鎖「新兵上陣」成就</p>
             </div>
         `;
         }
         
         contentHTML += `
             </div>
         </div>
         
         <!-- 文學冒險者之路成就 -->
         <div>
             <h4 class="text-xl font-bold text-amber-700 dark:text-amber-400 mb-4">文學冒險者之路（只計算完整篇章）</h4>
             <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-5">
         `;
         
         // 文學冒險者之路成就等級名稱
         const literatureLevels = ['青青子衿', '悠悠我心', '但為君故', '沉吟至今'];
         const literatureRequirements = [1, 3, 10, 20];
         const literatureBorderColors = ['#9CCC65', '#8BC34A', '#7CB342', '#689F38'];
         const literatureColors = [
         { center: '#C5E1A5', middle: '#AED581', outer: '#9CCC65' }, // 青青子衿
         { center: '#AED581', middle: '#9CCC65', outer: '#8BC34A' }, // 悠悠我心
         { center: '#9CCC65', middle: '#8BC34A', outer: '#7CB342' }, // 但為君故
         { center: '#8BC34A', middle: '#7CB342', outer: '#689F38' }  // 沉吟至今
         ];
         
         // 獲取所有「文學」分類的篇章
         const literaturePassages = Object.keys(passages).filter(key => 
         passages[key].category === '文學'
         );
         
         // 從用戶記錄中讀取每篇篇章的完成次數
         const literatureCompletionCounts = literaturePassages.map(key => 
         userRecordsMemory[key]?.completionCount || 0
         );
         
         // 找出最小完成次數
         const literatureMinCompletions = literatureCompletionCounts.length > 0 ? Math.min(...literatureCompletionCounts) : 0;
         
         // 確定成就等級 - 基於所有篇章的最小完成次數
         let calculatedLiteratureLevel = 0;
         for (let i = 0; i < literatureRequirements.length; i++) {
         if (literatureMinCompletions >= literatureRequirements[i]) {
             calculatedLiteratureLevel = i + 1;
         } else {
             break;
         }
         }
         
         // 更新全局統計中的成就等級（如果計算出的等級更高）
         if (calculatedLiteratureLevel > globalStats.achievements.literatureRouteLevel) {
         globalStats.achievements.literatureRouteLevel = calculatedLiteratureLevel;
         // 保存更新的統計
         saveStats();
         }
         
         // 使用更新後的等級
         const currentLiteratureLevel = globalStats.achievements.literatureRouteLevel;
         
         // 如果已經達成任何等級
         if (currentLiteratureLevel > 0) {
         // 顯示當前等級成就
         const levelIndex = currentLiteratureLevel - 1;
         contentHTML += `
             <div class="flex items-center mb-6">
                 <div class="achievement-seal" style="width: 110px; height: 110px;">
                     ${createAchievementSVG(literatureColors[levelIndex], literatureBorderColors[levelIndex])}
                     <div class="seal-text">
                         <span class="seal-title text-lg">${literatureLevels[levelIndex]}</span>
                         <span class="seal-desc">完成各${literatureRequirements[levelIndex]}次</span>
                     </div>
                 </div>
                 <div class="ml-5">
                     <p class="text-lg font-bold text-gray-800 dark:text-gray-200">目前等級：${literatureLevels[levelIndex]}</p>
                     <p class="text-gray-600 dark:text-gray-400">文學篇章最少完成：${literatureMinCompletions}次</p>
         `;
         
         // 如果還有下一等級，顯示進度
         if (currentLiteratureLevel < 4) {
             const nextLevelIndex = currentLiteratureLevel;
             const nextRequirement = literatureRequirements[nextLevelIndex];
             const progress = Math.min(100, (literatureMinCompletions / nextRequirement) * 100);
             
             contentHTML += `
                     <div class="mt-3">
                         <p class="text-sm text-gray-700 dark:text-gray-300 mb-1">距離 "${literatureLevels[nextLevelIndex]}" 還需完成所有文學篇章至少${nextRequirement - literatureMinCompletions}次</p>
                         <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden">
                             <div class="h-full bg-primary rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                         </div>
                     </div>
             `;
         } else {
             contentHTML += `
                     <p class="mt-3 text-sm text-green-500 dark:text-green-400"><i class="fas fa-crown mr-1"></i> 已達成最高等級！</p>
             `;
         }
         
         contentHTML += `
                 </div>
             </div>
         `;
         } else {
         // 顯示尚未獲得任何成就的提示
         contentHTML += `
             <div class="text-center py-8">
                 <i class="fas fa-feather-alt text-gray-300 dark:text-gray-600 text-4xl mb-3"></i>
                 <p class="text-gray-600 dark:text-gray-400">尚未獲得文學冒險者成就</p>
                 <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">完成所有「文學」篇章各1次解鎖「青青子衿」成就</p>
             </div>
         `;
         }
         
         // 特殊成就
         contentHTML += `
             </div>
         </div>
         
         <!-- 特殊成就 -->
         <div>
             <h4 class="text-xl font-bold text-amber-700 dark:text-amber-400 mb-4">特殊成就</h4>
             <div class="bg-gray-50 dark:bg-gray-800 rounded-lg p-5">
                 <div class="space-y-4">
         `;
         
         // 眼乾成就 (獲得不知疲倦30次)
         if (globalStats.achievements.dryEyes) {
         contentHTML += `
             <div class="flex items-center p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                 <div class="achievement-seal" style="width: 80px; height: 80px; margin: 0 10px 0 0;">
                     ${createAchievementSVG(dryEyesColors, '#0277BD')}
                     <div class="seal-text">
                         <span class="seal-title">眼乾</span>
                         <span class="seal-desc text-[8px]">不暫停成癮</span>
                     </div>
                 </div>
                 <div class="ml-3">
                     <p class="font-medium text-gray-800 dark:text-gray-200">眼乾</p>
                     <p class="text-sm text-gray-600 dark:text-gray-400">獲得不知疲倦30次</p>
                     <p class="text-xs text-green-500 dark:text-green-400 mt-1"><i class="fas fa-check-circle mr-1"></i> 已獲得</p>
                 </div>
             </div>
         `;
         } else {
         contentHTML += `
             <div class="flex items-center p-4 bg-gray-100 dark:bg-gray-700/40 rounded-lg">
                 <div class="w-12 h-12 rounded-full bg-gray-200 dark:bg-gray-600 flex items-center justify-center mr-3">
                     <i class="fas fa-eye text-gray-400 dark:text-gray-500"></i>
                 </div>
                 <div>
                     <p class="font-medium text-gray-500 dark:text-gray-400">眼乾</p>
                     <p class="text-sm text-gray-500 dark:text-gray-500">獲得「不知疲倦」30次</p>
                     <p class="text-xs text-gray-400 dark:text-gray-500 mt-1"><i class="fas fa-lock mr-1"></i> 未解鎖</p>
                 </div>
             </div>
         `;
         }
         
         // 夜貓王成就 (獲得夜貓20次)
         if (globalStats.achievements.nightOwlKing) {
         contentHTML += `
             <div class="flex items-center p-4 bg-purple-50 dark:bg-purple-900/20 rounded-lg">
                 <div class="achievement-seal" style="width: 80px; height: 80px; margin: 0 10px 0 0;">
                     ${createAchievementSVG(nightOwlKingColors, '#5D4037')}
                     <div class="seal-text">
                         <span class="seal-title">夜貓王</span>
                         <span class="seal-desc text-[8px]">深夜成癮</span>
                     </div>
                 </div>
                 <div class="ml-3">
                     <p class="font-medium text-gray-800 dark:text-gray-200">夜貓王</p>
                     <p class="text-sm text-gray-600 dark:text-gray-400">獲得「夜貓」20次</p>
                     <p class="text-xs text-green-500 dark:text-green-400 mt-1"><i class="fas fa-check-circle mr-1"></i> 已獲得</p>
                 </div>
             </div>
         `;
         } else {
         contentHTML += `
             <div class="flex items-center p-4 bg-gray-100 dark:bg-gray-700/40 rounded-lg">
                 <div class="w-12 h-12 rounded-full bg-gray-200 dark:bg-gray-600 flex items-center justify-center mr-3">
                     <i class="fas fa-moon text-gray-400 dark:text-gray-500"></i>
                 </div>
                 <div>
                     <p class="font-medium text-gray-500 dark:text-gray-400">夜貓王</p>
                     <p class="text-sm text-gray-500 dark:text-gray-500">獲得「夜貓」20次</p>
                     <p class="text-xs text-gray-400 dark:text-gray-500 mt-1"><i class="fas fa-lock mr-1"></i> 未解鎖</p>
                 </div>
             </div>
         `;
         }
         
         // 請專心吃飯成就 (獲得腸胃不好20次)
         if (globalStats.achievements.focusOnEating) {
         contentHTML += `
             <div class="flex items-center p-4 bg-orange-50 dark:bg-orange-900/20 rounded-lg">
                 <div class="achievement-seal" style="width: 80px; height: 80px; margin: 0 10px 0 0;">
                     ${createAchievementSVG(focusOnEatingColors, '#E65100')}
                     <div class="seal-text">
                         <span class="seal-title">請專心吃飯</span>
                         <span class="seal-desc text-[8px]">午餐時背誦</span>
                     </div>
                 </div>
                 <div class="ml-3">
                     <p class="font-medium text-gray-800 dark:text-gray-200">請專心吃飯</p>
                     <p class="text-sm text-gray-600 dark:text-gray-400">獲得「腸胃不好」20次</p>
                     <p class="text-xs text-green-500 dark:text-green-400 mt-1"><i class="fas fa-check-circle mr-1"></i> 已獲得</p>
                 </div>
             </div>
         `;
         } else {
         contentHTML += `
             <div class="flex items-center p-4 bg-gray-100 dark:bg-gray-700/40 rounded-lg">
                 <div class="w-12 h-12 rounded-full bg-gray-200 dark:bg-gray-600 flex items-center justify-center mr-3">
                     <i class="fas fa-utensils text-gray-400 dark:text-gray-500"></i>
                 </div>
                 <div>
                     <p class="font-medium text-gray-500 dark:text-gray-400">請專心吃飯</p>
                     <p class="text-sm text-gray-500 dark:text-gray-500">獲得「腸胃不好」20次</p>
                     <p class="text-xs text-gray-400 dark:text-gray-500 mt-1"><i class="fas fa-lock mr-1"></i> 未解鎖</p>
                 </div>
             </div>
         `;
         }
         
         contentHTML += `
                 </div>
             </div>
         </div>
         
         <div class="text-center text-sm text-gray-500 dark:text-gray-400 mt-8">
             持續挑戰，解鎖更多成就！
         </div>
         </div>
         `;
         
         infoModalContent.innerHTML = contentHTML;
         }            
             // 初始化用戶名編輯功能
             initializeNameEditor();
             
             // 初始化成就展示功能
             initializeAchievementsDisplay();
             
             // 初始化頭像選擇功能
             initializeAvatarSelector();
             
             // 頭像選擇功能
             function initializeAvatarSelector() {
                 // 獲取DOM元素
                 const changeAvatarBtn = document.getElementById('change-avatar-btn');
                 const avatarSelectorModal = document.getElementById('avatar-selector-modal');
                 const closeAvatarSelector = document.getElementById('close-avatar-selector');
                 const avatarGrid = document.getElementById('avatar-grid');
                 const userAvatar = document.getElementById('user-avatar');
                 
                 // 檢查元素是否存在
                 if (!changeAvatarBtn || !avatarSelectorModal || !closeAvatarSelector || !avatarGrid || !userAvatar) {
                     console.error("頭像選擇器初始化失敗：缺少必要元素");
                     return;
                 }
                 
                 // 載入之前選擇的頭像
                 try {
                     const savedAvatar = localStorage.getItem('MemoryMaster_userAvatar');
                     if (savedAvatar) {
                         userSelectedAvatar = savedAvatar;
                         renderUserAvatar(userAvatar, savedAvatar);
                     }
                 } catch (e) {
                     console.error("加載用戶頭像出錯:", e);
                 }
                 
                 // 生成頭像選項
                 generateAvatarOptions(avatarGrid);
                 
                 // 打開頭像選擇器
                 changeAvatarBtn.addEventListener('click', function() {
                     avatarSelectorModal.classList.remove('hidden');
                     
                     // 標記當前選中的頭像
                     highlightSelectedAvatar();
                     
                     // 禁用設置齒輪按鈕
                     window.disableSettingsButton();
                 });
                 
                 // 關閉頭像選擇器並重新啟用設置按鈕
                 function closeAvatarSelectorModal() {
                     avatarSelectorModal.classList.add('hidden');
                     window.enableSettingsButton();
                 }
                 
                 // 關閉頭像選擇器
                 closeAvatarSelector.addEventListener('click', function() {
                     closeAvatarSelectorModal();
                 });
                 
                 // 點擊背景關閉
                 avatarSelectorModal.addEventListener('click', function(e) {
                     if (e.target === avatarSelectorModal) {
                         closeAvatarSelectorModal();
                     }
                 });
                 
                 // 將關閉模態框函數設為全局，以便在選擇頭像後使用
                 window.closeAvatarSelectorModal = closeAvatarSelectorModal;
             }
             
             // 檢查頭像是否已解鎖
             function isAvatarUnlocked(avatarKey) {
                 // 默認頭像永遠解鎖
                 if (avatarKey === 'default') return true;
                 
                 // 檢查用戶等級是否達到解鎖要求
                 const requiredLevel = window.avatarUnlockLevels[avatarKey] || 1;
                 return userProfile.level >= requiredLevel;
             }
             
             // 生成頭像選項
             function generateAvatarOptions(container) {
                 if (!container) return;
                 
                 // 清空容器
                 container.innerHTML = '';
                 
                 // 添加默認頭像選項
                 const defaultOption = document.createElement('div');
                 defaultOption.className = 'avatar-option ' + (userSelectedAvatar === null ? 'selected' : '');
                 defaultOption.dataset.avatar = 'default';
                 defaultOption.innerHTML = `
                     <div class="pixel-avatar flex items-center justify-center">
                         <i class="fas fa-user text-2xl text-gray-800 dark:text-gray-100"></i>
                     </div>
                 `;
                 container.appendChild(defaultOption);
                 
                 // 為默認頭像添加點擊事件
                 defaultOption.addEventListener('click', function() {
                     selectAvatar('default');
                 });
                 
                 // 添加每個8-bit像素頭像選項
                 Object.keys(avatarPixelData).forEach(key => {
                     const avatarData = avatarPixelData[key];
                     const isUnlocked = isAvatarUnlocked(key);
                     const requiredLevel = avatarUnlockLevels[key] || 1;
                     
                     const option = document.createElement('div');
                     option.className = 'avatar-option ' + (userSelectedAvatar === key ? 'selected' : '');
                     option.dataset.avatar = key;
                     option.dataset.level = requiredLevel;
                     option.title = isUnlocked ? avatarData.name : `${avatarData.name} (需要等級 ${requiredLevel})`;
                     
                     // 如果頭像未解鎖，添加禁用樣式類
                     if (!isUnlocked) {
                         option.classList.add('locked');
                     }
                     
                     // 添加到容器
                     container.appendChild(option);
                     
                     // 添加頭像震動樣式
                     const avatarShakeStyle = document.createElement('style');
                     avatarShakeStyle.textContent = `
                         @keyframes avatar-shake {
                             0%, 100% { transform: translateX(0); }
                             25% { transform: translateX(-5px); }
                             50% { transform: translateX(5px); }
                             75% { transform: translateX(-5px); }
                         }
                         
                         .avatar-shake {
                             animation: avatar-shake 0.4s ease-in-out;
                         }
                     `;
                     document.head.appendChild(avatarShakeStyle);
                     
                     // 添加點擊事件
                     option.addEventListener('click', function() {
                         // 檢查頭像是否已解鎖
                         if (isUnlocked) {
                             selectAvatar(key);
                         } else {
                             // 未解鎖時輕微震動而不是顯示提醒文字
                             this.classList.add('avatar-shake');
                             
                             // 震動結束後移除類
                             setTimeout(() => {
                                 this.classList.remove('avatar-shake');
                             }, 400); // 與動畫持續時間相同
                         }
                     });
                     
                     // 渲染像素頭像
                     renderPixelAvatar(option, key, !isUnlocked);
                     
                     // 如果頭像未解鎖，添加等級指示器
                     if (!isUnlocked) {
                         const levelIndicator = document.createElement('div');
                         levelIndicator.className = 'absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-lg';
                         levelIndicator.innerHTML = `<span class="text-white font-bold text-sm">Lv.${requiredLevel}</span>`;
                         option.appendChild(levelIndicator);
                     }
                 });
             }
             
             // 選擇頭像
             function selectAvatar(avatarKey) {
                 // 取消所有選中狀態
                 document.querySelectorAll('.avatar-option').forEach(option => {
                     option.classList.remove('selected');
                 });
                 
                 // 設置新選中狀態
                 const selectedOption = document.querySelector(`.avatar-option[data-avatar="${avatarKey}"]`);
                 if (selectedOption) {
                     selectedOption.classList.add('selected');
                 }
                 
                 // 保存選擇
                 userSelectedAvatar = avatarKey === 'default' ? null : avatarKey;
                 
                 try {
                     if (userSelectedAvatar === null) {
                         localStorage.removeItem('MemoryMaster_userAvatar');
                     } else {
                         localStorage.setItem('MemoryMaster_userAvatar', userSelectedAvatar);
                     }
                 } catch (e) {
                     console.error("保存用戶頭像出錯:", e);
                 }
                 
                 // 更新用戶頭像顯示
                 const userAvatar = document.getElementById('user-avatar');
                 if (userAvatar) {
                     renderUserAvatar(userAvatar, userSelectedAvatar);
                 }
                 
                 // 顯示成功提示
                 const notification = document.createElement('div');
                 notification.className = 'fixed bottom-5 left-1/2 transform -translate-x-1/2 bg-green-100 text-green-800 py-2 px-4 rounded-lg shadow-lg z-50';
                 notification.innerHTML = '<i class="fas fa-check-circle mr-2"></i>頭像已更新';
                 document.body.appendChild(notification);
                 
                 // 3秒後移除提示
                 setTimeout(() => {
                     notification.remove();
                 }, 3000);
                 
                 // 選擇頭像後自動關閉選擇器
                 if (window.closeAvatarSelectorModal) {
                     window.closeAvatarSelectorModal();
                 }
             }
             
             // 標記當前選中的頭像
             function highlightSelectedAvatar() {
                 document.querySelectorAll('.avatar-option').forEach(option => {
                     option.classList.remove('selected');
                     
                     if ((userSelectedAvatar === null && option.dataset.avatar === 'default') || 
                         option.dataset.avatar === userSelectedAvatar) {
                         option.classList.add('selected');
                     }
                 });
             }
            
             // 渲染像素頭像
            function renderPixelAvatar(container, avatarKey) {
                if (!container) return;
                
                const avatarData = avatarPixelData[avatarKey];
                if (!avatarData) return;
                
                // 創建像素藝術容器
                const pixelContainer = document.createElement('div');
                pixelContainer.className = 'pixel-avatar';
                
                // 創建 8x8 像素網格
                const gridSize = 8;
                const pixelSize = 100 / gridSize; // 百分比尺寸
                
                // 為每個頭像生成唯一的像素模式
                const pixels = generatePixelPattern(avatarKey, gridSize, avatarData.colors);
                
                // 創建所有像素
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const pixel = document.createElement('div');
                        pixel.style.position = 'absolute';
                        pixel.style.top = (y * pixelSize) + '%';
                        pixel.style.left = (x * pixelSize) + '%';
                        pixel.style.width = pixelSize + '%';
                        pixel.style.height = pixelSize + '%';
                        
                        // 設置像素顏色
                        const colorIndex = pixels[y][x];
                        if (colorIndex >= 0) {
                            pixel.style.backgroundColor = avatarData.colors[colorIndex];
                        } else {
                            pixel.style.backgroundColor = 'transparent';
                        }
                        
                        pixelContainer.appendChild(pixel);
                    }
                }
                
                container.appendChild(pixelContainer);
            }
            
            // 為用戶頭像渲染頭像
            function renderUserAvatar(container, avatarKey) {
                if (!container) return;
                
                // 清空容器
                container.innerHTML = '';
                
                if (!avatarKey) {
                    // 顯示默認頭像
                    container.innerHTML = '<i class="fas fa-user text-4xl md:text-5xl text-amber-800 dark:text-amber-100"></i>';
                    return;
                }
                
                // 渲染選擇的像素頭像
                renderPixelAvatar(container, avatarKey);
            }
            
            // 生成像素模式
            function generatePixelPattern(avatarKey, size, colors) {
                // 使用Avatar鍵名作為種子創建一致的隨機模式
                const seed = hashString(avatarKey);
                const rng = mulberry32(seed);
                
                // 創建空白像素網格 (-1表示透明)
                const pixels = Array(size).fill().map(() => Array(size).fill(-1));
                
                // 生成像素藝術人物輪廓 - 基於角色類型選擇不同的模式
                if (avatarKey === 'villager') {
                    // 普通村民 - 簡單的人臉
                    drawSimpleFace(pixels, rng, colors);
                } else if (avatarKey === 'rabbit') {
                    // 白兔 - 兔子臉
                    drawRabbitFace(pixels, rng, colors);
                } else if (avatarKey === 'lumberjack') {
                    // 樵夫 - 戴著帽子的臉
                    drawLumberjackFace(pixels, rng, colors);
                } else if (avatarKey === 'panda') {
                    // 熊猫 - 熊貓臉
                    drawPandaFace(pixels, rng, colors);
                } else if (avatarKey === 'bomb') {
                    // 炸彈 - 炸彈形狀
                    drawBomb(pixels, rng, colors);
                } else if (avatarKey === 'fox') {
                    // 狐狸 - 狐狸臉
                    drawFoxFace(pixels, rng, colors);
                } else if (avatarKey === 'wizard') {
                    // 魔法师 - 帶帽子的魔法師
                    drawWizard(pixels, rng, colors);
                } else if (avatarKey === 'whale') {
                    // 鲸鱼 - 鯨魚形狀
                    drawWhale(pixels, rng, colors);
                } else if (avatarKey === 'radio') {
                    // 收音機 - 收音機外形
                    drawRadio(pixels, rng, colors);
                } else if (avatarKey === 'chicken') {
                    // 鸡 - 雞形狀
                    drawChicken(pixels, rng, colors);
                } else if (avatarKey === 'assassin') {
                    // 刺客 - 蒙面角色
                    drawAssassin(pixels, rng, colors);
                } else if (avatarKey === 'husky') {
                    // 哈士奇 - 哈士奇臉
                    drawHusky(pixels, rng, colors);
                } else if (avatarKey === 'bread') {
                    // 麵包 - 麵包外形
                    drawBread(pixels, rng, colors);
                } else if (avatarKey === 'werewolf') {
                    // 狼人 - 狼人形象
                    drawWerewolf(pixels, rng, colors);
                } else if (avatarKey === 'dragon') {
                    // 神龙 - 龍頭
                    drawDragon(pixels, rng, colors);
                } else if (avatarKey === 'sushi') {
                    // 壽司 - 壽司形狀
                    drawSushi(pixels, rng, colors);
                } else if (avatarKey === 'cat') {
                    // 猫 - 貓臉
                    drawCat(pixels, rng, colors);
                } else if (avatarKey === 'orange') {
                    // 橙子 - 橙子形狀
                    drawOrange(pixels, rng, colors);
                } else if (avatarKey === 'mask') {
                    // 面具 - 面具形狀
                    drawMask(pixels, rng, colors);
                } else if (avatarKey === 'sparrow') {
                    // 麻雀 - 麻雀形狀
                    drawSparrow(pixels, rng, colors);
                } else if (avatarKey === 'lemon') {
                    // 檸檬 - 重新設計的檸檬
                    drawLemon(pixels, rng, colors);
                } else if (avatarKey === 'angel') {
                    // 天使 - 重新設計的天使
                    drawAngel(pixels, rng, colors);
                } else if (avatarKey === 'unicorn') {
                    // 獨角獸 - 重新設計的獨角獸
                    drawUnicorn(pixels, rng, colors);
                } else if (avatarKey === 'iceflower') {
                    // 冰花 - 重新設計的冰花
                    drawIceflower(pixels, rng, colors);
                } else if (avatarKey === 'pirate') {
                    // 海盜 - 重新設計的海盜
                    drawPirate(pixels, rng, colors);
                } else if (avatarKey === 'candy') {
                    // 糖果 - 重新設計的糖果
                    drawCandy(pixels, rng, colors);
                } else if (avatarKey === 'butterfly') {
                    // 蝴蝶 - 重新設計的蝴蝶
                    drawButterfly(pixels, rng, colors);
                } else if (avatarKey === 'lightning') {
                    // 閃電 - 重新設計的閃電
                    drawLightning(pixels, rng, colors);
                } else if (avatarKey === 'crown') {
                    // 皇冠 - 重新設計的皇冠
                    drawCrown(pixels, rng, colors);
                } else if (avatarKey === 'moon') {
                    // 月球 - 重新設計的月球
                    drawMoon(pixels, rng, colors);
                } else {
                    // 默認 - 隨機圖案
                    drawRandomPattern(pixels, rng, colors);
                }
                
                return pixels;
            }
            
            // 繪製各種頭像的輔助函數
            function drawSimpleFace(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 基本背景色
                    }
                }
                
                // 頭部輪廓 - 更自然的形狀
                for (let y = 1; y < 6; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 1; // 膚色
                    }
                }
                
                // 增加臉部寬度
                pixels[2][1] = 1;
                pixels[2][6] = 1;
                pixels[3][1] = 1;
                pixels[3][6] = 1;
                pixels[4][1] = 1;
                pixels[4][6] = 1;
                
                // 頭髮/帽子 - 有層次感
                for (let x = 1; x < 7; x++) {
                    pixels[0][x] = 0; // 深色頭髮
                }
                for (let x = 2; x < 6; x++) {
                    pixels[1][x] = 0; // 前額髮線
                }
                
                // 側邊頭髮
                pixels[1][1] = 0;
                pixels[1][6] = 0;
                pixels[2][0] = 0;
                pixels[2][7] = 0;
                
                // 眼睛 - 更生動的表情
                pixels[3][2] = 0; // 左眼
                pixels[3][5] = 0; // 右眼
                
                // 嘴巴 - 友善微笑
                pixels[5][3] = 0;
                pixels[5][4] = 0;
                
                // 身體/衣服
                for (let x = 2; x < 6; x++) {
                    pixels[6][x] = 2; // 衣領
                    pixels[7][x] = 2; // 上衣
                }
                
                // 衣服細節
                pixels[6][2] = 0;
                pixels[6][5] = 0;
            }
            
            function drawRabbitFace(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 背景色
                    }
                }
                
                // 兔子頭部 - 更圓潤的臉型
                for (let y = 2; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 0; // 白色主體
                    }
                }
                
                // 擴展臉部輪廓讓臉更圓
                pixels[3][1] = 0;
                pixels[3][6] = 0;
                pixels[4][1] = 0;
                pixels[4][6] = 0;
                pixels[5][1] = 0;
                pixels[5][6] = 0;
                
                // 標誌性長耳朵 - 突出特徵
                pixels[0][2] = 0;
                pixels[0][5] = 0;
                pixels[1][2] = 0; 
                pixels[1][5] = 0;
                pixels[0][3] = 0;
                pixels[0][4] = 0;
                pixels[1][3] = 0;
                pixels[1][4] = 0;
                
                // 耳朵內部粉色細節
                pixels[1][3] = 1;
                pixels[1][4] = 1;
                
                // 可愛的眼睛
                pixels[3][3] = 2; // 左眼
                pixels[3][4] = 2; // 右眼
                
                // 兔子標誌性鼻子 - 小而粉
                pixels[4][3] = 1;
                pixels[4][4] = 1;
                
                // 微笑的嘴巴
                pixels[5][3] = 2;
                pixels[5][4] = 2;
                
                // 胡須暗示
                pixels[4][2] = 2;
                pixels[4][5] = 2;
            }
            
            function drawLumberjackFace(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 2;
                    }
                }
                
                // 臉
                for (let y = 3; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 1;
                    }
                }
                
                // 帽子
                for (let y = 0; y < 3; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 帽子邊緣
                for (let x = 0; x < 8; x++) {
                    pixels[3][x] = 0;
                }
                
                // 眼睛
                pixels[4][2] = 3;
                pixels[4][5] = 3;
                
                // 嘴
                pixels[5][3] = 3;
                pixels[5][4] = 3;
            }
            
            function drawPandaFace(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 淺灰色背景
                    }
                }
                
                // 熊貓頭 (白色部分)
                for (let y = 1; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 2; // 白色
                    }
                }
                
                // 熊貓耳朵 (黑色)
                pixels[0][1] = 0;
                pixels[0][2] = 0;
                pixels[1][0] = 0;
                pixels[1][1] = 0;
                
                pixels[0][5] = 0;
                pixels[0][6] = 0;
                pixels[1][6] = 0;
                pixels[1][7] = 0;
                
                // 熊貓眼睛周圍 (黑色)
                pixels[2][1] = 0;
                pixels[2][2] = 0;
                pixels[3][1] = 0;
                pixels[3][2] = 0;
                pixels[4][2] = 0;
                
                pixels[2][5] = 0;
                pixels[2][6] = 0;
                pixels[3][5] = 0;
                pixels[3][6] = 0;
                pixels[4][5] = 0;
                
                // 眼睛
                pixels[3][3] = 0;
                pixels[3][4] = 0;
                
                // 鼻子
                pixels[5][3] = 0;
                pixels[5][4] = 0;
                
                // 嘴
                pixels[6][3] = 0;
                pixels[6][4] = 0;
            }
            
            function drawBomb(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 2;
                    }
                }
                
                // 炸彈形狀
                for (let y = 2; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 炸彈頂部
                pixels[1][3] = 1;
                pixels[1][4] = 1;
                pixels[0][4] = 1;
                
                // 高光
                pixels[3][2] = 1;
                pixels[3][3] = 1;
                
                // 引信
                pixels[0][3] = 3;
                pixels[1][2] = 3;
            }
            
            function drawFoxFace(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 狐狸頭部主色區域
                for (let y = 2; y < 6; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0; // 橙色主體
                    }
                }
                
                // 尖三角形耳朵
                pixels[0][1] = 0;
                pixels[0][6] = 0;
                pixels[1][1] = 0;
                pixels[1][2] = 0;
                pixels[1][5] = 0;
                pixels[1][6] = 0;
                
                // 延長的狐狸嘴巴 - 尖嘴特徵
                pixels[6][2] = 0;
                pixels[6][3] = 0;
                pixels[6][4] = 0;
                pixels[6][5] = 0;
                pixels[7][3] = 0;
                pixels[7][4] = 0;
                
                // 眼睛
                pixels[3][2] = 3;
                pixels[3][5] = 3;
                
                // 鼻子
                pixels[5][3] = 3;
                pixels[5][4] = 3;
                
                // 白色面部細節
                pixels[4][2] = 2;
                pixels[4][3] = 2;
                pixels[4][4] = 2;
                pixels[4][5] = 2;
                
                // 耳朵內部
                pixels[1][2] = 2;
                pixels[1][5] = 2;
            }
            
            function drawWizard(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 臉部
                for (let y = 3; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 2;
                    }
                }
                
                // 魔法師尖頂帽
                pixels[0][3] = 0;
                pixels[0][4] = 0;
                pixels[1][2] = 0;
                pixels[1][3] = 0;
                pixels[1][4] = 0;
                pixels[1][5] = 0;
                pixels[2][1] = 0;
                pixels[2][2] = 0;
                pixels[2][3] = 0;
                pixels[2][4] = 0;
                pixels[2][5] = 0;
                pixels[2][6] = 0;
                
                // 帽子裝飾
                pixels[1][4] = 3;
                
                // 眼睛
                pixels[4][2] = 1;
                pixels[4][5] = 1;
                
                // 鬍子 - 更長的白鬍子
                pixels[5][3] = 1;
                pixels[5][4] = 1;
                pixels[6][2] = 1;
                pixels[6][3] = 1;
                pixels[6][4] = 1;
                pixels[6][5] = 1;
                pixels[7][3] = 1;
                pixels[7][4] = 1;
            }
            
            function drawWhale(pixels, rng, colors) {
                // 背景 (海水)
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 淺藍色海水
                    }
                }
                
                // 鯨魚身體
                for (let y = 2; y < 6; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0; // 深藍色身體
                    }
                }
                
                // 鯨魚頭部圓弧
                pixels[1][3] = 0;
                pixels[1][4] = 0;
                pixels[1][5] = 0;
                
                // 鯨魚尾巴
                pixels[3][0] = 0;
                pixels[4][0] = 0;
                
                // 鯨魚尾鰭
                pixels[1][1] = 0;
                pixels[6][1] = 0;
                
                // 噴水
                pixels[0][4] = 2;
                pixels[0][3] = 2;
                
                // 眼睛
                pixels[3][5] = 2;
                
                // 腹部細節
                pixels[4][3] = 1;
                pixels[4][4] = 1;
                pixels[5][3] = 1;
                pixels[5][4] = 1;
            }
            
            function drawRadio(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 收音機主體
                for (let y = 1; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 1;
                    }
                }
                
                // 收音機控制鈕
                pixels[2][2] = 3;
                pixels[2][5] = 3;
                pixels[5][2] = 3;
                pixels[5][5] = 3;
                
                // 收音機顯示屏
                for (let x = 2; x < 6; x++) {
                    pixels[3][x] = 2;
                    pixels[4][x] = 2;
                }
                
                // 天線
                pixels[0][2] = 2;
                pixels[0][5] = 2;
            }
            
            function drawChicken(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 雞身體
                for (let y = 2; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 1;
                    }
                }
                
                // 雞冠
                pixels[0][3] = 2;
                pixels[0][4] = 2;
                pixels[1][2] = 2;
                pixels[1][3] = 2;
                pixels[1][4] = 2;
                pixels[1][5] = 2;
                
                // 雞嘴
                pixels[2][4] = 0;
                pixels[2][5] = 0;
                
                // 眼睛
                pixels[2][3] = 0;
                
                // 腿
                pixels[7][3] = 0;
                pixels[7][4] = 0;
            }
            
            function drawAssassin(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 1; // 灰色背景
                    }
                }
                
                // 刺客頭部與身體 - 黑色
                for (let y = 1; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 0; // 黑色裝束
                    }
                }
                
                // 面具輪廓和頭巾 - 更加突出刺客特徵
                pixels[0][2] = 0;
                pixels[0][3] = 0;
                pixels[0][4] = 0;
                pixels[0][5] = 0;
                
                // 頭巾兩側
                pixels[1][1] = 0;
                pixels[1][6] = 0;
                
                // 眼睛部分 - 突出的紅色眼睛，增加神秘感
                pixels[2][3] = 3; // 左眼
                pixels[2][4] = 3; // 右眼
                
                // 面罩輪廓 - 更寬的面罩覆蓋
                pixels[3][1] = 0;
                pixels[3][6] = 0;
                pixels[4][1] = 0;
                pixels[4][6] = 0;
                
                // 肩部裝甲/披風痕跡
                pixels[4][0] = 0;
                pixels[4][7] = 0;
                
                // 武器特徵 - 雙刀，調整位置更具威脅性
                // 左刀
                pixels[5][1] = 0;
                pixels[6][0] = 0;
                pixels[7][0] = 0;
                
                // 右刀
                pixels[5][6] = 0;
                pixels[6][7] = 0;
                pixels[7][7] = 0;
                
                // 腰帶/身體細節 - 紅色配飾增強對比
                pixels[5][3] = 3;
                pixels[5][4] = 3;
                
                // 身體下部
                pixels[7][3] = 0;
                pixels[7][4] = 0;
            }
            
            function drawHusky(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 哈士奇頭
                for (let y = 1; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 耳朵
                pixels[0][1] = 0;
                pixels[0][6] = 0;
                
                // 眼睛
                pixels[2][2] = 1;
                pixels[2][5] = 1;
                
                // 鼻子
                pixels[4][3] = 1;
                pixels[4][4] = 1;
                
                // 嘴巴
                pixels[5][3] = 2;
                pixels[5][4] = 2;
                
                // 白色部分
                pixels[3][3] = 3;
                pixels[3][4] = 3;
                pixels[6][3] = 3;
                pixels[6][4] = 3;
            }
            
            function drawBread(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 麵包底部
                for (let y = 4; y < 8; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0; // 麵包底色
                    }
                }
                
                // 麵包頂部圓弧
                for (let x = 2; x < 6; x++) {
                    pixels[3][x] = 0;
                }
                for (let x = 3; x < 5; x++) {
                    pixels[2][x] = 0;
                }
                
                // 麵包片切面
                for (let y = 5; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 1; // 麵包內部色
                    }
                }
                
                // 麵包切片上沿
                for (let x = 2; x < 6; x++) {
                    pixels[4][x] = 1;
                }
                
                // 麵包質感點
                pixels[5][3] = 2;
                pixels[5][4] = 2;
                pixels[6][2] = 2;
                pixels[6][5] = 2;
                
                // 烤過的邊緣
                pixels[3][1] = 2;
                pixels[3][6] = 2;
                pixels[7][3] = 2;
                pixels[7][4] = 2;
            }
            
            function drawWerewolf(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 狼人頭
                for (let y = 1; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 耳朵
                pixels[0][1] = 0;
                pixels[0][6] = 0;
                
                // 眼睛
                pixels[3][2] = 2;
                pixels[3][5] = 2;
                
                // 鼻子
                pixels[4][3] = 1;
                pixels[4][4] = 1;
                
                // 嘴和尖牙
                pixels[5][2] = 3;
                pixels[5][3] = 1;
                pixels[5][4] = 1;
                pixels[5][5] = 3;
                pixels[6][2] = 3;
                pixels[6][5] = 3;
            }
            
            function drawDragon(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 龍頭主部
                for (let y = 2; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0; // 基本龍色
                    }
                }
                
                // 龍角 - 更明顯且對稱
                pixels[0][2] = 0;
                pixels[0][5] = 0;
                pixels[1][1] = 0;
                pixels[1][2] = 0;
                pixels[1][5] = 0;
                pixels[1][6] = 0;
                
                // 眼睛 - 更兇猛的眼神
                pixels[3][2] = 2; // 左眼
                pixels[3][5] = 2; // 右眼
                pixels[2][2] = 2; // 左眼上部
                pixels[2][5] = 2; // 右眼上部
                
                // 鼻孔
                pixels[4][3] = 1;
                pixels[4][4] = 1;
                
                // 龍嘴 - 嘴巴張開的樣子
                pixels[5][2] = 3; // 牙齒
                pixels[5][5] = 3; // 牙齒
                pixels[6][3] = 2; // 嘴裡
                pixels[6][4] = 2; // 嘴裡
                
                // 鱗片紋理
                pixels[3][3] = 1;
                pixels[3][4] = 1;
                pixels[5][3] = 1;
                pixels[5][4] = 1;
            }
            
            function drawSushi(pixels, rng, colors) {
                // 背景(碟子)
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 壽司飯
                for (let y = 2; y < 6; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 1;
                    }
                }
                
                // 壽司魚
                for (let y = 1; y < 4; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 2;
                    }
                }
                
                // 海苔
                pixels[4][1] = 3;
                pixels[4][2] = 3;
                pixels[4][3] = 3;
                pixels[4][4] = 3;
                pixels[4][5] = 3;
                pixels[4][6] = 3;
                
                // 芥末
                pixels[6][3] = 1;
                pixels[6][4] = 1;
            }
            
            function drawCat(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 貓臉
                for (let y = 1; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 貓耳
                pixels[0][1] = 0;
                pixels[0][6] = 0;
                
                // 眼睛
                pixels[3][2] = 2;
                pixels[3][5] = 2;
                
                // 眼睛縫
                pixels[2][2] = 1;
                pixels[2][5] = 1;
                pixels[4][2] = 1;
                pixels[4][5] = 1;
                
                // 鼻子
                pixels[4][3] = 1;
                pixels[4][4] = 1;
                
                // 嘴
                pixels[5][3] = 1;
                pixels[5][4] = 1;
                
                // 鬍鬚
                pixels[4][0] = 0;
                pixels[4][7] = 0;
                pixels[5][0] = 0;
                pixels[5][7] = 0;
            }
            
            function drawOrange(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 橙子主體
                for (let y = 1; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 0;
                    }
                }
                for (let y = 2; y < 6; y++) {
                    pixels[y][1] = 0;
                    pixels[y][6] = 0;
                }
                
                // 葉子
                pixels[0][3] = 2;
                pixels[0][4] = 2;
                pixels[1][3] = 2;
                
                // 細節紋理
                pixels[2][3] = 1;
                pixels[3][4] = 1;
                pixels[4][2] = 1;
                pixels[5][5] = 1;
            }
            
            function drawMask(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 面具主體
                for (let y = 1; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 面具眼睛
                pixels[2][2] = 3;
                pixels[2][5] = 3;
                pixels[3][2] = 3;
                pixels[3][5] = 3;
                
                // 面具嘴
                pixels[5][3] = 3;
                pixels[5][4] = 3;
                
                // 裝飾
                pixels[1][3] = 2;
                pixels[1][4] = 2;
                pixels[6][2] = 1;
                pixels[6][5] = 1;
            }
            
            function drawSparrow(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 麻雀身體
                for (let y = 2; y < 6; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 麻雀頭
                pixels[1][3] = 0;
                pixels[1][4] = 0;
                
                // 眼睛
                pixels[2][3] = 2;
                
                // 嘴
                pixels[2][5] = 1;
                pixels[2][6] = 1;
                
                // 尾巴
                pixels[5][1] = 0;
                pixels[6][0] = 0;
                
                // 腳
                pixels[6][3] = 1;
                pixels[6][4] = 1;
                pixels[7][3] = 1;
                pixels[7][4] = 1;
                
                // 翅膀
                pixels[3][1] = 0;
                pixels[4][1] = 0;
            }
            
            function drawWatermelon(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 西瓜外皮
                for (let y = 1; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0;
                    }
                }
                
                // 西瓜紅肉
                for (let y = 2; y < 6; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 2;
                    }
                }
                
                // 西瓜籽
                pixels[2][3] = 1;
                pixels[3][4] = 1;
                pixels[4][2] = 1;
                pixels[5][3] = 1;
                pixels[3][2] = 1;
            }
            
            function drawCapybara(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 背景色
                    }
                }
                
                // 卡皮巴拉身體 - 圓潤而寬的輪廓
                for (let y = 2; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0; // 棕色主體
                    }
                }
                
                // 擴展卡皮巴拉頭部，更圓潤
                pixels[1][2] = 0;
                pixels[1][3] = 0;
                pixels[1][4] = 0;
                pixels[1][5] = 0;
                
                // 小型圓耳朵 - 卡皮巴拉特徵
                pixels[0][2] = 0;
                pixels[0][5] = 0;
                
                // 眼睛 - 黑色圓眼睛
                pixels[2][2] = 2; // 左眼
                pixels[2][5] = 2; // 右眼
                
                // 鼻子 - 寬大特徵性鼻子
                pixels[3][3] = 1; // 深色鼻子
                pixels[3][4] = 1;
                pixels[3][2] = 1; // 延長鼻子寬度
                pixels[3][5] = 1;
                
                // 嘴 - 友善表情
                pixels[4][3] = 2;
                pixels[4][4] = 2;
                
                // 腿和腳 - 短腿特徵
                pixels[6][2] = 0;
                pixels[6][5] = 0;
                pixels[7][2] = 0;
                pixels[7][5] = 0;
                
                // 毛髮質感
                pixels[2][3] = 3; // 淺色毛髮細節
                pixels[2][4] = 3;
            }
            
            function drawSunflower(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 淺色背景
                    }
                }
                
                // 鮮明的花瓣 - 明亮的黃色
                // 外圈花瓣 - 更加突出的放射狀
                pixels[0][3] = 0; // 頂部花瓣
                pixels[0][4] = 0;
                pixels[1][1] = 0; // 左上花瓣
                pixels[1][2] = 0;
                pixels[1][5] = 0; // 右上花瓣
                pixels[1][6] = 0;
                pixels[2][0] = 0; // 左側花瓣
                pixels[2][1] = 0;
                pixels[2][6] = 0; // 右側花瓣
                pixels[2][7] = 0;
                pixels[3][0] = 0; // 極左花瓣
                pixels[4][0] = 0;
                pixels[3][7] = 0; // 極右花瓣
                pixels[4][7] = 0;
                pixels[5][1] = 0; // 左下花瓣
                pixels[5][2] = 0;
                pixels[5][5] = 0; // 右下花瓣
                pixels[5][6] = 0;
                pixels[6][2] = 0; // 下方花瓣
                pixels[6][3] = 0;
                pixels[6][4] = 0;
                pixels[6][5] = 0;
                pixels[7][3] = 0; // 底部花瓣
                pixels[7][4] = 0;
                
                // 花盤 - 棕色
                for (let y = 2; y < 6; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 2; // 深棕色花盤
                    }
                }
                
                // 花盤紋理 - 增添細節
                pixels[2][3] = 1; // 上緣紋理
                pixels[2][4] = 1;
                pixels[3][2] = 1; // 左側紋理
                pixels[4][2] = 1;
                pixels[3][5] = 1; // 右側紋理
                pixels[4][5] = 1;
                pixels[5][3] = 1; // 下緣紋理
                pixels[5][4] = 1;
                
                // 莖部提示 - 綠色
                pixels[7][2] = 2;
                pixels[7][5] = 2;
            }
            
            function drawRandomPattern(pixels, rng, colors) {
                // 先填充背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3;
                    }
                }
                
                // 對稱圖案
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        const colorIndex = Math.floor(rng() * 3);
                        pixels[y][x] = colorIndex;
                        pixels[y][7-x] = colorIndex; // 水平對稱
                        pixels[7-y][x] = colorIndex; // 垂直對稱
                        pixels[7-y][7-x] = colorIndex; // 對角對稱
                    }
                }
            }

            // 添加新設計的天使頭像函數
            function drawAngel(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 基本背景色
                    }
                }
                
                // 天使身體 - 白色長袍
                for (let y = 2; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 0; // 純白色長袍
                    }
                }
                
                // 頭部 - 天使特徵
                pixels[1][3] = 0;
                pixels[1][4] = 0;
                
                // 翅膀 - 天使的標誌性特徵
                // 左翅膀
                pixels[2][0] = 0;
                pixels[2][1] = 0;
                pixels[3][0] = 0;
                pixels[3][1] = 0;
                pixels[4][1] = 0;
                
                // 右翅膀
                pixels[2][6] = 0;
                pixels[2][7] = 0;
                pixels[3][6] = 0;
                pixels[3][7] = 0;
                pixels[4][6] = 0;
                
                // 光環 - 天使頭頂的金色光環
                pixels[0][3] = 2;
                pixels[0][4] = 2;
                
                // 翅膀細節 - 淺藍色羽毛紋理
                pixels[2][1] = 3;
                pixels[3][0] = 3;
                pixels[2][6] = 3;
                pixels[3][7] = 3;
                
                // 長袍細節 - 淺藍色裝飾
                pixels[4][3] = 3;
                pixels[4][4] = 3;
                pixels[5][2] = 3;
                pixels[5][5] = 3;
                pixels[6][3] = 3;
                pixels[6][4] = 3;
                
                // 面部特徵
                pixels[1][3] = 1; // 溫柔的表情
            }
            
            // 新設計的獨角獸頭像
            function drawUnicorn(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 基本背景色
                    }
                }
                
                // 獨角獸頭部 - 白色
                for (let y = 1; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        pixels[y][x] = 0; // 白色主體
                    }
                }
                
                // 獨角獸頭部輪廓優化
                pixels[2][0] = 0;
                pixels[3][0] = 0;
                pixels[4][0] = 0;
                pixels[2][7] = 0;
                pixels[3][7] = 0;
                pixels[4][7] = 0;
                
                // 特徵性獨角 - 獨角獸的標誌特徵
                pixels[0][4] = 0;
                pixels[1][3] = 0;
                pixels[0][3] = 0;
                
                // 獨角獸獨角金色尖端
                pixels[0][3] = 2;
                
                // 獨角獸鬃毛 - 紫色
                pixels[0][5] = 1;
                pixels[0][6] = 1;
                pixels[1][6] = 1;
                pixels[1][7] = 1;
                pixels[2][7] = 1;
                
                // 獨角獸眼睛
                pixels[3][2] = 3;
                pixels[3][5] = 3;
                
                // 鼻子和嘴
                pixels[4][3] = 1;
                pixels[4][4] = 1;
                pixels[5][3] = 1;
                pixels[5][4] = 1;
                
                // 耳朵
                pixels[1][1] = 0;
                pixels[1][2] = 0;
                
                // 耳朵內側 - 粉色
                pixels[1][2] = 1;
            }
            
            // 新設計的冰花頭像
            function drawIceflower(pixels, rng, colors) {
                // 背景 - 深藍色
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 深藍色背景
                    }
                }
                
                // 冰花中心 - 最淺的藍色
                pixels[3][3] = 0;
                pixels[3][4] = 0;
                pixels[4][3] = 0;
                pixels[4][4] = 0;
                
                // 主體六角形冰晶形狀 - 六條射線形成雪花形狀
                // 上射線
                pixels[0][3] = 0;
                pixels[1][3] = 0;
                pixels[2][3] = 0;
                pixels[0][4] = 0;
                pixels[1][4] = 0;
                pixels[2][4] = 0;
                
                // 下射線
                pixels[5][3] = 0;
                pixels[6][3] = 0;
                pixels[7][3] = 0;
                pixels[5][4] = 0;
                pixels[6][4] = 0;
                pixels[7][4] = 0;
                
                // 左射線
                pixels[3][0] = 0;
                pixels[3][1] = 0;
                pixels[3][2] = 0;
                pixels[4][0] = 0;
                pixels[4][1] = 0;
                pixels[4][2] = 0;
                
                // 右射線
                pixels[3][5] = 0;
                pixels[3][6] = 0;
                pixels[3][7] = 0;
                pixels[4][5] = 0;
                pixels[4][6] = 0;
                pixels[4][7] = 0;
                
                // 左上射線
                pixels[1][1] = 0;
                pixels[2][2] = 0;
                
                // 右上射線
                pixels[1][6] = 0;
                pixels[2][5] = 0;
                
                // 左下射線
                pixels[5][1] = 0;
                pixels[6][2] = 0;
                
                // 右下射線
                pixels[5][6] = 0;
                pixels[6][5] = 0;
                
                // 晶瑩冰晶細節 - 淺藍色裝飾點
                pixels[2][3] = 1;
                pixels[3][2] = 1;
                pixels[5][3] = 1;
                pixels[3][5] = 1;
                pixels[1][1] = 1;
                pixels[1][6] = 1;
                pixels[6][1] = 1;
                pixels[6][6] = 1;
                
                // 冰花閃光效果 - 最亮的藍色
                pixels[0][3] = 2;
                pixels[3][0] = 2;
                pixels[7][4] = 2;
                pixels[4][7] = 2;
            }
            
            // 新設計的海盜頭像
            function drawPirate(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 基本背景色
                    }
                }
                
                // 海盜面部 - 棕色
                for (let y = 2; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 0; // 深棕色臉
                    }
                }
                
                // 海盜帽 - 黑色
                for (let x = 1; x < 7; x++) {
                    pixels[0][x] = 1; // 帽子頂部
                }
                for (let x = 0; x < 8; x++) {
                    pixels[1][x] = 1; // 帽子寬邊
                }
                
                // 骷髏標誌 - 白色
                pixels[0][4] = 2;
                
                // 眼罩 - 海盜特色
                pixels[2][2] = 1;
                pixels[2][3] = 1;
                pixels[3][2] = 1;
                pixels[3][3] = 1;
                
                // 可見的眼睛
                pixels[3][5] = 3;
                
                // 嘴巴和胡子
                pixels[5][3] = 3;
                pixels[5][4] = 3;
                pixels[4][2] = 1;
                pixels[5][2] = 1;
                pixels[6][3] = 1;
                
                // 耳環 - 金色
                pixels[4][6] = 2;
                
                // 頭巾末端
                pixels[2][6] = 3;
                pixels[2][7] = 3;
                
                // 傷疤 - 紅色
                pixels[4][3] = 3;
                pixels[4][4] = 3;
            }
            
            // 糖果頭像 - 新設計
            function drawCandy(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 背景色
                    }
                }
                
                // 糖果主體 - 橢圓形包裝
                for (let y = 1; y < 7; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 0; // 粉紅色糖果主體
                    }
                }
                
                // 包裝紙兩端的擰紋
                pixels[0][3] = 1;
                pixels[0][4] = 1;
                pixels[7][3] = 1;
                pixels[7][4] = 1;
                
                // 擁有更明顯的包裝紙形狀
                pixels[0][2] = 1;
                pixels[0][5] = 1;
                pixels[7][2] = 1;
                pixels[7][5] = 1;
                
                // 糖果條紋 - 標誌性特徵
                pixels[2][2] = 2; // 綠色條紋
                pixels[2][5] = 2;
                pixels[4][2] = 2;
                pixels[4][5] = 2;
                pixels[6][2] = 2;
                pixels[6][5] = 2;
                
                // 中央部分的花紋
                pixels[3][3] = 1; // 深粉色的裝飾紋理
                pixels[3][4] = 1;
                pixels[5][3] = 1;
                pixels[5][4] = 1;
                
                // 糖果反光高光
                pixels[2][3] = 3;
                pixels[2][4] = 3;
            }
            
            // 蝴蝶頭像 - 新設計
            function drawButterfly(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 背景色
                    }
                }
                
                // 蝴蝶身體 - 中央細長
                pixels[3][3] = 0; // 深紫色身體
                pixels[3][4] = 0;
                pixels[4][3] = 0;
                pixels[4][4] = 0;
                pixels[5][3] = 0;
                pixels[5][4] = 0;
                
                // 蝴蝶頭部
                pixels[2][3] = 0;
                pixels[2][4] = 0;
                
                // 觸角
                pixels[1][2] = 0;
                pixels[1][5] = 0;
                pixels[0][1] = 0;
                pixels[0][6] = 0;
                
                // 上翅膀 - 主要特徵
                // 左上翅膀
                pixels[1][0] = 1;
                pixels[1][1] = 1;
                pixels[2][0] = 1;
                pixels[2][1] = 1;
                pixels[2][2] = 1;
                
                // 右上翅膀
                pixels[1][6] = 1;
                pixels[1][7] = 1;
                pixels[2][5] = 1;
                pixels[2][6] = 1;
                pixels[2][7] = 1;
                
                // 下翅膀
                // 左下翅膀
                pixels[3][0] = 1;
                pixels[3][1] = 1;
                pixels[3][2] = 1;
                pixels[4][0] = 1;
                pixels[4][1] = 1;
                pixels[4][2] = 1;
                
                // 右下翅膀
                pixels[3][5] = 1;
                pixels[3][6] = 1;
                pixels[3][7] = 1;
                pixels[4][5] = 1;
                pixels[4][6] = 1;
                pixels[4][7] = 1;
                
                // 翅膀上的花紋
                // 上翅膀花紋
                pixels[2][1] = 2; // 粉色斑點
                pixels[2][6] = 2;
                
                // 下翅膀花紋
                pixels[4][1] = 2;
                pixels[4][6] = 2;
            }
            
            // 閃電頭像 - 新設計
            function drawLightning(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 背景色
                    }
                }
                
                // 閃電主體 - 鋸齒狀Z形
                // 上部
                pixels[0][3] = 0;
                pixels[0][4] = 0;
                pixels[1][3] = 0;
                pixels[1][4] = 0;
                
                // 中上部轉折
                pixels[2][2] = 0;
                pixels[2][3] = 0;
                pixels[3][2] = 0;
                pixels[3][3] = 0;
                
                // 中間部分
                pixels[3][3] = 0;
                pixels[3][4] = 0;
                pixels[4][3] = 0;
                pixels[4][4] = 0;
                
                // 中下部轉折
                pixels[4][4] = 0;
                pixels[4][5] = 0;
                pixels[5][4] = 0;
                pixels[5][5] = 0;
                
                // 底部
                pixels[6][3] = 0;
                pixels[6][4] = 0;
                pixels[7][3] = 0;
                pixels[7][4] = 0;
                
                // 閃電內部亮黃色核心
                pixels[1][3] = 1;
                pixels[2][2] = 1;
                pixels[3][3] = 1;
                pixels[4][4] = 1;
                pixels[5][4] = 1;
                pixels[6][3] = 1;
                
                // 閃電最亮部分 - 中央高光
                pixels[3][3] = 2;
                pixels[4][4] = 2;
            }
            
            // 皇冠頭像 - 新設計
            function drawCrown(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 背景色
                    }
                }
                
                // 皇冠底部 - 基礎圓環
                for (let x = 1; x < 7; x++) {
                    pixels[5][x] = 0; // 金黃色基底
                    pixels[6][x] = 0;
                }
                
                // 皇冠尖頂 - 主要特徵
                // 中央大尖頂
                pixels[1][3] = 0;
                pixels[1][4] = 0;
                pixels[2][3] = 0;
                pixels[2][4] = 0;
                pixels[3][3] = 0;
                pixels[3][4] = 0;
                pixels[4][3] = 0;
                pixels[4][4] = 0;
                
                // 左側尖頂
                pixels[2][1] = 0;
                pixels[2][2] = 0;
                pixels[3][1] = 0;
                pixels[3][2] = 0;
                pixels[4][1] = 0;
                pixels[4][2] = 0;
                
                // 右側尖頂
                pixels[2][5] = 0;
                pixels[2][6] = 0;
                pixels[3][5] = 0;
                pixels[3][6] = 0;
                pixels[4][5] = 0;
                pixels[4][6] = 0;
                
                // 皇冠上的寶石裝飾
                pixels[0][3] = 3; // 紅寶石 (在中央尖頂上)
                pixels[0][4] = 3;
                
                pixels[2][1] = 1; // 尖頂上的金色細節
                pixels[2][5] = 1;
                
                // 皇冠內部細節 - 亮金色
                pixels[3][3] = 1;
                pixels[3][4] = 1;
                pixels[5][2] = 1;
                pixels[5][5] = 1;
                
                // 皇冠底部裝飾
                pixels[7][2] = 0;
                pixels[7][5] = 0;
            }
            
            // 月球頭像 - 新設計
            function drawMoon(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 深色背景 (像夜空)
                    }
                }
                
                // 月球主體 - 圓形
                for (let y = 1; y < 7; y++) {
                    for (let x = 1; x < 7; x++) {
                        // 創建圓形
                        const centerX = 3.5;
                        const centerY = 3.5;
                        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                        if (distance < 3) {
                            pixels[y][x] = 0; // 淺灰色月球表面
                        }
                    }
                }
                
                // 月球表面細節 - 環形山和陰影
                pixels[2][2] = 1; // 較深的環形山
                pixels[3][5] = 1;
                pixels[5][3] = 1;
                
                // 更多的隕石坑和凹陷
                pixels[2][4] = 2; // 更深的凹陷
                pixels[4][2] = 2;
                
                // 月球陰影部分 - 創造三維感
                pixels[1][1] = 3; // 恢復背景色，創造圓形輪廓
                pixels[1][6] = 3;
                pixels[6][1] = 3;
                pixels[6][6] = 3;
            }
            
            function drawLemon(pixels, rng, colors) {
                // 背景
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        pixels[y][x] = 3; // 基本背景色
                    }
                }
                
                // 檸檬主體 - 更明顯的檸檬形狀
                // 中央部分
                for (let y = 2; y < 6; y++) {
                    for (let x = 2; x < 6; x++) {
                        pixels[y][x] = 0; // 鮮豔檸檬黃色
                    }
                }
                
                // 側面延伸 - 創造橢圓形輪廓
                pixels[3][1] = 0;
                pixels[3][6] = 0;
                pixels[4][1] = 0;
                pixels[4][6] = 0;
                
                // 檸檬特有的尖端 - 更突出的形狀
                // 上部尖端
                pixels[1][3] = 0;
                pixels[1][4] = 0;
                pixels[0][3] = 0;
                pixels[0][4] = 0;
                
                // 下部尖端
                pixels[6][3] = 0;
                pixels[6][4] = 0;
                pixels[7][3] = 0;
                pixels[7][4] = 0;
                
                // 檸檬表面紋理 - 增加視覺趣味性
                pixels[2][3] = 1; // 較亮的黃色斑點
                pixels[3][4] = 1;
                pixels[4][2] = 1;
                pixels[5][3] = 1;
                pixels[5][5] = 1;
                
                // 檸檬綠色葉子 - 更生動的細節
                pixels[0][2] = 2; // 頂部葉子
                pixels[1][2] = 2; // 側葉
                pixels[1][5] = 2; // 對稱側葉
            }
            
            // 幫助函數 - 創建一個基於字符串的哈希值
            function hashString(str) {
                let hash = 0;
                if (str.length === 0) return hash;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // 轉換為32位整數
                }
                return hash >>> 0; // 轉換為無符號整數
            }            

             // 幫助函數 - 創建一個基於字符串的哈希值
             function hashString(str) {
                 let hash = 0;
                 if (str.length === 0) return hash;
                 for (let i = 0; i < str.length; i++) {
                     const char = str.charCodeAt(i);
                     hash = ((hash << 5) - hash) + char;
                     hash = hash & hash; // 轉換為32位整數
                 }
                 return hash >>> 0; // 轉換為無符號整數
             }
             
             // 幫助函數 - 基於種子的隨機數生成器
             function mulberry32(seed) {
                 return function() {
                     let t = seed += 0x6D2B79F5;
                     t = Math.imul(t ^ t >>> 15, t | 1);
                     t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                     return ((t ^ t >>> 14) >>> 0) / 4294967296;
                 };
             }
             
             // 成就展示功能
             function initializeAchievementsDisplay() {
                 // 嘗試從localStorage加載已選擇的成就
                 let selectedAchievements = [];
                 try {
                     const saved = localStorage.getItem('MemoryMaster_selectedAchievements');
                     if (saved) {
                         selectedAchievements = JSON.parse(saved);
                     }
                 } catch (e) {
                     console.error("加載選擇的成就出錯:", e);
                 }
                 
                 // 更新成就展示
                 updateAchievementsDisplay(selectedAchievements);
                 
                 // 管理成就按鈕點擊事件
                 const manageAchievementsBtn = document.getElementById('manage-achievements-btn');
                 if (manageAchievementsBtn) {
                     manageAchievementsBtn.addEventListener('click', function() {
                         showAchievementSelector(selectedAchievements);
                     });
                 }
             }
             
             // 更新成就展示
             function updateAchievementsDisplay(selectedAchievements) {
                 const achievementsDisplay = document.getElementById('achievements-display');
                 if (!achievementsDisplay) return;
                 
                 // 如果沒有選擇任何成就，顯示提示信息
                 if (!selectedAchievements || selectedAchievements.length === 0) {
                     achievementsDisplay.innerHTML = `
                         <p class="text-sm text-gray-500 dark:text-gray-400 italic">從設置菜單的「歷史成就」中選擇展示</p>
                     `;
                     return;
                 }
                 
                 // 清空現有內容
                 achievementsDisplay.innerHTML = '';
                 
                 // 創建SVG徽章
                 const createAchievementSVG = (colors, borderColor) => {
                     const uniqueId = 'seal_' + Math.random().toString(36).substr(2, 9);
                     return `
                     <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                         <defs>
                             <radialGradient id="${uniqueId}" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                                 <stop offset="0%" style="stop-color:${colors.center}" />
                                 <stop offset="70%" style="stop-color:${colors.middle}" />
                                 <stop offset="100%" style="stop-color:${colors.outer}" />
                             </radialGradient>
                         </defs>
                         <circle cx="50" cy="50" r="45" fill="url(#${uniqueId})" />
                         <circle cx="50" cy="50" r="42" fill="none" stroke="${borderColor}" stroke-width="1" stroke-dasharray="2,1" />
                         <circle cx="50" cy="50" r="38" fill="none" stroke="${borderColor}" stroke-width="0.5" />
                     </svg>
                     `;
                 };
                 
                 // 定義各成就色彩
                 const achievementColors = {
                     'complete': { colors: { center: '#8B0000', middle: '#5C0000', outer: '#400000' }, border: '#FFD700' },
                     'lightning': { colors: { center: '#4B0082', middle: '#2A004D', outer: '#1C0033' }, border: '#00FFFF' },
                     'master': { colors: { center: '#006400', middle: '#004D00', outer: '#003300' }, border: '#7CFC00' },
                     'snail': { colors: { center: '#8B4513', middle: '#6B3100', outer: '#4A2100' }, border: '#DAA520' },
                     'tireless': { colors: { center: '#1E3A8A', middle: '#1E40AF', outer: '#1D4ED8' }, border: '#38BDF8' },
                     'nightOwl': { colors: { center: '#3E2723', middle: '#33211B', outer: '#2E1B15' }, border: '#4E342E' },
                     'badDigestion': { colors: { center: '#E65100', middle: '#D84315', outer: '#BF360C' }, border: '#BF360C' },
                     'dryEyes': { colors: { center: '#FFCC80', middle: '#FFA726', outer: '#EF6C00' }, border: '#0277BD' },
                     'nightOwlKing': { colors: { center: '#5D4037', middle: '#3E2723', outer: '#1B0000' }, border: '#5D4037' },
                     'focusOnEating': { colors: { center: '#FFFFFF', middle: '#FFD0B0', outer: '#FF8A65' }, border: '#E65100' },
                     
                     // 冒險之路
                     'adventure1': { colors: { center: '#B3E5FC', middle: '#4FC3F7', outer: '#0288D1' }, border: '#90CAF9' },
                     'adventure2': { colors: { center: '#EF5350', middle: '#E53935', outer: '#C62828' }, border: '#4CAF50' },
                     'adventure3': { colors: { center: '#FFD54F', middle: '#FFC107', outer: '#FFA000' }, border: '#F4511E' },
                     'adventure4': { colors: { center: '#BA68C8', middle: '#AB47BC', outer: '#8E24AA' }, border: '#673AB7' },
                     'adventure5': { colors: { center: '#A5D6A7', middle: '#81C784', outer: '#4CAF50' }, border: '#FFC107' },
                     
                     // 挫敗之路
                     'defeat1': { colors: { center: '#D7CCC8', middle: '#8D6E63', outer: '#4E342E' }, border: '#7E57C2' },
                     'defeat2': { colors: { center: '#E3F2FD', middle: '#90CAF9', outer: '#1565C0' }, border: '#42A5F5' },
                     'defeat3': { colors: { center: '#80DEEA', middle: '#26A69A', outer: '#004D40' }, border: '#00796B' },
                     'defeat4': { colors: { center: '#FFE0B2', middle: '#FFB74D', outer: '#E65100' }, border: '#F57C00' },
                     'defeat5': { colors: { center: '#E0F7FA', middle: '#80DEEA', outer: '#00838F' }, border: '#D32F2F' },
                     
                     // 極速之路
                     'speed1': { colors: { center: '#FF5252', middle: '#D50000', outer: '#B71C1C' }, border: '#311B92' },
                     'speed2': { colors: { center: '#FF9800', middle: '#F57C00', outer: '#E65100' }, border: '#283593' },
                     'speed3': { colors: { center: '#00B4D8', middle: '#0096C7', outer: '#023E8A' }, border: '#1565C0' },
                     'speed4': { colors: { center: '#FFEE58', middle: '#FFD600', outer: '#F9A825' }, border: '#0277BD' },
                     
                     // 完美之路
                     'perfect1': { colors: { center: '#80CBC4', middle: '#4DB6AC', outer: '#E8F5E9' }, border: '#AD1457' },
                     'perfect2': { colors: { center: '#F06292', middle: '#EC407A', outer: '#AD1457' }, border: '#6A1B9A' },
                     'perfect3': { colors: { center: '#FFD54F', middle: '#FFB300', outer: '#5D4037' }, border: '#4527A0' },
                     'perfect4': { colors: { center: '#B39DDB', middle: '#7E57C2', outer: '#4527A0' }, border: '#283593' },
                     
                     // 記憶之路
                     'memory1': { colors: { center: '#00E5FF', middle: '#00B8D4', outer: '#006064' }, border: '#004D40' },
                     'memory2': { colors: { center: '#FFD54F', middle: '#FFB300', outer: '#F57F17' }, border: '#00838F' },
                     'memory3': { colors: { center: '#5C6BC0', middle: '#3949AB', outer: '#283593' }, border: '#2E7D32' },
                     'memory4': { colors: { center: '#26C6DA', middle: '#00ACC1', outer: '#00838F' }, border: '#558B2F' }
                 };
                 
                 // 顯示選擇的成就
                 selectedAchievements.forEach(achievement => {
                     const colorInfo = achievementColors[achievement.id];
                     if (!colorInfo) return;
                     
                     const achievementElement = document.createElement('div');
                     achievementElement.className = 'achievement-seal';
                     achievementElement.style.width = '70px';
                     achievementElement.style.height = '70px';
                     achievementElement.style.margin = '0 5px';
                     achievementElement.style.transform = 'rotate(-5deg)';
                     
                     achievementElement.innerHTML = `
                         <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                             ${createAchievementSVG(colorInfo.colors, colorInfo.border)}
                         </div>
                         <div class=\"seal-text\">
                         <span class=\"seal-title\">${achievement.title}
                         </span>
                         <span class=\"seal-desc\" style=\"font-size: 10px; opacity: 0.9;\">成就</span>
                         </div>
                     `;
                     
                     achievementsDisplay.appendChild(achievementElement);
                 });
             }
             
             // 顯示成就選擇器
             function showAchievementSelector(currentSelected) {
                 // 確保globalStats已初始化
                 if (typeof globalStats !== 'object' || globalStats === null) {
                     initializeDefaultStats();
                 }
                 
                 // 創建模態框
                 const modal = document.createElement('div');
                 modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100]';
                 modal.id = 'achievement-selector-modal';
                 
                 // 獲取可供選擇的成就
                 const availableAchievements = getAvailableAchievements();
                 
                 // 創建模態框內容
                 modal.innerHTML = `
                     <div class="bg-white dark:bg-gray-800 rounded-lg p-5 max-w-xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                         <div class="flex justify-between items-center mb-4">
                             <h3 class="text-xl font-bold text-gray-800 dark:text-gray-100">展示歷史成就</h3>
                             <button id="close-achievement-selector" class="text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:text-gray-100">
                                 <i class="fas fa-times"></i>
                             </button>
                         </div>
                         
                         <p class="text-gray-600 dark:text-gray-400 mb-4">可選擇最多三個歷史成就</p>
                         
                         <div id="achievement-list" class="space-y-4">
                             <!-- 成就列表將在這裡生成 -->
                         </div>
                         
                         <div class="flex justify-end mt-6">
                             <button id="save-achievements-btn" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-opacity-90">保存選擇</button>
                         </div>
                     </div>
                 `;
                 
                 document.body.appendChild(modal);
                 
                 // 填充成就列表
                 const achievementList = document.getElementById('achievement-list');
                 if (achievementList) {
                     // 組織成就為類別
                     const categories = [
                         {
                             name: '遊戲成就',
                             achievements: availableAchievements.filter(a => ['complete', 'lightning', 'master', 'snail', 'tireless', 'nightOwl', 'badDigestion'].includes(a.id))
                         },
                         {
                             name: '冒險之路',
                             achievements: availableAchievements.filter(a => a.id.startsWith('adventure'))
                         },
                         {
                             name: '挫敗之路',
                             achievements: availableAchievements.filter(a => a.id.startsWith('defeat'))
                         },
                         {
                             name: '極速之路',
                             achievements: availableAchievements.filter(a => a.id.startsWith('speed'))
                         },
                         {
                             name: '完美之路',
                             achievements: availableAchievements.filter(a => a.id.startsWith('perfect'))
                         },
                         {
                             name: '記憶之路',
                             achievements: availableAchievements.filter(a => a.id.startsWith('memory'))
                         },
                         {
                             name: '特殊成就',
                             achievements: availableAchievements.filter(a => ['dryEyes', 'nightOwlKing', 'focusOnEating'].includes(a.id))
                         }
                     ];
                     
                     // 只顯示有成就的類別
                     categories.forEach(category => {
                         if (category.achievements.length > 0) {
                             const categoryElement = document.createElement('div');
                             categoryElement.className = 'mb-6';
                             categoryElement.innerHTML = `
                                 <h4 class="text-lg font-medium text-amber-700 dark:text-amber-400 mb-3">${category.name}</h4>
                                 <div class="bg-gray-50 dark:bg-gray-700/50 rounded-lg p-3 grid grid-cols-1 md:grid-cols-2 gap-3 category-achievements">
                                     <!-- 成就將在這裡添加 -->
                                 </div>
                             `;
                             
                             const achievementsContainer = categoryElement.querySelector('.category-achievements');
                             
                             category.achievements.forEach(achievement => {
                                 const isSelected = currentSelected.some(a => a.id === achievement.id);
                                 
                                 const achievementItem = document.createElement('div');
                                 achievementItem.className = `p-3 border ${isSelected ? 'border-primary' : 'border-gray-200 dark:border-gray-600'} rounded-lg flex items-center achievement-item ${isSelected ? 'selected' : ''}`;
                                 achievementItem.dataset.id = achievement.id;
                                 achievementItem.dataset.title = achievement.title;
                                 
                                 achievementItem.innerHTML = `
                                     <div class="w-12 h-12 flex-shrink-0 flex items-center justify-center">
                                         <i class="${achievement.icon} text-2xl ${isSelected ? 'text-primary' : 'text-gray-500 dark:text-gray-400'}"></i>
                                     </div>
                                     <div class="ml-3 flex-1">
                                         <p class="font-medium text-gray-800 dark:text-gray-200">${achievement.title}</p>
                                         <p class="text-sm text-gray-500 dark:text-gray-400">${achievement.description}</p>
                                     </div>
                                 `;
                                 
                                 achievementsContainer.appendChild(achievementItem);
                                 
                                 // 添加點擊事件
                                     achievementItem.addEventListener('click', function() {
                                     const isCurrentlySelected = this.classList.contains('selected');
                                     const isNowSelected = !isCurrentlySelected;
                                     
                                     // 獲取當前選中的成就數量
                                     const selectedCount = document.querySelectorAll('.achievement-item.selected').length;
                                     
                                     // 如果選中數量已經達到3個且當前操作是選中，則不進行操作
                                     if (selectedCount >= 3 && isNowSelected && !isCurrentlySelected) {
                                         alert('最多只能選擇3個成就');
                                         return;
                                     }
                                     
                                 // 更新選中狀態
                                     if (isNowSelected) {
                                         this.classList.add('selected');
                                         this.classList.remove('border-gray-200', 'dark:border-gray-600');
                                         this.classList.add('border-primary');
                                         this.querySelector('i').classList.remove('text-gray-500', 'dark:text-gray-400');
                                         this.querySelector('i').classList.add('text-primary');
                                     } else {
                                         this.classList.remove('selected');
                                         this.classList.add('border-gray-200', 'dark:border-gray-600');
                                         this.classList.remove('border-primary');
                                         this.querySelector('i').classList.add('text-gray-500', 'dark:text-gray-400');
                                         this.querySelector('i').classList.remove('text-primary');
                                     }
                                 });
                             });
                             
                             achievementList.appendChild(categoryElement);
         
                         }
                     });
                     
                     // 如果沒有可用成就
                     if (availableAchievements.length === 0) {
                         achievementList.innerHTML = `
                             <div class="text-center p-6">
                                 <i class="fas fa-medal text-gray-300 dark:text-gray-600 text-4xl mb-3"></i>
                                 <p class="text-gray-600 dark:text-gray-400">您還沒有獲得任何成就</p>
                                 <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">完成更多挑戰來獲得成就！</p>
                             </div>
                         `;
                     }
                 }
                 
                 // 關閉按鈕事件
                 const closeBtn = document.getElementById('close-achievement-selector');
                 if (closeBtn) {
                     closeBtn.addEventListener('click', function() {
                         document.body.removeChild(modal);
                     });
                 }
                 
                 // 點擊背景關閉
                 modal.addEventListener('click', function(e) {
                     if (e.target === modal) {
                         document.body.removeChild(modal);
                     }
                 });
                 
                 // 保存按鈕事件
                 const saveBtn = document.getElementById('save-achievements-btn');
                 if (saveBtn) {
                     saveBtn.addEventListener('click', function() {
                         // 獲取選中的成就
                         const selectedItems = document.querySelectorAll('.achievement-item.selected');
                         const selected = [];
                         
                         selectedItems.forEach(item => {
                             selected.push({
                                 id: item.dataset.id,
                                 title: item.dataset.title
                             });
                         });
                         
                         // 保存到localStorage
                         try {
                             localStorage.setItem('MemoryMaster_selectedAchievements', JSON.stringify(selected));
                         } catch (e) {
                             console.error("保存選擇的成就出錯:", e);
                         }
                         
                         // 更新顯示
                         updateAchievementsDisplay(selected);
                         
                         // 關閉模態框
                         document.body.removeChild(modal);
                     });
                 }
             }
             
             // 獲取可用成就
             function getAvailableAchievements() {
                 const achievements = [];
                 
                 // 特殊累積成就
                 if (globalStats.achievements.dryEyes) {
                     achievements.push({ id: 'dryEyes', title: '眼乾', description: '獲得不知疲倦30次', icon: 'fas fa-eye' });
                 }
                 
                 if (globalStats.achievements.nightOwlKing) {
                     achievements.push({ id: 'nightOwlKing', title: '夜貓王', description: '獲得夜貓20次', icon: 'fas fa-crown' });
                 }
                 
                 if (globalStats.achievements.focusOnEating) {
                     achievements.push({ id: 'focusOnEating', title: '請專心吃飯', description: '獲得腸胃不好20次', icon: 'fas fa-drumstick-bite' });
                 }
                 
                 // 冒險之路成就
                 const adventureLevels = ['初心者', '勇者', '大師', '偏執狂', '掃地僧'];
                 const adventureRequirements = [1, 10, 50, 150, 300];
                 const adventureIcons = ['fas fa-hiking', 'fas fa-running', 'fas fa-dragon', 'fas fa-atom', 'fas fa-broom'];
                 
                 for (let i = 0; i < globalStats.achievements.adventureLevel; i++) {
                     achievements.push({
                         id: `adventure${i+1}`,
                         title: adventureLevels[i],
                         description: `完成${adventureRequirements[i]}次挑戰`,
                         icon: adventureIcons[i]
                     });
                 }
                 
                 // 挫敗之路成就
                 const defeatLevels = ['初嘗敗績', '堅毅', '鋼鐵意志', '小強是我', '心如止水'];
                 const defeatRequirements = [1, 5, 30, 50, 100];
                 const defeatIcons = ['fas fa-dizzy', 'fas fa-fist-raised', 'fas fa-shield-alt', 'fas fa-bug', 'fas fa-water'];
                 
                 for (let i = 0; i < globalStats.achievements.defeatLevel; i++) {
                     achievements.push({
                         id: `defeat${i+1}`,
                         title: defeatLevels[i],
                         description: `失敗${defeatRequirements[i]}次`,
                         icon: defeatIcons[i]
                     });
                 }
                 
                 // 極速之路成就
                 const speedLevels = ['敏捷', '肌肉記憶', '無影手', '世界第一束光'];
                 const speedRequirements = [1, 10, 50, 100];
                 const speedIcons = ['fas fa-tachometer-alt', 'fas fa-dumbbell', 'fas fa-hand-paper', 'fas fa-lightbulb'];
                 
                 for (let i = 0; i < globalStats.achievements.speedRouteLevel; i++) {
                     achievements.push({
                         id: `speed${i+1}`,
                         title: speedLevels[i],
                         description: `獲得閃電俠${speedRequirements[i]}次`,
                         icon: speedIcons[i]
                     });
                 }
                 
                 // 完美之路成就
                 const perfectLevels = ['如沐春風', '完美主義', '滿月', '至善'];
                 const perfectRequirements = [1, 10, 50, 100];
                 const perfectIcons = ['fas fa-wind', 'fas fa-ruler', 'fas fa-circle', 'fas fa-dove'];
                 
                 for (let i = 0; i < globalStats.achievements.perfectRouteLevel; i++) {
                     achievements.push({
                         id: `perfect${i+1}`,
                         title: perfectLevels[i],
                         description: `獲得完美無瑕${perfectRequirements[i]}次`,
                         icon: perfectIcons[i]
                     });
                 }
                 
                 // 記憶之路成就
                 const memoryLevels = ['激活腦細胞', '記憶麵包', '移動圖書館', '流如背倒'];
                 const memoryRequirements = [1, 10, 30, 50];
                 const memoryIcons = ['fas fa-brain', 'fas fa-bread-slice', 'fas fa-book', 'fas fa-stream'];
                 
                 for (let i = 0; i < globalStats.achievements.memoryRouteLevel; i++) {
                     achievements.push({
                         id: `memory${i+1}`,
                         title: memoryLevels[i],
                         description: `獲得記憶大師${memoryRequirements[i]}次`,
                         icon: memoryIcons[i]
                     });
                 }
                 
                 return achievements;
             }
             
             console.log("初始化完成");
         });
      </script>
      <script>
         // 全屏控制逻辑
         function toggleFullscreen() {
           if (!document.fullscreenElement) {
             document.documentElement.requestFullscreen();
           } else {
             document.exitFullscreen();
           }
         }
         
         // 监听全屏变化
         document.addEventListener('fullscreenchange', () => {
           if (!document.fullscreenElement) {
             // 退出全屏后的处理
             console.log('已退出全屏模式');
           }
         });
      </script>
   </body>
</html>

